<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>EVMS User Guide</title><meta name="generator" content="DocBook XSL Stylesheets V1.56.1"><meta name="generator" content="LDoc XSLT customization layer   $Revision$"><!-- Generated by LDoc XSLT customization layer
        based on Norman Walsh's DocBook XSL stylesheets v1.56.1.
        --><link rel="home" href="#evmsug" title="EVMS User Guide"><link rel="next" href="#userguidepref" title="Preface"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book"><div class="titlepage"><div><h1 class="title"><a name="evmsug"></a>EVMS User Guide</h1></div><div><div class="authorgroup"><div class="author"><h3 class="author">Christine Lorenz</h3><div class="affiliation"><span class="orgname">IBM<br></span></div></div><div class="author"><h3 class="author">Joy Goodreau</h3><div class="affiliation"><span class="orgname">IBM<br></span></div></div><div class="author"><h3 class="author">Kylie Smith</h3><div class="affiliation"><span class="orgname">IBM<br></span></div></div></div></div><div><p class="copyright">Copyright © 2003 IBM</p></div><div><div class="legalnotice"><p class="legalnotice-title"><b>Special Notices</b></p><p>The following terms are registered trademarks of International Business Machines corporation in the United States and/or other countries:  AIX, OS/2, System/390.  A full list of U.S. trademarks owned by IBM may be found at <a href="http://www.ibm.com/legal/copytrade.shtml" target="_top">http://www.ibm.com/legal/copytrade.shtml</a>.</p><p>Intel is a trademark or registered trademark of Intel Corporation in the United States, other countries, or both.</p><p>Windows is a trademark of Microsoft Corporation in the United States, other countries, or both. </p><p> Linux is a trademark of Linus Torvalds. </p><p>UNIX is a registered trademark of The Open Group in the United States and other countries.</p><p>Other company, product, and service names may be trademarks or service marks of others.</p><p>This document is provided &quot;AS IS,&quot; with no express or implied warranties. Use the information in this document at your own risk. </p></div></div><div><div class="legalnotice"><p class="legalnotice-title"><b>License Information</b></p><p>This document may be reproduced or distributed in any form without prior permission provided the copyright notice is retained on all copies. Modified versions of this document may be freely distributed provided that they are clearly identified as such, and this copyright is included intact. </p></div></div><div><p class="pubdate">November 25, 2003</p></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#userguidepref">Preface</a></dt><dt>1. <a href="#intro">What is EVMS?</a></dt><dd><dl><dt>1.1. <a href="#cando">Why choose EVMS?</a></dt><dt>1.2. <a href="#uis">The EVMS user interfaces</a></dt><dt>1.3. <a href="#terminology">EVMS terminology</a></dt><dt>1.4. <a href="#id2867359">What makes EVMS so flexible?</a></dt><dt>1.5. <a href="#LAYERDEF">Plug-in layer definitions</a></dt></dl></dd><dt>2. <a href="#evmscmuse">Using the EVMS interfaces</a></dt><dd><dl><dt>2.1. <a href="#GUI">EVMS GUI</a></dt><dd><dl><dt>2.1.1. <a href="#GUITASKS">Using context sensitive and action menus</a></dt><dt>2.1.2. <a href="#COMMIT">Saving changes</a></dt><dt>2.1.3. <a href="#refresh">Refreshing changes</a></dt><dt>2.1.4. <a href="#guiplus">Using the GUI &quot;+&quot;</a></dt><dt>2.1.5. <a href="#id2867956">Using the accelerator keys</a></dt></dl></dd><dt>2.2. <a href="#NCURSES">EVMS Ncurses interface</a></dt><dd><dl><dt>2.2.1. <a href="#NCURSESOVER">Navigating through EVMS Ncurses</a></dt><dt>2.2.2. <a href="#NCURCHANGES">Saving changes</a></dt></dl></dd><dt>2.3. <a href="#COMMANDLINE">EVMS Command Line Interpreter</a></dt><dd><dl><dt>2.3.1. <a href="#CLITASKS">Using the EVMS CLI</a></dt><dt>2.3.2. <a href="#NOTECOMMAND">Notes on commands and command files</a></dt></dl></dd></dl></dd><dt>3. <a href="#debuglevels">The EVMS log file and error data collection</a></dt><dd><dl><dt>3.1. <a href="#FSIMsupp">About the EVMS log file</a></dt><dt>3.2. <a href="#loglevels">Log file logging levels</a></dt><dt>3.3. <a href="#specifylevels">Specifying the logging levels</a></dt></dl></dd><dt>4. <a href="#evmsmigrate">Viewing compatibility volumes after migrating</a></dt><dd><dl><dt>4.1. <a href="#guimigrate">Using the EVMS GUI</a></dt><dt>4.2. <a href="#ncurmigrate">Using Ncurses</a></dt><dt>4.3. <a href="#climigrate">Using the CLI</a></dt></dl></dd><dt>5. <a href="#displaydetails">Obtaining interface display details</a></dt><dd><dl><dt>5.1. <a href="#displaygui">Using the EVMS GUI</a></dt><dt>5.2. <a href="#displaydatancurses">Using Ncurses</a></dt><dt>5.3. <a href="#id2870136">Using the CLI</a></dt></dl></dd><dt>6. <a href="#evmsassignseg">Adding and removing a segment manager</a></dt><dd><dl><dt>6.1. <a href="#whenassign">When to add a segment manager</a></dt><dt>6.2. <a href="#smtypes">Types of segment managers</a></dt><dd><dl><dt>6.2.1. <a href="#defaultseg">DOS Segment Manager</a></dt><dt>6.2.2. <a href="#gptseg">GUID Partitioning Table (GPT) Segment Manager</a></dt><dt>6.2.3. <a href="#s390sm">S/390 Segment Manager</a></dt><dt>6.2.4. <a href="#id2870583">Cluster segment manager</a></dt><dt>6.2.5. <a href="#id2870641">BSD segment manager</a></dt><dt>6.2.6. <a href="#id2870652">MAC segment manager</a></dt><dt>6.2.7. <a href="#id2870685">BBR segment manager</a></dt></dl></dd><dt>6.3. <a href="#assignsegex">Adding a segment manager to an existing disk</a></dt><dt>6.4. <a href="#assignsegnew">Adding a segment manager to a new disk</a></dt><dt>6.5. <a href="#assignex">Example: add a segment manager</a></dt><dd><dl><dt>6.5.1. <a href="#assignseggui">Using the EVMS GUI</a></dt><dt>6.5.2. <a href="#assignsegncur">Using Ncurses</a></dt><dt>6.5.3. <a href="#assignsegcli">Using the CLI</a></dt></dl></dd><dt>6.6. <a href="#removeseg">Removing a segment manager</a></dt><dt>6.7. <a href="#rmvex">Example: remove a segment manager</a></dt><dd><dl><dt>6.7.1. <a href="#removeseggui">Using the EVMS GUI context sensitive menu</a></dt><dt>6.7.2. <a href="#removesegcur">Using Ncurses</a></dt><dt>6.7.3. <a href="#removesegcli">Using the CLI</a></dt></dl></dd></dl></dd><dt>7. <a href="#evmscreateseg">Creating segments</a></dt><dd><dl><dt>7.1. <a href="#whyseg">When to create a segment</a></dt><dt>7.2. <a href="#crsegex">Example: create a segment</a></dt><dd><dl><dt>7.2.1. <a href="#guiseg">Using the EVMS GUI</a></dt><dt>7.2.2. <a href="#ncurseg">Using Ncurses</a></dt><dt>7.2.3. <a href="#cliseg">Using the CLI</a></dt></dl></dd></dl></dd><dt>8. <a href="#evmscreatecont">Creating a container </a></dt><dd><dl><dt>8.1. <a href="#whencont">When to create a container</a></dt><dt>8.2. <a href="#contex">Example: create a container</a></dt><dd><dl><dt>8.2.1. <a href="#guicont">Using the EVMS GUI</a></dt><dt>8.2.2. <a href="#ncurcont">Using Ncurses</a></dt><dt>8.2.3. <a href="#clicont">Using the CLI</a></dt></dl></dd></dl></dd><dt>9. <a href="#evmscreatereg">Creating regions</a></dt><dd><dl><dt>9.1. <a href="#id2872475">When to create regions</a></dt><dt>9.2. <a href="#crregex">Example: create a region</a></dt><dd><dl><dt>9.2.1. <a href="#guireg">Using the EVMS GUI</a></dt><dt>9.2.2. <a href="#ncurreg">Using Ncurses</a></dt><dt>9.2.3. <a href="#clireg">Using the CLI</a></dt></dl></dd></dl></dd><dt>10. <a href="#evmscreatedrivelinking">Creating drive links</a></dt><dd><dl><dt>10.1. <a href="#whatisdrivelinking">What is drive linking?</a></dt><dt>10.2. <a href="#howimp">How drive linking is implemented</a></dt><dt>10.3. <a href="#id2872992">Creating a drive link</a></dt><dt>10.4. <a href="#drivelinkex">Example: create a drive link</a></dt><dd><dl><dt>10.4.1. <a href="#guidrivelinking">Using the EVMS GUI</a></dt><dt>10.4.2. <a href="#ncursdrivelink">Using Ncurses</a></dt><dt>10.4.3. <a href="#drlinkseg">Using the CLI</a></dt></dl></dd><dt>10.5. <a href="#expandpartitions">Expanding a drive link</a></dt><dt>10.6. <a href="#shrinkdrivelink">Shrinking a drive link</a></dt><dt>10.7. <a href="#deletedrivelink">Deleting a drive link</a></dt></dl></dd><dt>11. <a href="#evmscreatesnap">Creating snapshots</a></dt><dd><dl><dt>11.1. <a href="#whatissnapshotting">What is a snapshot?</a></dt><dt>11.2. <a href="#createactivsnap">Creating and activating snapshot objects</a></dt><dd><dl><dt>11.2.1. <a href="#id2873686">Creating a snapshot</a></dt><dt>11.2.2. <a href="#id2873571">Activating a snapshot</a></dt></dl></dd><dt>11.3. <a href="#snapshotex">Example: create a snapshot</a></dt><dd><dl><dt>11.3.1. <a href="#guisnapshot">Using the EVMS GUI</a></dt><dt>11.3.2. <a href="#ncursnapshot">Using Ncurses</a></dt><dt>11.3.3. <a href="#clisnapshot">Using the CLI</a></dt></dl></dd><dt>11.4. <a href="#id2875148">Reinitializing a snapshot</a></dt><dd><dl><dt>11.4.1. <a href="#id2875186">Using the EVMS GUI or Ncurses</a></dt><dt>11.4.2. <a href="#id2875384">Using the CLI</a></dt></dl></dd><dt>11.5. <a href="#id2875436">Expanding a snapshot</a></dt><dd><dl><dt>11.5.1. <a href="#id2875514">Using the EVMS GUI or Ncurses</a></dt><dt>11.5.2. <a href="#id2875754">Using the CLI</a></dt></dl></dd><dt>11.6. <a href="#id2875808">Deleting a snapshot</a></dt><dt>11.7. <a href="#id2874456">Rolling back a snapshot</a></dt><dd><dl><dt>11.7.1. <a href="#id2874529">Using the EVMS GUI or Ncurses</a></dt><dt>11.7.2. <a href="#id2876251">Using the CLI</a></dt></dl></dd></dl></dd><dt>12. <a href="#evmscreatevol">Creating volumes</a></dt><dd><dl><dt>12.1. <a href="#id2876072">When to create a volume</a></dt><dt>12.2. <a href="#crvolexcomp">Example: create an EVMS native volume</a></dt><dd><dl><dt>12.2.1. <a href="#evmsguivol">Using the EVMS GUI</a></dt><dt>12.2.2. <a href="#ncurevmsvol">Using Ncurses</a></dt><dt>12.2.3. <a href="#id2876550">Using the CLI</a></dt></dl></dd><dt>12.3. <a href="#crvolexevms">Example: create a compatibility volume</a></dt><dd><dl><dt>12.3.1. <a href="#guicompvol">Using the GUI</a></dt><dt>12.3.2. <a href="#ncurcompatvol">Using Ncurses</a></dt><dt>12.3.3. <a href="#id2876950">Using the CLI</a></dt></dl></dd></dl></dd><dt>13. <a href="#evmsfsimops">FSIMs and file system operations</a></dt><dd><dl><dt>13.1. <a href="#FSIMsuppevms">The FSIMs supported by EVMS</a></dt><dd><dl><dt>13.1.1. <a href="#fsimjfs">JFS</a></dt><dt>13.1.2. <a href="#fsimxfs">XFS</a></dt><dt>13.1.3. <a href="#fsimreiserfs">ReiserFS</a></dt><dt>13.1.4. <a href="#fsimext23">Ext2/3</a></dt><dt>13.1.5. <a href="#fsimswapfs">SWAPFS</a></dt></dl></dd><dt>13.2. <a href="#fsimmkfs">Example: add a file system to a volume</a></dt><dd><dl><dt>13.2.1. <a href="#fsimmkfsgui">Using the EVMS GUI</a></dt><dt>13.2.2. <a href="#fsimmkfsncurses">Using Ncurses</a></dt><dt>13.2.3. <a href="#fsimmkfscli">Using the CLI</a></dt></dl></dd><dt>13.3. <a href="#fsimmkfsaex">Example: check a file system</a></dt><dd><dl><dt>13.3.1. <a href="#FSIMmkfsgui">Using the EVMS GUI</a></dt><dt>13.3.2. <a href="#fsimfsckncurses">Using Ncurses</a></dt><dt>13.3.3. <a href="#FSIMmkfscli">Using the CLI</a></dt></dl></dd></dl></dd><dt>14. <a href="#clusterops">Clustering operations</a></dt><dd><dl><dt>14.1. <a href="#id2877138">Rules and restrictions for creating cluster containers</a></dt><dt>14.2. <a href="#id2877038">Example: create a private cluster container</a></dt><dd><dl><dt>14.2.1. <a href="#id2878582">Using the EVMS GUI</a></dt><dt>14.2.2. <a href="#id2878774">Using Ncurses</a></dt><dt>14.2.3. <a href="#id2879087">Using the CLI</a></dt></dl></dd><dt>14.3. <a href="#id2879123">Example: create a shared cluster container</a></dt><dd><dl><dt>14.3.1. <a href="#id2879180">Using the EVMS GUI</a></dt><dt>14.3.2. <a href="#id2879376">Using Ncurses</a></dt><dt>14.3.3. <a href="#id2879671">Using the CLI</a></dt></dl></dd><dt>14.4. <a href="#id2879719">Example: convert a private container to a shared container</a></dt><dd><dl><dt>14.4.1. <a href="#id2879780">Using the EVMS GUI</a></dt><dt>14.4.2. <a href="#id2879906">Using Ncurses</a></dt><dt>14.4.3. <a href="#id2880165">Using the CLI</a></dt></dl></dd><dt>14.5. <a href="#id2880216">Example: convert a shared container to a private container</a></dt><dd><dl><dt>14.5.1. <a href="#id2880285">Using the EVMS GUI</a></dt><dt>14.5.2. <a href="#id2880411">Using Ncurses</a></dt><dt>14.5.3. <a href="#id2880659">Using the CLI</a></dt></dl></dd><dt>14.6. <a href="#id2880704">Example: deport a private or shared container</a></dt><dd><dl><dt>14.6.1. <a href="#id2880749">Using the EVMS GUI</a></dt><dt>14.6.2. <a href="#id2880878">Using Ncurses</a></dt><dt>14.6.3. <a href="#id2881124">Using the CLI</a></dt></dl></dd><dt>14.7. <a href="#id2881166">Deleting a cluster container</a></dt><dt>14.8. <a href="#id2881186">Failover and Failback of a private container on Linux-HA</a></dt><dt>14.9. <a href="#id2881442">Remote configuration management</a></dt><dd><dl><dt>14.9.1. <a href="#id2881471">Using the EVMS GUI</a></dt><dt>14.9.2. <a href="#id2881558">Using Ncurses</a></dt><dt>14.9.3. <a href="#id2881676">Using the CLI</a></dt></dl></dd><dt>14.10. <a href="#id2881704">Forcing a cluster container to be imported</a></dt></dl></dd><dt>15. <a href="#evmsconvert">Converting volumes</a></dt><dd><dl><dt>15.1. <a href="#id2878543">When to convert volumes</a></dt><dt>15.2. <a href="#comptoevms">Example: convert compatibility volumes to EVMS volumes</a></dt><dd><dl><dt>15.2.1. <a href="#c2egui">Using the EVMS GUI</a></dt><dt>15.2.2. <a href="#c2encur">Using Ncurses</a></dt><dt>15.2.3. <a href="#id2882270">Using the CLI</a></dt></dl></dd><dt>15.3. <a href="#evmstocomp">Example: convert EVMS volumes to compatibility volumes</a></dt><dd><dl><dt>15.3.1. <a href="#e2cgui">Using the EVMS GUI</a></dt><dt>15.3.2. <a href="#e2cncur">Using Ncurses</a></dt><dt>15.3.3. <a href="#e2ccli">Using the CLI</a></dt></dl></dd></dl></dd><dt>16. <a href="#expandshrink">Expanding and shrinking volumes</a></dt><dd><dl><dt>16.1. <a href="#whyexpandshrink">Why expand and shrink volumes?</a></dt><dt>16.2. <a href="#exshrink">Example: shrink a volume</a></dt><dd><dl><dt>16.2.1. <a href="#shrinkgui">Using the EVMS GUI</a></dt><dt>16.2.2. <a href="#shrinkncurses">Using Ncurses</a></dt><dt>16.2.3. <a href="#shrinkcli">Using the CLI</a></dt></dl></dd><dt>16.3. <a href="#mkfs">Example: expand a volume</a></dt><dd><dl><dt>16.3.1. <a href="#expandgui">Using the EVMS GUI</a></dt><dt>16.3.2. <a href="#expandncurses">Using Ncurses</a></dt><dt>16.3.3. <a href="#expandcli">Using the CLI</a></dt></dl></dd></dl></dd><dt>17. <a href="#addfeatures">Adding features to an existing volume</a></dt><dd><dl><dt>17.1. <a href="#whyadd">Why add features to a volume?</a></dt><dt>17.2. <a href="#exaddfeature">Example: add drive linking to an existing volume</a></dt><dd><dl><dt>17.2.1. <a href="#addfeaturegui">Using the EVMS GUI</a></dt><dt>17.2.2. <a href="#addfeaturesncurses">Using Ncurses</a></dt><dt>17.2.3. <a href="#addfeaturescli">Using the CLI</a></dt></dl></dd></dl></dd><dt>18. <a href="#plugintasks">Plug-in operations tasks</a></dt><dd><dl><dt>18.1. <a href="#aboutplugintasks">What are plug-in tasks?</a></dt><dt>18.2. <a href="#pluginexample">Example: complete a plug-in operations task</a></dt><dd><dl><dt>18.2.1. <a href="#plugingui">Using the EVMS GUI</a></dt><dt>18.2.2. <a href="#plugintasksncurses">Using Ncurses</a></dt><dt>18.2.3. <a href="#plugincli">Using the CLI</a></dt></dl></dd></dl></dd><dt>19. <a href="#deleterecurs">Deleting objects</a></dt><dd><dl><dt>19.1. <a href="#howtodel">How to delete objects: delete and delete recursive</a></dt><dt>19.2. <a href="#examdelrecur">Example: perform a delete recursive operation</a></dt><dd><dl><dt>19.2.1. <a href="#mkfsgui">Using the EVMS GUI</a></dt><dt>19.2.2. <a href="#mkfsncurses">Using Ncurses</a></dt><dt>19.2.3. <a href="#deleterecurcli">Using the CLI</a></dt></dl></dd></dl></dd><dt>20. <a href="#evmsreplaceobjects">Replacing objects</a></dt><dd><dl><dt>20.1. <a href="#whatisobjectreplace">What is object-replace?</a></dt><dt>20.2. <a href="#replacedlchildobj">Replacing a drive-link child object</a></dt><dd><dl><dt>20.2.1. <a href="#guiobjectreplace">Using the EVMS GUI or Ncurses</a></dt><dt>20.2.2. <a href="#clireplace">Using the CLI</a></dt></dl></dd></dl></dd><dt>21. <a href="#segstorobjs">Moving segment storage objects</a></dt><dd><dl><dt>21.1. <a href="#whatissegmove">What is segment moving?</a></dt><dt>21.2. <a href="#whymove">Why move a segment?</a></dt><dt>21.3. <a href="#id2885910">Which segment manager plug-ins implement the move function?</a></dt><dt>21.4. <a href="#movesegex">Example: move a DOS segment</a></dt><dd><dl><dt>21.4.1. <a href="#guimoveseg">Using the EVMS GUI context sensitive menu</a></dt><dt>21.4.2. <a href="#ncursmoveseg">Using Ncurses</a></dt><dt>21.4.3. <a href="#clisegmove">Using the CLI</a></dt></dl></dd></dl></dd><dt>Appendix A. <a href="#appxdos">The DOS plug-in</a></dt><dd><dl><dt>A.1. <a href="#DOShow">How the DOS plug-in is implemented</a></dt><dt>A.2. <a href="#assignDOS">Assigning the DOS plug-in</a></dt><dt>A.3. <a href="#creatingDOS">Creating DOS partitions</a></dt><dt>A.4. <a href="#expandDOS">Expanding DOS partitions</a></dt><dt>A.5. <a href="#shrinkDOS">Shrinking DOS partitions</a></dt><dt>A.6. <a href="#deleteDOS">Deleting partitions</a></dt></dl></dd><dt>Appendix B. <a href="#appxmdreg">The MD region manager</a></dt><dd><dl><dt>B.1. <a href="#createmdreg">Creating an MD region</a></dt><dt>B.2. <a href="#addremspare">Adding and removing a spare object (RAID-1 and RAID-4/5)</a></dt><dt>B.3. <a href="#rmactiveraid">Reconfiguring MD arrays</a></dt><dd><dl><dt>B.3.1. <a href="#id2887479">Expanding and shrinking MD arrays (linear and RAID-1)</a></dt><dt>B.3.2. <a href="#id2887546">Adding an active object (RAID-1 only)</a></dt><dt>B.3.3. <a href="#id2887562">Removing an active object (RAID-1 only)</a></dt></dl></dd><dt>B.4. <a href="#rmfaultyobj">Removing a faulty object (RAID-1 and RAID-4/5)</a></dt><dt>B.5. <a href="#markobjfaulty">Marking an object faulty (RAID-1 and RAID-4/5)</a></dt><dt>B.6. <a href="#replaceobj">Replacing an object</a></dt><dt>B.7. <a href="#characsraid">Characteristics of Linux RAID levels</a></dt><dd><dl><dt>B.7.1. <a href="#id2887686">Linear mode</a></dt><dt>B.7.2. <a href="#id2887794">RAID-0</a></dt><dt>B.7.3. <a href="#id2887960">RAID-1</a></dt><dt>B.7.4. <a href="#id2888088">RAID-4</a></dt><dt>B.7.5. <a href="#id2888181">RAID-5</a></dt><dt>B.7.6. <a href="#id2888281">MULTIPATH</a></dt></dl></dd></dl></dd><dt>Appendix C. <a href="#appxsnap">The LVM plug-in</a></dt><dd><dl><dt>C.1. <a href="#lvmimp">How LVM is implemented</a></dt><dt>C.2. <a href="#containerops">Container operations</a></dt><dd><dl><dt>C.2.1. <a href="#createlvmconts">Creating LVM containers</a></dt><dt>C.2.2. <a href="#id2887328">Adding objects to LVM containers</a></dt><dt>C.2.3. <a href="#id2887424">Removing objects from LVM containers</a></dt><dt>C.2.4. <a href="#id2888540">Deleting LVM containers</a></dt></dl></dd><dt>C.3. <a href="#id2888557">Region operations</a></dt><dd><dl><dt>C.3.1. <a href="#id2888563">Creating LVM regions</a></dt><dt>C.3.2. <a href="#id2888738">Expanding LVM regions</a></dt><dt>C.3.3. <a href="#id2888815">Shrinking LVM regions</a></dt><dt>C.3.4. <a href="#id2888887">Deleting LVM regions</a></dt><dt>C.3.5. <a href="#id2888902">Moving LVM regions</a></dt></dl></dd></dl></dd><dt>Appendix D. <a href="#appxcsm">The CSM plug-in</a></dt><dd><dl><dt>D.1. <a href="#csmassn">Assigning the CSM plug-in</a></dt><dt>D.2. <a href="#unassignCSM">Unassigning the CSM plug-in</a></dt><dt>D.3. <a href="#id2889526">Deleting a CSM container</a></dt></dl></dd><dt>Appendix E. <a href="#jfsfsim">JFS file system interface module</a></dt><dd><dl><dt>E.1. <a href="#createjfsfsim">Creating JFS file systems</a></dt><dt>E.2. <a href="#checkjfsfsim">Checking JFS file systems</a></dt><dt>E.3. <a href="#removejfsfsim">Removing JFS file systems</a></dt><dt>E.4. <a href="#expandjfsfsim">Expanding JFS file systems</a></dt><dt>E.5. <a href="#shrinkjfsfsim">Shrinking JFS file systems</a></dt></dl></dd><dt>Appendix F. <a href="#xfsfsim">XFS file system interface module</a></dt><dd><dl><dt>F.1. <a href="#createxfsfsim">Creating XFS file systems</a></dt><dt>F.2. <a href="#checkxfsfsim">Checking XFS file systems</a></dt><dt>F.3. <a href="#removexfsfsim">Removing XFS file systems</a></dt><dt>F.4. <a href="#expandxfsfsim">Expanding XFS file systems</a></dt><dt>F.5. <a href="#shrinkxfsfsim">Shrinking XFS file systems</a></dt></dl></dd><dt>Appendix G. <a href="#reiserfsim">ReiserFS file system interface module</a></dt><dd><dl><dt>G.1. <a href="#createreiserfsim">Creating ReiserFS file systems</a></dt><dt>G.2. <a href="#checkreiserfsim">Checking ReiserFS file systems</a></dt><dt>G.3. <a href="#removexreiserfsim">Removing ReiserFS file systems</a></dt><dt>G.4. <a href="#expandreiserFSfsim">Expanding ReiserFS file systems</a></dt><dt>G.5. <a href="#shrinkreiserfsim">Shrinking ReiserFS file systems</a></dt></dl></dd><dt>Appendix H. <a href="#ext23fsim">Ext-2/3 file system interface module</a></dt><dd><dl><dt>H.1. <a href="#createext23fsim">Creating Ext-2/3 file systems</a></dt><dt>H.2. <a href="#checkext23fsim">Checking Ext-2/3 file systems</a></dt><dt>H.3. <a href="#removereiserfsim">Removing Ext-2/3 file systems</a></dt><dt>H.4. <a href="#expandshrinkext23fsim">Expanding and shrinking Ext-2/3 
file systems</a></dt></dl></dd></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>4.1. <a href="#id2869361">GUI start-up window</a></dt><dt>4.2. <a href="#id2869253">Ncurses start-up window</a></dt><dt>4.3. <a href="#id2869844">CLI volume query results</a></dt></dl></div><div class="preface"><div class="titlepage"><div><h2 class="title"><a name="userguidepref"></a>Preface</h2></div></div><p>This guide tells how to configure and manage Enterprise
Volume Management System (EVMS).  EVMS is a storage management program
that provides a single framework for managing and administering your system's storage.</p><p>This guide is intended for Linux system administrators and users who are
responsible for setting up and maintaining EVMS.</p><p>For additional information about EVMS or to ask questions specific to 
your distribution, refer to the EVMS mailing lists. You can view  the list 
archives or subscribe to the lists from 
the <a href="http://evms.sourceforge.net/mailinglists.html" target="_top">EVMS Project 
web site</a>.</p><p>The following table shows how this guide is organized:</p><div class="table"><a name="bookorg"></a><p class="title"><b>Table 1. Organization of the EVMS User Guide</b></p><table summary="Organization of the EVMS User Guide" border="1"><colgroup><col><col></colgroup><thead><tr><th>Chapter or appendix title</th><th>Contents</th></tr></thead><tbody><tr><td>1. What is EVMS?</td><td>Discusses general EVMS concepts and terms.</td></tr><tr><td>2. Using the EVMS interfaces</td><td>Describes the three EVMS user interfaces and how to use them.</td></tr><tr><td>3. The EVMS log file and error data collection</td><td>Discusses the EVMS information and error log file and explains how to change the logging level.</td></tr><tr><td>4. Viewing compatibility volumes after migrating</td><td>Tells how to view existing files that have been migrated to EVMS.</td></tr><tr><td>5. Obtaining interface display details</td><td>Tells how to view detailed information about EVMS objects.</td></tr><tr><td>6. Adding and removing a segment manager</td><td>Discusses segments and explains how to add and remove a segment manager.</td></tr><tr><td>7. Creating segments</td><td>Explains when and how to create segments.</td></tr><tr><td>8. Creating containers</td><td>Discusses containers and explains when and how to create them.</td></tr><tr><td>9. Creating regions</td><td>Discusses regions and explains when and how to create them.</td></tr><tr><td>10. Creating drive links</td><td>Discusses the drive linking feature and tells how to create a drive link.</td></tr><tr><td>11. Creating snapshots</td><td>Discusses snapshotting and tells how to create a snapshot.</td></tr><tr><td>12. Creating volumes</td><td>Explains when and how to create volumes.</td></tr><tr><td>13. FSIMs and file system operations</td><td>Discusses the standard FSIMs shipped with EVMS and provides examples of adding file systems and coordinating file checks with the FSIMs.</td></tr><tr><td>14. Clustering operations</td><td>Describes EVMS clustering and how to create private and shared containers.</td></tr><tr><td>15. Converting volumes</td><td>Explains how to convert EVMS native volumes to compatibility volumes and compatibility volumes to EVMS native volumes.</td></tr><tr><td>16. Expanding and shrinking volumes</td><td>Tells how to expand and shrink EVMS volumes with the various EVMS user interfaces.</td></tr><tr><td>17. Adding features to an existing volume</td><td>Tells how to add additional features, such as drive linking and bad block relocation, to an existing volume.</td></tr><tr><td>18. Plug-in operations tasks</td><td>Discusses the plug-in tasks that are available within the context of a particular plug-in.</td></tr><tr><td>19. Deleting objects</td><td>Tells how to safely delete EVMS objects.</td></tr><tr><td>20. Replacing objects</td><td>Tells how to change the 
configuration of a volume or storage object.</td></tr><tr><td>21. Moving segment storage objects</td><td>Discusses how to use
the move function for moving segments.</td></tr><tr><td>A. The DOS link plug-in</td><td>Provides details about the DOS link plug-in, which is a segment manager plug-in.</td></tr><tr><td>B. The MD region manager</td><td>Explains the Multiple Disks (MD) support in Linux that is a software implementation of RAID.</td></tr><tr><td>C. The LVM plug-in</td><td>Tells how the LVM plug-in is implemented and how to perform container operations.</td></tr><tr><td>D. The CSM plug-in</td><td>Explains how the Cluster Segment Manager (CSM) plug-in is implemented and how to perform CSM operations.</td></tr><tr><td>E. JFS file system interface module</td><td>Provides information about the JFS FSIM.</td></tr><tr><td>F. XFS file system interface module</td><td>Provides information about the XFS FSIM.</td></tr><tr><td>G. ReiserFS file system interface module</td><td>Provides information about the ReiserFS FSIM.</td></tr><tr><td>H. Ext-2/3 file system interface module</td><td>Provides information about the Ext-2/3 FSIM.</td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="intro"></a>Chapter 1. What is EVMS?</h2></div></div><p>EVMS brings a new model of volume management to Linux®. 
EVMS integrates all aspects of volume management, 
such as disk partitioning, Linux logical volume manager (LVM) and 
multi-disk (MD) management, OS2 and AIX volume managers, and file system operations into a single 
cohesive package. 
With EVMS, various volume management technologies are accessible through 
one interface, and new technologies can be added as plug-ins as they are developed.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="cando"></a>1.1. Why choose EVMS?</h2></div></div><p>EVMS lets you manage storage space in a way that is more 
intuitive and flexible than many other Linux volume management systems. 
Practical tasks, such as migrating disks or adding new disks to your 
Linux system, become more manageable with EVMS because EVMS can  
recognize and read from different volume types and file systems. 
EVMS provides additional safety controls by not allowing commands that are
unsafe.
These controls help maintain the integrity of the data stored on the system.</p><p>You can use EVMS  to create and manage data storage. 
With EVMS, you can use multiple volume management technologies under one 
framework while ensuring your system still interacts correctly with 
stored data. 
With EVMS, you are can use bad block relocation, shrink and expand volumes, 
create snapshots of your volumes, and set up RAID (redundant array of independent devices) features for your system. 
You can also use many types of file systems and manipulate these storage pieces 
in ways that best meet the needs of your particular work environment.</p><p>EVMS also provides the capability to manage data on storage that is
physically shared by nodes in a cluster.  This shared storage allows data to
be highly available from different nodes in the cluster.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="uis"></a>1.2. The EVMS user interfaces</h2></div></div><p>There are currently three user interfaces available for EVMS: graphical (GUI), text mode (Ncurses), and the Command Line Interpreter (CLI). 
Additionally, you can use the EVMS Application Programming Interface to implement your own customized user interface. </p><p><a href="#userinterf" title="Table 1.1. EVMS user interfaces">Table 1.1</a> tells more about each of the EVMS user interfaces.

</p><div class="table"><a name="userinterf"></a><p class="title"><b>Table 1.1. EVMS user interfaces</b></p><table summary="EVMS user interfaces" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>User interface</th><th>Typical user</th><th>Types of use</th><th>Function</th></tr></thead><tbody><tr><td>GUI</td><td>All</td><td>All uses except automation</td><td>Allows you to choose from available options only, instead of having to sort through all the options, including ones that are not available at that point in the process. </td></tr><tr><td>Ncurses</td><td>Users who don't have GTK libraries or X Window Systems on their machines</td><td>All uses except automation</td><td>Allows you to choose from available options only, instead of having to sort through all the options, including ones that are not available at that point in the process. </td></tr><tr><td>Command Line</td><td>Expert</td><td>All uses</td><td>Allows easy automation of  tasks</td></tr></tbody></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="terminology"></a>1.3. EVMS terminology</h2></div></div><p>To avoid confusion with other terms that describe volume 
	management in general, EVMS uses a specific set of terms. 
	These terms are listed, from most fundamental to most comprehensive, 
	as follows:
	</p><div class="variablelist"><dl><dt><b>Logical disk</b></dt><dd><p>Representation of anything EVMS can access as a physical disk. 
		In EVMS, physical disks are logical disks.</p></dd><dt><b>Sector</b></dt><dd><p>The lowest level of addressability on a block
		device. This definition is in keeping with the standard
		meaning found in other management systems.</p></dd><dt><b>Disk segment</b></dt><dd><p>An ordered set of physically contiguous
		sectors residing on the same storage object. 
		The general analogy for a segment is to a traditional disk
		partition, such as DOS or OS/2 ®</p></dd><dt><b>Storage region</b></dt><dd><p>An ordered set of logically contiguous sectors
		that  are not necessarily physically contiguous. </p></dd><dt><b>Storage object</b></dt><dd><p>Any persistent memory structure in EVMS that can be used to 
		build objects or create a volume. Storage object is a  generic term for disks, segments, regions, and feature objects.</p></dd><dt><b>Storage container</b></dt><dd><p>A collection of storage objects. A storage
		container consumes one set of storage objects and produces new 
		storage objects. One common subset of storage containers is volume groups, 
		such as AIX®  or LVM.</p><p>Storage containers can be either of type private or cluster.</p></dd><dt><b>Cluster storage container</b></dt><dd><p>Specialized storage containers that consume only disk objects 
	that are physically accessible from all nodes of a cluster.</p><div class="variablelist"><dl><dt><b>Private storage container</b></dt><dd><p>A collection of disks that are physically accessible from all
	nodes of a cluster, managed as a single pool of storage, and owned and accessed
	by a single node of the cluster at any given time.</p></dd><dt><b>Shared storage container</b></dt><dd><p>A collection of disks that are physically accessible from all
	nodes of a cluster, managed as a single pool of storage, and owned and accessed
	by all nodes of the cluster simultaneously.</p></dd><dt><b>Deported storage container</b></dt><dd><p>A shared cluster container that is not owned by any node of the cluster.</p></dd></dl></div></dd><dt><b>Feature object</b></dt><dd><p>A storage object that contains an EVMS native feature, such as 
		bad block relocation. </p><p>An <i>EVMS Native Feature</i> is a  function of volume management designed 
		and implemented by 
		EVMS. These features are not intended to be backward compatible with other 
		volume management technologies. </p></dd><dt><b>Logical volume</b></dt><dd><p>A volume that consumes a storage object and exports 
		something mountable. There are two varieties of logical volumes: <i>EVMS Volumes</i> 
		and <i>Compatibility volumes</i>.</p><p> <i>EVMS  Volumes</i> contain EVMS native metadata and can support all 
		EVMS features. <tt>/dev/evms/my_volume</tt> would be an example 
		of an EVMS Volume.</p><p><i>Compatibility volumes</i> do not contain any EVMS native metadata. 
		Compatibility volumes are backward compatible to their particular scheme, but 
		they cannot support EVMS features. <tt>/dev/evms/md/md0</tt> would 
		be an example of a compatibility  volume. </p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2867359"></a>1.4. What makes EVMS so flexible?</h2></div></div><p>There are numerous drivers in the Linux kernel, such as Device
Mapper and MD (software RAID), that implement volume management schemes.  EVMS is built
on top of these drivers to provide one framework for combining and
accessing the capabilities.</p><p>The EVMS Engine handles the creation,
configuration, and management of volumes, segments, and disks.
The EVMS Engine is a programmatic interface to the EVMS system.
User interfaces and programs that use EVMS must go through the Engine.</p><p>EVMS provides the capacity for plug-in modules to the Engine that
allow EVMS to perform specialized tasks without altering the core code.
These plug-in modules allow EVMS to be more extensible and customizable than
other volume management systems.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="LAYERDEF"></a>1.5. Plug-in layer definitions</h2></div></div><p>EVMS defines a layered architecture where plug-ins in each layer
		create abstractions of the layer or layers below. EVMS also allows most plug-ins
		to create abstractions of objects within the same layer. The following
		list defines these layers from the bottom up.</p><div class="variablelist"><dl><dt><b>Device managers</b></dt><dd><p>The first (bottom) layer consists
			of device managers.
			These plug-ins communicate with hardware device drivers to
			create the first EVMS objects. Currently, all devices are handled by a single plug-in.
			Future releases of EVMS might need additional device managers
			for network device management (for example, to manage
			disks on a storage area network (SAN)).</p></dd><dt><b>Segment managers</b></dt><dd><p>The second layer consists of segment 
			managers. These plug-ins
			 handle the segmenting, or partitioning,
			of disk drives. The Engine components can replace partitioning
			programs, such as <b>fdisk</b> and
			Disk Druid, and EVMS
			uses Device Mapper to replace the in-kernel disk
			partitioning code. 
			Segment managers can also be &quot;stacked,&quot; meaning that 
			one segment manager
			can take as input the output from another segment 
			manager.</p><p> EVMS provides the following segment managers: 
			DOS, GPT, System/390® (S/390), Cluster, and BSD. Other segment manager
			plug-ins can be added to support other 
			partitioning schemes.</p></dd><dt><b>Region managers</b></dt><dd><p>The third layer consists of region 
			managers. 
			This layer provides a place for plug-ins that ensure
			compatibility with existing volume management schemes 
			in Linux and other operating systems. 
			Region managers are intended to model systems that 
			provide a logical abstraction above disks
			or partitions.</p><p>Like segment managers, region managers can 
			also be stacked. 
			Therefore, the input object(s) to a region manager can
			be disks, segments, or other regions.</p><p>There are currently four region manager plug-ins in EVMS: 
			Linux LVM, AIX, OS/2, and Multi-Disk (MD).
			</p><div class="variablelist"><dl><dt><b>Linux LVM</b></dt><dd><p>The Linux LVM plug-in provides compatibility with
				the Linux LVM and allows the creation of volume groups 
				(known in EVMS as containers) and logical volumes 
				(known in EVMS as regions). </p></dd><dt><b>AIX LVM</b></dt><dd><p>The AIX LVM provides compatibility with AIX and is similar in functionality 
				to the Linux LVM by also using volume groups and logical 
				volumes. </p></dd><dt><b>OS/2 LVM</b></dt><dd><p>The OS/2 plug-in provides compatibility with 
				volumes created under
				OS/2. Unlike the Linux and AIX LVMs, the OS/2 LVM 
				is based on linear linking of disk partitions, as well as
				bad-block relocation. The OS/2 LVM does not allow for modifications.</p></dd><dt><b>MD</b></dt><dd><p>The Multi-Disk (MD) plug-in for RAID provides 
				RAID levels linear, 0, 1, 4, and 5 in 
				software. MD is one plug-in that displays as four region
				managers that you can choose from.</p></dd></dl></div></dd><dt><b>EVMS features</b></dt><dd><p>The next layer consists of EVMS 
			features. This layer is
			where new EVMS-native functionality is implemented. EVMS
			features can be built on any object in the system, including
			disks, segments, regions, or other feature objects. 
			All EVMS features share a common type of metadata, 
			which makes discovery of feature objects much more 
			efficient, and recovery
			of broken features objects much more reliable. There are three 
			features currently available in EVMS: drive linking, Bad 
			Block Relocation, and snapshotting. </p><div class="variablelist"><dl><dt><b>Drive Linking</b></dt><dd><p>Drive linking allows any
			number of objects to be linearly concatenated together into a
			single object. A drive linked volume can be expanded by 
			adding another storage object to the end or shrunk by removing the last object.</p></dd><dt><b>Bad Block Relocation</b></dt><dd><p>Bad Block Relocation (BBR)
			monitors its I/O path and detects write failures (which can be
			caused by a damaged disk). In the event of such a failure, the
			data from that request is stored in a new location. BBR keeps
			track of this remapping. Additional I/Os to that
			location are redirected to the new location.</p></dd><dt><b>Snapshotting</b></dt><dd><p>The Snapshotting feature provides
			a mechanism for creating a &quot;frozen&quot; copy of a volume at a single
			instant in time, without having to take that volume off-line.
			This is useful for performing backups on a live system.
			Snapshots work with any volume (EVMS or compatibility), and can
			use any other available object as a backing store. After a
			snapshot is created and made into an EVMS volume, writes to the &quot;original&quot; volume cause the
			original contents of that location to be copied to the snapshot's
			storage object. Reads to the snapshot volume look like they
			come from the original at the time the snapshot was created.
</p></dd></dl></div></dd><dt><b>File System Interface Modules</b></dt><dd><p>File System Interface Modules (FSIMs) 
			provide coordination with the
			file systems during certain volume management 
			operations. For
			instance, when expanding or shrinking a volume, 
			the file system
			must also be expanded or shrunk to the appropriate size.
			Ordering in this example is also important; 
			a file system cannot
			be expanded before the volume, and a volume cannot 
			be shrunk before the file system. 
			The FSIMs allow EVMS to ensure this
			coordination and ordering.</p><p>FSIMs also perform file system
			operations from one of the EVMS user interfaces. For instance,
			a user can make new file systems and check existing file systems
			by interacting with the FSIM.</p></dd><dt><b>Cluster Manager Interface Modules</b></dt><dd><p>Cluster Manager Interface Modules, also
		known as the EVMS Clustered Engine (ECE), interface
		with the local cluster manager installed on the system.
		The ECE provides a standardized ECE API to the Engine
		while hiding cluster manager details from the Engine.</p></dd></dl></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmscmuse"></a>Chapter 2. Using the EVMS interfaces</h2></div></div><p>This chapter explains how to use the EVMS GUI, Ncurses, and CLI interfaces.
This chapter also
includes information about basic navigation and commands available through
the CLI. </p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="GUI"></a>2.1. EVMS GUI</h2></div></div><p>The EVMS GUI is a flexible and easy-to-use
	interface for administering volumes and storage objects. 
	Many users find the EVMS GUI easy to use because it displays which
	storage objects, actions, and plug-ins are acceptable for a
	particular task.</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="GUITASKS"></a>2.1.1. Using context sensitive and action menus</h3></div></div><p>The EVMS GUI lets you accomplish most
		tasks in one of two ways: context sensitive menus or the
		<b>Actions</b> menu.</p><p>Context sensitive menus are available from any
		of the main &quot;views.&quot; Each view corresponds to a
		page in a notebook widget located on the EVMS
		GUI main window. These views are made up of different
		trees or lists that visually represent the organization of
		different object types, including volumes,
		feature objects, regions, containers, segments, or disks. </p><p>You can view the context
		sensitive menu for an object by right-clicking on that
		object. The actions that are available
		for that object display on
		the screen. The GUI will only present actions that are 
		acceptable for the selected object at that point in the 
		process. These actions are not always a complete set. </p><p>To use the <b>Actions</b> menu,
		choose <b>Action</b>-&gt;<b>&lt;the action you want
				to accomplish&gt;</b>-&gt;<b>&lt;options&gt;</b>. 
			The <b>Actions</b> menu 
		provides a more guided path for
		completing a task than do context sensitive menus. The
			<b>Actions</b> option is similar to the 
		wizard or druid approach used by many GUI applications.</p><p>All of the operations you need to
			perform as an administrator are available through
			the <b>Actions</b> menu.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="COMMIT"></a>2.1.2. Saving changes</h3></div></div><p>All of the changes that you make while in the EVMS
		GUI are only in memory until you save the changes.
		In order to make your changes
		permanent, you must save
		all changes before exiting. If you
		forget to save the changes and decide to exit or close the
		EVMS GUI, you are reminded to save any
		pending changes.</p><p>To explicitly save all the changes you
		made, select <b>Action</b>-&gt;<b>Save</b>, and click
		the <b>Save</b> button.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="refresh"></a>2.1.3. Refreshing changes</h3></div></div><p>The <b>Refresh</b> button updates the view and allows 
you to see changes, like mount points, that might have changed outside of 
the GUI.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guiplus"></a>2.1.4. Using the GUI &quot;+&quot;</h3></div></div><p>Along the left hand side of the panel views in the GUI is a &quot;+&quot; that resides
beside each item.  When you click the &quot;+,&quot;  the objects that are included
in the item are displayed.  If any of the objects that display also have a &quot;+&quot; beside them, you can expand them further by clicking on the &quot;+&quot; next to each object name.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2867956"></a>2.1.5. Using the accelerator keys</h3></div></div><p>You can avoid using a mouse for navigating the EVMS GUI by using a series of
key strokes, or &quot;accelerator keys,&quot; instead.  The following sections tell how to use
accelerator keys in the EVMS Main Window, the Selection Window, and the Configuration
Options Window.</p><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2867970"></a>2.1.5.1. Main Window accelerator keys</h4></div></div><p>In the Main Window view, use the following keys to navigate:

</p><div class="table"><a name="id2867981"></a><p class="title"><b>Table 2.1. Accelerator keys in the Main Window</b></p><table summary="Accelerator keys in the Main Window" border="1"><colgroup><col><col></colgroup><tbody><tr><td>Left and right arrow keys</td><td>Navigate between the notebook tabs of the different views.</td></tr><tr><td>Down arrow and <b>Spacebar</b></td><td>Bring keyboard focus into the view.</td></tr></tbody></table></div><p>
</p><p>
While in a view, use the following keys to navigate:

</p><div class="table"><a name="id2868043"></a><p class="title"><b>Table 2.2. Accelerator keys in the views</b></p><table summary="Accelerator keys in the views" border="1"><colgroup><col><col></colgroup><tbody><tr><td>up and down arrows</td><td>Allow movement around the window.</td></tr><tr><td>&quot;+&quot;</td><td>Opens an object tree.</td></tr><tr><td>&quot;-&quot;</td><td>Collapses an object tree.</td></tr><tr><td><b>ENTER</b></td><td>Brings up the context menu (on a row).</td></tr><tr><td>Arrows</td><td>Navigate a context menu.</td></tr><tr><td><b>ENTER</b></td><td><p>Activates an item.</p></td></tr><tr><td><b>ESC</b></td><td>Dismisses the context menu.</td></tr><tr><td><b>Tab</b></td><td>Gets you out of the view and moves you back up to the notebook tab.</td></tr></tbody></table></div><p>
 
</p><p>
To access the action bar menu, press <b>Alt</b> and 
then the underlined
accelerator key for the menu choice (for example, &quot;A&quot; for the 
<b>Actions</b>
dropdown menu).
</p><p>In a dropdown menu, you can use the up and down arrows
to navigate.  You could also just type the accelerator key for the menu
item, which is the character with the underscore.  For example, to initiate
a command to delete a container, type <b>Alt</b> + &quot;A&quot; + &quot;D&quot; + &quot;C.&quot;</p><p>
<b>Ctrl-S</b> is a shortcut to initiate saving changes.  
<b>Ctrl-Q</b> is a shortcut to initiate quitting the EVMS GUI.
</p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2868217"></a>2.1.5.2. Accelerator keys in the selection window </h4></div></div><p>
A selection window typically contains a selection list, plus four to five
buttons below it.  Use the following keys to navigate in the selection window:

</p><div class="table"><a name="id2868230"></a><p class="title"><b>Table 2.3. Accelerator keys in the selection window</b></p><table summary="Accelerator keys in the selection window" border="1"><colgroup><col><col></colgroup><tbody><tr><td><b>Tab</b></td><td>Navigates (changes keyboard focus) between the list and the buttons.</td></tr><tr><td>Up and down arrows</td><td>Navigates within the selection list.</td></tr><tr><td><b>Spacebar</b></td><td>Selects and deselects items in the selection list.</td></tr><tr><td><b>Enter</b> on the button or type the accelerator character (if one exists)</td><td>Activates a button</td></tr></tbody></table></div><p>

</p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2868313"></a>2.1.5.3. Configuration options window accelerator keys</h4></div></div><p>
Use the following keys to navigate in the configuration options window:

</p><div class="table"><a name="id2868324"></a><p class="title"><b>Table 2.4. Accelerator keys in the configuration options window</b></p><table summary="Accelerator keys in the configuration options window" border="1"><colgroup><col><col></colgroup><tbody><tr><td><b>Tab</b></td><td>Cycles focus between fields and buttons</td></tr><tr><td>Left and right arrows</td><td>Navigate the folder tabs if the window has a widget notebook.</td></tr><tr><td><b>Spacebar</b> or the down arrow</td><td>Switches focus to a different notebook page.</td></tr><tr><td><b>Enter</b> or type the accelerator character (if one exists)</td><td>Activates a button</td></tr></tbody></table></div><p>

</p><p>For widgets, use the following keys to navigate:

</p><div class="table"><a name="id2868411"></a><p class="title"><b>Table 2.5. Widget navigation keys in the configuration options window </b></p><table summary="Widget navigation keys in the configuration options window " border="1"><colgroup><col><col></colgroup><tbody><tr><td><b>Tab</b></td><td>Cycles forward through a set of widgets</td></tr><tr><td><b>Shift-Tab</b></td><td>Cycles backward through a set of widgets.</td></tr></tbody></table></div><p>

</p><p>
The widget navigation, selection, and activation is the same in all dialog
windows.
</p></div></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="NCURSES"></a>2.2. EVMS Ncurses interface</h2></div></div><p>The EVMS Ncurses (<b>evmsn</b>) user interface is a menu-driven
	interface with characteristics similar to those of the EVMS GUI. 
	Like the EVMS GUI,
	<b>evmsn</b> can accommodate new plug-ins and features without requiring any code
	changes.</p><p>The EVMS Ncurses user interface
	allows you to manage volumes on systems that do not have the X
	and GTK+ libraries that are required by the EVMS GUI.</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="NCURSESOVER"></a>2.2.1. Navigating through EVMS Ncurses</h3></div></div><p>The EVMS Ncurses user interface initially
	     	displays a list of logical volumes similar to the
	     logical volumes view in the EVMS GUI.  Ncurses also provides
		a menu bar similar to the menu bar in the EVMS GUI.</p><p>A general guide to navigating through the layout of the
		Ncurses window is listed below:</p><div class="itemizedlist"><ul type="disc"><li><p><b>Tab</b> cycles you through the available 
			views.</p></li><li><p>Status messages and tips are displayed on
			the last line of the screen.</p></li><li><p>Typing the accelerator character (the
			letter highlighted in red) for any menu item activates
			that item.  For example, typing <b>A</b> in any view brings
			down the <b>Actions</b> menu.</p></li><li><p>Typing <b>A</b> + <b>Q</b> in a view 
			quits the application.</p></li><li><p>Typing <b>A</b> + <b>S</b> in a view 
			saves changes
			made during an <b>evmsn</b> session.</p></li><li><p>Use the <b>up</b> and <b>down</b> 
			arrows to highlight an object in a view.  Pressing
			<b>Enter</b> while an object in a view is
			highlighted presents a context popup menu.</p></li><li><p>Dismiss a context popup menu by pressing
			<b>Esc</b> or by selecting a menu item with the
			<b>up</b> and <b>down</b> arrows and pressing 
			<b>Enter</b> to 
			activate the menu item.</p></li></ul></div><p>Dialog windows are similar in design to the EVMS GUI
dialogs, which allow a user to navigate forward and backward through a series
of dialogs using <b>Next</b> and <b>Previous</b>.  A general
guide to dialog windows is listed below:</p><div class="itemizedlist"><ul type="disc"><li><p><b>Tab</b> cycles you through the available buttons.  Note
that some buttons might not be available until a valid selection is made.</p></li><li><p>The <b>left</b> and <b>right</b> arrows can also be used
to move to an available button.</p></li><li><p>Navigate a selection list with the <b>up</b> and 
<b>down</b> arrows.</p></li><li><p>Toggle the selection of an item in a list with <b>spacebar</b>.</p></li><li><p>Activate a button that has the current focus with <b>Enter</b>.  If the button has
an accelerator character (highlighted in red), you can also activate the button
by typing the accelerator character regardless of whether the button has the current
focus.</p></li></ul></div><p>The EVMS Ncurses user interface, like the EVMS GUI, provides context menus
for actions that are available only to the selected object in a view.  Ncurses also provides
context menus for items that are
available from the <b>Actions</b> menu.  These context menus present
a list of commands available for a certain object.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="NCURCHANGES"></a>2.2.2. Saving changes</h3></div></div><p>All changes you make while in the EVMS
		Ncurses are only in memory until you save the changes.
		In order to make the changes permanent, save
		all changes before exiting. If you
		forget to save the changes and decide to exit the EVMS Ncurses
		interface, you will be reminded of the unsaved changes and
		be given the chance to save or discard the changes before exiting.</p><p>To explicitly save all changes,  press <b>A</b> + <b>S</b> and confirm
		that you want to save changes.</p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="COMMANDLINE"></a>2.3. EVMS Command Line Interpreter</h2></div></div><p>The EVMS Command Line Interpreter (EVMS CLI) provides a
	command-driven user interface for EVMS. The EVMS CLI 
	helps automate volume management tasks
	and provides an interactive mode in situations where the
	EVMS GUI is not available.</p><p>Because the EVMS CLI is an interpreter, it operates
	differently than command line utilities for the
	operating system. The options you specify 
	on the EVMS CLI command line to invoke the EVMS 
	CLI control how the EVMS CLI operates. For example, the 
	command line options tell the CLI where to go for commands to 
	interpret and how
	often the EVMS CLI must commit changes to disk. 
	When invoked, the EVMS CLI prompts for commands. </p><p>The volume management commands the EVMS CLI understands
	are specified in the <tt>/usr/src/evms-2.2.0/engine2/ui/cli/grammar.ps</tt> 
	file that accompanies the EVMS
	package.  These commands are described in detail in the EVMS
	man page, and help on these commands is available from within the EVMS
	CLI. </p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="CLITASKS"></a>2.3.1. Using the EVMS CLI</h3></div></div><p>Use the <b>evms</b> command to start
	  the EVMS CLI. If you do not enter an option with
	  <b>evms</b>, the EVMS CLI starts in
	  interactive mode. In interactive mode, the EVMS CLI prompts
	  you for commands. The result of each command is immediately saved
	  to disk. The EVMS CLI exits when you type <b><tt>exit</tt></b>. 
	You can modify this behavior by using
	  the following options with <b>evms</b>: 

	  </p><div class="variablelist"><dl><dt><b>-b</b></dt><dd><p>This option indicates that you are running in
		batch mode and anytime there is a prompt for input from the user,
		the default value is accepted automatically.  This is the
		default behavior with the <b>-f</b> option.</p></dd><dt><b>-c</b></dt><dd><p>This option commits changes to disk
		only when EVMS CLI exits, not after
		each command.</p></dd><dt><b>-f <i><tt>filename</tt></i></b></dt><dd><p>This option tells the EVMS CLI to use
		<i><tt>filename</tt></i> as the source of
		commands. The EVMS CLI exits when it reaches the
		end of
		<i><tt>filename</tt></i>.
		</p></dd><dt><b>-p</b></dt><dd><p>This option only parses commands; it does
		not execute them.
		When combined with the <b>-f</b> option, the 
		<b>-p</b> option detects syntax errors in 
		command files. </p></dd><dt><b>-h</b></dt><dd><p>This option displays help information
		for options used with the <b>evms</b>
		command.</p></dd><dt><b>-rl</b></dt><dd><p>This option tells the CLI that all remaining items on the 
		command line are replacement parameters for use with 
		EVMS commands. </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>Replacement parameters are accessed in EVMS commands using the 
		<tt>$(x)</tt> notation, where <i><tt>x</tt></i> is the number identifying which 
		replacement parameter to use. Replacement parameters are assigned 
		numbers (starting with 1) as they are encountered on the command line. 
		Substitutions are not made within comments or quoted strings. </p><p>An example would be:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">evms -c -f testcase -rl sda sdb</pre></td></tr></table><p>
		<tt>sda</tt> is the replacement for <i><tt>parameter1</tt></i> and 
		<tt>sdb</tt> is the replacement for <i><tt>parameter2</tt></i></p></div></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>Information on less commonly used options is available 
		in the EVMS man page. </p></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="NOTECOMMAND"></a>2.3.2. Notes on commands and command files</h3></div></div><p>The EVMS CLI allows multiple commands to be displayed
		on a command line.  When you specify multiple commands on a
		single command line, separate the commands with
		a colon ( : ).  This is
		important for command files because the EVMS CLI sees
		a command file as a single long command line.  The
		EVMS CLI has no concept of lines in the file and
		ignores spaces. These features allow a command in
		a command file to span several lines and use whatever
		indentation or margins that are convenient. The only
		requirement is that the command separator (the colon) be present
		between commands.</p><p>The EVMS CLI ignores spaces unless they 
		occur within quote marks. Place in quotation marks a name that contains
		spaces or other non-printable or control characters.  If the name
		contains a quotation mark as part of the name, the
		quotation mark must be &quot;doubled,&quot; as shown in the following 
		example:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">&quot;This is a name containing &quot;&quot;embedded&quot;&quot; quote marks.&quot;</pre></td></tr></table><p>EVMS CLI keywords are not case sensitive, but EVMS
		names are case sensitive. Sizes can be input in any units with a unit label, such as KB, MB, GB, or TB.</p><p>Finally, C programming language style comments
		are supported by the EVMS CLI.  Comments can begin and
		end anywhere except within a quoted string, as shown in the
		following example:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">/* This is a comment */
Create:Vo/*This is a silly place for a comment, but it is
allowed.*/lume,&quot;lvm/Sample Container/My LVM
Volume&quot;,compatibility</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="debuglevels"></a>Chapter 3. The EVMS log file and error data collection</h2></div></div><p>This chapter discusses the EVMS information and error log file and the various logging levels.  It also explains how to change the logging level.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="FSIMsupp"></a>3.1. About the EVMS log file</h2></div></div><p>The EVMS Engine creates a log file called <tt>/var/log/evmsEngine.log</tt> every time the Engine is opened.  The Engine also saves copies of up to 10 previous Engine sessions in the files <tt>/var/log/evmsEngine.n.log</tt>, where <tt>n</tt> is the number of the session between 1 and 10.  </p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="loglevels"></a>3.2. Log file logging levels</h2></div></div><p>There are several possible logging levels that you can choose to be collected in <tt>/var/log/evmsEngine.log</tt>.  The &quot;lowest&quot; logging level, <tt>critical</tt>, collects only messages about serious system problems, whereas the &quot;highest&quot; level, <tt>everything</tt>, collects all logging related messages.  When you specify a particular logging level, the Engine collects messages for that level and all the levels below it.  </p><p>The following table lists the allowable log levels and the information they provide:</p><div class="table"><a name="id2867739"></a><p class="title"><b>Table 3.1. EVMS logging levels</b></p><table summary="EVMS logging levels" border="1"><colgroup><col><col></colgroup><thead><tr><th>Level name</th><th>Description</th></tr></thead><tbody><tr><td>Critical</td><td>The health of the system or the Engine is in jeopardy; for example, an operation has failed because there is not enough memory.</td></tr><tr><td>Serious</td><td>An operation did not succeed.</td></tr><tr><td>Error</td><td>The user has caused an error.  The error messages are provided to help the user correct the problem.</td></tr><tr><td>Warning</td><td>An error has occurred that the system might or might not be able to work around.</td></tr><tr><td>Default</td><td>An error has occurred that the system has already worked around.</td></tr><tr><td>Details</td><td>Detailed information about the system.</td></tr><tr><td>Debug</td><td>Information that helps the user debug a problem.</td></tr><tr><td>Extra</td><td>More information that helps the user debug a problem than the &quot;Debug&quot; level provides.</td></tr><tr><td>Entry_Exit</td><td>Traces the entries and exits of functions.</td></tr><tr><td>Everything</td><td>Verbose output.</td></tr></tbody></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="specifylevels"></a>3.3. Specifying the logging levels</h2></div></div><p>By default, when any of the EVMS interfaces is opened, the Engine logs the <tt>Default</tt> level of messages into the <tt>/var/log/evmsEngine.log</tt> file.  However, if your system is having problems and you want to see more of what is happening, you can change the logging level to be higher; if you want fewer logging messages, you can change the logging level to be lower.  To change the logging level, specify the <b>-d</b> parameter and the log level on the interface open call.  The following examples show how to open the various interfaces with the highest logging level (<tt>everything</tt>):</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">GUI:		evmsgui -d everything</pre></td></tr></table><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Ncurses:	evmsn -d everything</pre></td></tr></table><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">CLI:		evms -d everything</pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>If you use the EVMS mailing list for help with a problem, providing to us
the log file that is created when you open one of the interfaces (as shown 
in the previous commands) makes it easier for us to help you.
</p></div><p>The EVMS GUI lets you change the logging level during an Engine session.  To do so, follow these steps:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Settings</b>-&gt;<b>Log Level</b>-&gt;<b>Engine</b>.
	</p></li><li><p>Click the <b>Level</b> you want.
	</p></li></ol></div><p>The CLI command, <b>probe</b>, opens and closes the Engine, which causes a new log to start.  The log that existed before the <b>probe</b> command was issued is renamed <tt>/var/log/evmsEngine.1.log</tt> and the new log is named <tt>/var/log/evmsEngine.log</tt>.</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmsmigrate"></a>Chapter 4. Viewing compatibility volumes after migrating</h2></div></div><p>Migrating to EVMS allows you to have the flexibility of EVMS without losing the integrity of your existing data. EVMS discovers existing volume management volumes as compatibility volumes. After you have installed EVMS, you can view your existing volumes with the interface of your choice. </p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="guimigrate"></a>4.1. Using the EVMS GUI</h2></div></div><p>If you are using the EVMS GUI as your preferred interface, you can view your migrated volumes by typing <b>evmsgui</b> at the command prompt. The following window opens, listing your migrated volumes. </p><div class="figure"><a name="id2869361"></a><p class="title"><b>Figure 4.1. GUI start-up window</b></p><div class="mediaobject"><img src="gui_active.png" alt="GUI start-up window"></div></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="ncurmigrate"></a>4.2. Using Ncurses</h2></div></div><p>If you are using the Ncurses interface, you can view your migrated volumes by 
	typing <b>evmsn</b> at the command prompt. The following window opens, listing your migrated volumes. </p><div class="figure"><a name="id2869253"></a><p class="title"><b>Figure 4.2. Ncurses start-up window</b></p><div class="mediaobject"><img src="n.png" alt="Ncurses start-up window"></div></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="climigrate"></a>4.3. Using the CLI</h2></div></div><p>If you are using the Command Line Interpreter (CLI) interface, you can view 
	your migrated volumes by following these steps:</p><div class="orderedlist"><ol type="1"><li><p>Start the Command Line Interpreter by typing 
		<b>evms</b> at the command line.</p></li><li><p>Query the volumes by typing the following at the 
		<tt>EVMS</tt> prompt:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query:volumes</pre></td></tr></table><p>Your migrated volumes are displayed as results of the 
		query. </p></li></ol></div><div class="figure"><a name="id2869844"></a><p class="title"><b>Figure 4.3. CLI volume query results</b></p><div class="mediaobject"><img src="cli_active.png" alt="CLI volume query"></div></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="displaydetails"></a>Chapter 5. Obtaining interface display details</h2></div></div><p>The EVMS interfaces let you view more detailed information about an EVMS object than 
what is readily available from the main views of the EVMS user interfaces.  The type and extent
of additional information available is dependent on the interface you use.  For example, the
EVMS GUI provides more in-depth information than does the CLI.</p><p>The following sections show how to find detailed information on the region
<tt>lvm/Sample Container/Sample Region</tt>, which is part of
volume <tt>/dev/evms/Sample Volume</tt> (created in section 10.2).</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="displaygui"></a>5.1. Using the EVMS GUI</h2></div></div><p>With the EVMS GUI, it is only possible to display additional details on an object through
the Context Sensitive Menus, as shown in the following steps:

</p><div class="orderedlist"><ol type="1"><li><p>Looking at the <b>volumes view</b>, click the &quot;+&quot; next
to volume <tt>/dev/evms/Sample Volume</tt>.  Alternatively, look at the <b>regions</b> view.</p></li><li><p>Right click <tt>lvm/Sample Container/Sample Region</tt>.</p></li><li><p>Point at <b>Display Details...</b> and click.  A new window opens
with additional information about the selected region.</p></li><li><p>Click <b>More</b> by the <b>Logical Extents box</b>.  Another window opens that displays the mappings of logical extents to physical extents.</p></li></ol></div><p>


</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="displaydatancurses"></a>5.2. Using Ncurses</h2></div></div><p>Follow these steps to display additional details on an object with Ncurses:

</p><div class="orderedlist"><ol type="1"><li><p>Press
	<b>Tab</b> to reach the Storage Regions view.
	</p></li><li><p>Scroll down using the <b>down</b> arrow until
	 <tt>lvm/Sample Container/Sample Region</tt> is highlighted.
	</p></li><li><p>Press <b>Enter</b>.
	</p></li><li><p>In the context menu, scroll down using the <b>down</b> arrow 
	to highlight &quot;Display Details...&quot;
	</p></li><li><p>Press <b>Enter</b> to activate the menu item.
	</p></li><li><p>In the Detailed Information dialog, use the <b>down</b> arrow to
	highlight the &quot;Logical Extents&quot; item and then use <b>spacebar</b> to open
	another window that displays the mappings of logical extents to physical extents.
	</p></li></ol></div><p>
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2870136"></a>5.3. Using the CLI</h2></div></div><p>Use the
	<b>query</b> command (abbreviated <b>q</b>) with filters to display details about EVMS objects.  There are two filters that are especially helpful for navigating
within the command line: <b>list options</b> (abbreviated <b>lo</b>) and <b>extended info</b> (abbreviated <b>ei</b>). </p><p>The <b>list options</b> command tells you what can currently be done and what options you
can specify.  To use this command, first build a traditional query command starting with the command name <b>query</b>, followed by a colon (<b>:</b>), and then the type of object you
want to query (for example, volumes, objects, plug-ins).  Then, you can use filters to narrow
the search to only the area you are interested in.  For example, to determine the acceptable
actions at the current time on <tt>lvm/Sample Container/Sample Region</tt>, enter the following command:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: regions, region=&quot;lvm/Sample Container/Sample Region&quot;, list options</pre></td></tr></table><p>The <b>extended info</b> filter is the equivalent of Display Details in the EVMS GUI and Ncurses interfaces.  The command takes the following form: <b>query</b>, followed by a colon (<b>:</b>), the filter (<b>extended info</b>), a comma (<b>,</b>), and the object you want more information about.  The command returns a list containing the field names, titles, descriptions and values for each field defined for the object.  For example, to obtain details on <tt>lvm/Sample Container/Sample Region</tt>, enter the following command:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: extended info, &quot;lvm/Sample Container/Sample Region&quot;</pre></td></tr></table><p>Many of  the field names that are returned by the <b>extended info</b> filter can be expanded
further by specifying the field name or names at the end of the command, separated
by commas.  For example, if you wanted additional information about logical extents, the query would look like the following:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: extended info, &quot;lvm/Sample Container/Sample Region&quot;, Extents</pre></td></tr></table></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmsassignseg"></a>Chapter 6. Adding and removing a segment manager</h2></div></div><p> This chapter discusses  when to use a segment manager, what the different types of segment managers are, how to add a segment manager to a disk, and how to remove a
segment manager. </p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whenassign"></a>6.1. When to add a segment manager</h2></div></div><p>Adding a segment manager to a disk allows the disk to be subdivided into 
	smaller storage objects called disk segments. The 
	<b>add</b> command causes a 
	segment manager to create appropriate metadata and expose freespace 
	that the segment manager  
	finds on the disk. You need to add segment managers when you 
	have a new disk or 
	when you are switching from one partitioning scheme to another. </p><p>EVMS displays disk segments as the following types: </p><div class="itemizedlist"><ul type="disc"><li><p>Data: a set of contiguous sectors that has been allocated 
		from a disk and can be used to construct a volume or object.</p></li><li><p>Freespace: a set of contiguous sectors that are unallocated 
		or not in use. Freespace can be used to create a segment.</p></li><li><p>Metadata: a set of contiguous sectors that contain 
		information needed by the segment manager.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="smtypes"></a>6.2. Types of segment managers</h2></div></div><p>There are seven types of segment managers in EVMS: DOS, GPT, S/390, Cluster,  BSD, MAC, and BBR. </p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="defaultseg"></a>6.2.1. DOS Segment Manager</h3></div></div><p>The most
		commonly used segment manager is the DOS Segment Manager. This plug-in
		provides support for traditional DOS disk partitioning. The 
		DOS Segment Manager also recognizes and supports the following variations 
		of the DOS partitioning scheme:
		</p><div class="itemizedlist"><ul type="disc"><li><p>OS/2:  an OS/2 disk has additional metadata 
		sectors that contain information needed to reconstruct disk segments.</p></li><li><p>Embedded partitions: support for BSD, SolarisX86, and UnixWare  
			is sometimes found embedded in primary DOS partitions. 
			The DOS Segment Manager  recognizes and supports these 
			slices as disk segments.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="gptseg"></a>6.2.2. GUID Partitioning Table (GPT) Segment Manager</h3></div></div><p>The GUID Partitioning Table (GPT) Segment Manager handles the 
		new GPT partitioning scheme 
		on IA-64 machines. The Intel 
		<i>Extensible Firmware Interface Specification</i>
 		requires that firmware be able to discover partitions and produce logical devices that 
		correspond to disk partitions.  The partitioning scheme described in 
		the specification is called GPT due to the extensive use of 
		Globally Unique Identifier (GUID) tagging. GUID is a 128 bit long 
		identifier, also referred to as a Universally Unique Identifier (UUID).   
		As described in the Intel <i>Wired For Management Baseline Specification</i>,  
		a GUID is a combination of  time and space fields that produce an 
		identifier that is unique across an entire UUID space.  
		These identifiers are used extensively on GPT partitioned disks 
		for tagging entire disks and individual partitions. 
		GPT partitioned disks serve several functions, such as:</p><div class="itemizedlist"><ul type="disc"><li><p>keeping a primary and backup copy of metadata</p></li><li><p>replacing msdos partition nesting by allowing many partitions</p></li><li><p>using 64 bit logical block addressing</p></li><li><p>tagging partitions and disks with GUID descriptors</p></li></ul></div><p>The GPT Segment Manager scales better to large disks. It provides more redundancy with added reliability and uses unique names. However, the GPT Segment Manager is not compatible with DOS, OS/2, or Windows®. </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="s390sm"></a>6.2.3. S/390 Segment Manager</h3></div></div><p>The S/390 Segment Manager is used exclusively on System/390 
		mainframes.  The S/390 Segment Manager has the ability to recognize 
		various disk layouts found on an S/390 machine, and provide 
		disk segment support for this architecture. The two most common disk 
		layouts are Linux Disk Layout (LDL) and Common Disk Layout (CDL). </p><p>The principle difference between LDL and CDL is that an LDL disk 
		cannot be further subdivided. An LDL disk will produce a single metadata 
		disk segment and a single data disk segment. There is no freespace on an 
		LDL disk, and you cannot delete or re-size the data segment. A CDL disk can 
		be subdivided into multiple data disk segments 
		because it contains metadata that is missing from an LDL disk, specifically 
		the Volume Table of Contents (vtoc) information.</p><p>The S/390 Segment  Manager is the only segment manager plug-in 
		capable of understanding the unique S/390 disk layouts. The S/390 Segment Manager 
		cannot be added or removed from a disk. </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2870583"></a>6.2.4. Cluster segment manager</h3></div></div><p>The cluster segment manager (CSM) supports high availability clusters.  When the
CSM is added to a shared storage disk, it writes metadata on the disk that:</p><div class="itemizedlist"><ul type="disc"><li><p>provides a unique disk ID (guid)</p></li><li><p>names the EVMS container the disk will reside within</p></li><li><p>specifies the cluster node (nodeid) that owns the disk</p></li><li><p>specifies the HA cluster (clusterid)</p></li></ul></div><p>This metadata allows the CSM to build containers for supporting failover situations.
It does so by constructing an EVMS container object that consumes all shared objects
discovered by the CSM and belonging to the same container.  These shared storage
objects are consumed by the container.  A single segment object is produced by the
container for each consumed storage object.  A failover of the EVMS resource is then
accomplished by simply reassigning the container to the standby cluster node and
having that node re-run its discovery process.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2870641"></a>6.2.5. BSD segment manager</h3></div></div><p>BSD refers to the Berkeley Software Distribution UNIX® operating system.  The EVMS
BSD segment manager is responsible for recognizing and producing EVMS segment
storage objects that map BSD partitions.  A BSD disk may have a slice table in the
very first sector on the disk for compatibility purposes with other operating systems.
For example, a DOS slice table might be found in the usual MBR sector.  The BSD disk
would then be found within a disk slice that is located using the compatibility slice table.
However, BSD has no need for the slice table and can fully dedicate the disk to
itself by placing the disk label in the very first sector.  This is called a &quot;fully dedicated
disk&quot; because BSD uses the entire disk and does not provide a compatibility slice table.
The BSD segment manager recognizes such &quot;fully dedicated disks&quot; and provides mappings for
the BSD partitions.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2870652"></a>6.2.6. MAC segment manager</h3></div></div><p>Apple-partitioned disks use a disk label that is recognized by the MAC segment
manager.  The MAC segment manager recognizes the disk label during discovery and 
creates EVMS
segments to map the MacOS disk partitions.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2870685"></a>6.2.7. BBR segment manager</h3></div></div><p>The bad block replacement (BBR) segment manager enhances the reliability of
a disk by remapping bad storage blocks.  When BBR is added to a disk, it writes
metadata on the disk that:</p><div class="itemizedlist"><ul type="disc"><li><p>reserves replacement blocks</p></li><li><p>maps bad blocks to reserved blocks</p></li></ul></div><p>Bad blocks occur when an I/O error is detected for a write operation.
When this happens, I/O normally fails and the failure code is returned to the
calling program code.  BBR detects failed write operations and remaps the I/O to a
reserved block on the disk.  Afterward, BBR restarts the I/O using the reserve block.</p><p>Every block of storage has an address, called a logical block address, or LBA.
When BBR is added to a disk, it provides two critical functions: remap and recovery.
When an I/O operation is sent to disk, BBR inspects the LBA in the I/O command to see
if the LBA has been remapped to a reserve block due to some earlier I/O error.
If BBR finds a mapping between the LBA and a reserve block, it updates the I/O
command with the LBA of the reserve block before sending it on to the disk.
Recovery occurs when BBR detects an I/O error and remaps the bad block to a 
reserve block.  The new LBA mapping is saved in BBR metadata so that subsequent
I/O to the LBA can be remapped.</p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="assignsegex"></a>6.3. Adding a segment manager to an existing disk</h2></div></div><p>When you add a segment manager to a disk, the segment manager 
	needs to change the basic 
	layout of the disk. This change means that some sectors are 
	reserved for metadata and the remaining sectors are
  made available for creating data disk segments. Metadata sectors 
	are written to disk to save information
	needed by the segment manager;  previous information found on the 
	disk is lost. Before adding a 
	segment manager to an existing disk, you must remove any existing 
	volume management structures, including any previous segment manager.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="assignsegnew"></a>6.4. Adding a segment manager to a new disk</h2></div></div><p>When a new disk is added to a system,
	the disk usually contains no data and has not
	  been partitioned. If this is the case, the disk shows up in EVMS as a compatibility volume because 
	  EVMS cannot tell if the disk is being used as a volume. To add a segment manager to the disk so that it 
	can be subdivided into smaller disk segment objects, tell EVMS that the disk is not a
	compatibility volume by deleting the volume information.</p><p>If the new disk was moved from another system, chances are good that the disk already contains 
	metadata. If the disk does contain metadata, the disk shows up in EVMS with storage objects that 
	were produced from the existing metadata. Deleting these objects will allow you to add a different 
	segment manager to the disk, and you lose any old data. </p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="assignex"></a>6.5. Example: add a segment manager</h2></div></div><p>This section shows how to add 
a segment manager with EVMS.</p><p>EVMS initially displays the
	physical disks it sees as volumes. Assume that you have added a new 
	disk to the system that EVMS 
	sees as <tt>sde</tt>. 
	This disk contains no data and has not been subdivided 
	(no partitions). EVMS assumes that this 
	disk is a compatibility volume known as <tt>/dev/evms/sde</tt>. </p><blockquote class="blockquote"><div class="example"><a name="id2870845"></a><p class="title"><b>Example 6.1. Add the DOS Segment Manager</b></p><p>Add the DOS Segment Manager to disk <tt>sde</tt>.</p></div></blockquote><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>In the following example, the DOS Segment
		Manager creates two segments on the disk:
		a metadata segment known as <tt>sde_mbr</tt>, and a
		segment to represent the available space on
		the drive, <tt>sde_freespace1</tt>. This freespace
		segment (<tt>sde_freespace1</tt>) can be 
		divided into
		other segments because it represents space on
		the drive that is not in use.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="assignseggui"></a>6.5.1. Using the EVMS GUI</h3></div></div><p>To add the DOS Segment Manager to <tt>sde</tt>, first 
remove the volume, <tt>/dev/evms/sde</tt>:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Delete</b>-&gt;<b>Volume</b>.</p></li><li><p>Select <tt>/dev/evms/sde</tt>.</p></li><li><p>Click <b>Delete</b>.</p></li></ol></div><p>Alternatively, you can remove the volume through the GUI context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes tab</b>, right click <tt>/dev/evms/sde</tt>.</p></li><li><p>Click <b>Delete</b>.</p></li></ol></div><p>After the volume is removed, add the DOS Segment Manager:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Add</b>-&gt;<b>Segment Manager to Storage Object</b>.</p></li><li><p>Select <i>DOS Segment Manager</i>.</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select <i>sde</i></p></li><li><p>Click <b>Add</b></p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="assignsegncur"></a>6.5.2. Using Ncurses</h3></div></div><p>To add the DOS Segment Manager to <tt>sde</tt>, first remove the 
volume <tt>/dev/evms/sde</tt>:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Delete</b>-&gt;<b>Segment Manager to Storage Object</b>.</p></li><li><p>Select <tt>/dev/evms/sde</tt>.</p></li><li><p>Activate <b>Delete</b>.</p></li></ol></div><p>Alternatively, you can remove the volume through the context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Logical Volumes view, press <b>Enter</b> on 
<tt>/dev/evms/sde</tt>.</p></li><li><p>Activate <b>Delete</b>.</p></li></ol></div><p>After the volume is removed, add the DOS Segment Manager:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Add</b>-&gt;<b>Segment Manager to Storage Object</b></p></li><li><p>Select <i>DOS Segment Manager</i>.</p></li><li><p>Activate <b>Next</b>.</p></li><li><p>Select <i>sde</i>.
</p></li><li><p>Activate <b>Add</b>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="assignsegcli"></a>6.5.3. Using the CLI</h3></div></div><p>To add the DOS Segment Manager to sde, first tell EVMS that this disk is not a 
volume and is available for use:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Delete:/dev/evms/sde</pre></td></tr></table><p>Next, add the DOS Segment Manager to sde by typing the following:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Add:DosSegMgr={},sde</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="removeseg"></a>6.6. Removing a segment manager</h2></div></div><p>When a segment manager is removed from a disk, the disk can be reused by
other plug-ins.  The <b>remove</b> command causes the segment manager to remove its
partition or slice table from the disk, leaving the raw disk storage object that then
becomes an available EVMS storage object.  As an available storage object,
the disk is free to be used by any plug-in when storage objects are created or expanded.
You can also add any of the segment managers to the available disk storage object
to subdivide the disk into segments.</p><p>Most segment manager plug-ins check to determine if any of the segments are still in
use by other plug-ins or are still part of volumes.  If a segment manager determines
that there are no disks from which it can safely remove itself, it will not be listed
when you use the <b>remove</b> command.  In this case, you should delete the
volume or storage object that is consuming segments from the disk you want to reuse.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="rmvex"></a>6.7. Example: remove a segment manager</h2></div></div><p>This section shows how to remove 
a segment manager with EVMS.</p><blockquote class="blockquote"><div class="example"><a name="id2871472"></a><p class="title"><b>Example 6.2. Remove the DOS Segment Manager</b></p><p>Remove the DOS Segment Manager from disk <tt>sda</tt>.</p></div></blockquote><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>In the following example, the DOS Segment
		Manager has one primary partition on disk <tt>sda</tt>.
		The segment is a compatibility volume known as
		<tt>/dev/evms/sda1</tt>.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="removeseggui"></a>6.7.1. Using the EVMS GUI context sensitive menu</h3></div></div><p>Follow these steps to remove a segment manager with the GUI context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click <tt>/dev/evms/sda1</tt>..</p></li><li><p>Click <b>Delete</b>.</p></li><li><p>Select <b>Actions</b>-&gt;<b>Remove</b>-&gt;<b>Segment Manager from Storage Object</b>.</p></li><li><p>Select <b>DOS Segment Manager, sda</b>.</p></li><li><p>Click <b>Remove</b>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="removesegcur"></a>6.7.2. Using Ncurses</h3></div></div><p>Follow these steps to remove a segment manager with the Ncurses interface:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Delete</b>-&gt;<b>Volume</b>.</p></li><li><p>Select <tt>/dev/evms/sda1</tt>.</p></li><li><p>Click <b>Delete</b>.</p></li><li><p>Select <b>Actions</b>-&gt;<b>Remove</b>-&gt;<b>Segment Manager from Storage Object</b>.</p></li><li><p>Click <b>Remove</b>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="removesegcli"></a>6.7.3. Using the CLI</h3></div></div><p>Follow these steps to remove a segment manager with the CLI:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Delete:/dev/evms/sda1</pre></td></tr></table><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Remove: sda</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmscreateseg"></a>Chapter 7. Creating segments</h2></div></div><p>This chapter discusses when to use segments and how to create them using 
different EVMS interfaces.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whyseg"></a>7.1. When to create a segment</h2></div></div><p>A disk can be subdivided into smaller storage objects called disk segments. A segment manager plug-in provides this capability. Another reason for creating disk segments is to maintain compatibility on a dual boot system where the other operating system requires disk partitions. Before creating a disk segment, you must choose a segment manager plug-in to manage the disk and assign 
the segment manager to the disk. An explanation of when and how to assign segment managers can be found in <a href="#evmsassignseg" title="Chapter 6. Adding and removing a segment manager">Chapter 6. &quot;<i>Adding and removing a segment manager</i>&quot;</a>.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="crsegex"></a>7.2. Example: create a segment</h2></div></div><p> This section provides a detailed explanation of how to create a 
segment with EVMS by providing instructions to help you complete the following task:</p><blockquote class="blockquote"><div class="example"><a name="id2870460"></a><p class="title"><b>Example 7.1. Create a 100MB segment</b></p><p>Create a 100MB segment from the freespace segment sde_freespace1. This
	freespace segment lies on a drive controlled by the DOS Segment Manager. </p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guiseg"></a>7.2.1. Using the EVMS GUI</h3></div></div><p>To create a segment using the GUI, follow the steps below:
	</p><div class="orderedlist"><ol type="1"><li><p>Select
		<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Segment</b>
		to see a list of segment manager plug-ins.
		</p></li><li><p>Select
		<b>DOS Segment Manager</b>.
		Click <b>Next</b>.</p><p>The next dialog window lists
		the free space storage objects suitable for creating
		a new segment.</p></li><li><p>Select <tt>sde_freespace1</tt>. Click
		<b>Next</b>. </p><p>The last dialog window
		presents the free space object you
		selected as well as the available
		configuration options for that
		object.</p></li><li><p>Enter 100 MB. Required fields are denoted by the
		&quot;*&quot; in front of the field description. The DOS Segment
		Manager provides default values, but you might want to change
		some of these values.</p><p>After you have filled in
		information for all the required
		fields, the <b>Create</b>
		button becomes available.</p></li><li><p>Click 
		<b>Create</b>.
		A window opens to display the
		outcome.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a segment from the GUI context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Segments</b> tab, right click 
on <tt>sde_freespace1</tt>.</p></li><li><p>Click <b>Create Segment...</b></p></li><li><p>Continue beginning with step 4 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="ncurseg"></a>7.2.2. Using Ncurses</h3></div></div><p>To create a segment using Ncurses, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Segment</b> to see a list of segment manager plug-ins.</p></li><li><p>Select <b>DOS Segment Manager</b>. 
	Activate <b>Next</b>.</p><p>The next dialog window
	lists free space
	storage objects suitable for creating
	a new segment. </p></li><li><p>Select <tt>sde_freespace1</tt>.  Activate <b>Next</b>.</p></li><li><p>Highlight the <i>size field</i> and press <b>spacebar</b>.</p></li><li><p>At the &quot;::&quot; prompt enter <b><tt>100MB</tt></b>. 
	Press <b>Enter</b>. </p></li><li><p>After all required values have been completed, the <b>Create</b>
	button becomes available.</p></li><li><p>Activate <b>Create</b>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a segment from the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Segments view, press <b>Enter</b> on <tt>sde_freespace1</tt>.</p></li><li><p>Activate <b>Create Segment</b>.</p></li><li><p>Continue beginning with step 4 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="cliseg"></a>7.2.3. Using the CLI</h3></div></div><p>To create a data segment from a
	freespace segment, use the
	<b>Create</b> command. The arguments the
	<b>Create</b> command accepts vary
	depending on what is being created.  The first
	argument to the <b>Create</b>
	command indicates what is to be created, which
	in the above example is a segment. The
	remaining arguments are the freespace segment
	to allocate from and a list of options to pass
	to the segment manager. The command to
	accomplish this is:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Create: Segment,sde_freespace1, size=100MB</pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>The <b>Allocate</b> command also works to create a segment. </p></div><p>The previous example accepts the default values for all options you don't specify. To see the options for this command type:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query:plugins,plugin=DosSegMgr,list options</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmscreatecont"></a>Chapter 8. Creating a container </h2></div></div><p>This chapter discusses when and how to create a container. </p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whencont"></a>8.1. When to create a container</h2></div></div><p>Segments and disks can be combined to form a container. Containers allow 
	you to combine
	storage objects and then subdivide those combined storage objects 
	into new storage objects. You can 
	combine storage objects to implement the volume group concept
	as found in the AIX and Linux logical volume managers.</p><p>Containers are the beginning of more flexible 
volume management. You might want to create a container in order to account for flexibility in your future storage needs. For example, you might 
need to add additional disks when your applications or users need more storage. </p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="contex"></a>8.2. Example: create a container</h2></div></div><p>This section provides a detailed explanation of how to create a container with EVMS by providing instructions 
to help you complete the following task.</p><blockquote class="blockquote"><div class="example"><a name="id2871930"></a><p class="title"><b>Example 8.1. Create &quot;Sample Container&quot;</b></p><p>Given a system with three available disk drives 
(<tt>sdc</tt>, <tt>sdd</tt>, <tt>hdc</tt>),
 use the EVMS LVM Region Manager to combine these disk drives into a 
container called &quot;Sample Container&quot; with a PE size of 16 MB. </p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guicont"></a>8.2.1. Using the EVMS GUI</h3></div></div><p>To create a container using the EVMS GUI, follow these steps:	
	</p><div class="orderedlist"><ol type="1"><li><p>Select
		<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Container</b>
		to see a list plug-ins that support container creation.</p></li><li><p>Select the
		<b>LVM Region Manager</b>. Click
		<b>Next</b>.</p><p>The next dialog window contains a list of storage objects
		that the LVM Region Manager can use to create a container. </p></li><li><p>Select <i>sdc</i>, <i>sdd</i>, and 
		<i>hdc</i> from the list. Click
		<b>Next</b>.</p></li><li><p>Enter the name <b><tt>Sample Container</tt></b> 
		for the container and <b><tt>16MB</tt></b> in the 
		<i>PE size</i> field.</p></li><li><p>Click
		<b>Create</b>.
		A window opens to display the
		outcome.</p></li></ol></div><p>
	</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="ncurcont"></a>8.2.2. Using Ncurses</h3></div></div><p>To create a container using the Ncurses interface, follow these 
steps:
	</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Container</b>
		to see a list of plug-ins that support container creation.</p></li><li><p>Select the
 		<b>LVM Region Manager</b>. Activate
 		<b>Next</b>. </p><p>The next dialog window contains a list
		of storage objects that the LVM Region Manager can use to
		create the container.</p></li><li><p>Select <i>sdc</i>, <i>sdd</i>, and 
		<i>hdc</i> from the list.  Activate
		<b>Next</b>.</p></li><li><p>Press <b>spacebar</b> to select the field for
		the container name.	</p></li><li><p>Type <b><tt>Sample Container</tt></b> at the &quot;::&quot; prompt. Press
		<b>Enter</b>.</p></li><li><p>Scroll down until <i>PE Size</i> is highlighted. 
		Press <b>spacebar</b>.</p></li><li><p>Scroll down until <i>16MB</i> is highlighted. 
		Press  <b>spacebar</b>.</p></li><li><p>Activate <b>OK</b>.</p></li><li><p>Activate <b>Create</b>.</p></li></ol></div><p>
   </p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="clicont"></a>8.2.3. Using the CLI</h3></div></div><p>The <b>Create</b> command 
	creates containers.  The first argument
	in the <b>Create</b> command is the type of object to
	produce, in this case a container.  The
	<b>Create</b> command then accepts
	the following arguments: the region manager to
	use along with any parameters it might need, and
	the segments or disks to create the container
	from. The command to complete the previous example is:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Create:Container,LvmRegMgr={name=&quot;Sample Container&quot;,pe_size=16MB},sdc,sdd,hdc
</pre></td></tr></table><p>The previous example accepts the default values for all options 
you don't specify. To see the options for this command type:
 </p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query:plugins,plugin=LvmRegMgr,list options</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmscreatereg"></a>Chapter 9. Creating regions</h2></div></div><p>Regions can be created from containers, but they can also be created from other
regions, segments, or disks.  Most region managers that support containers create one or more
freespace regions to represent the freespace within the container. This function is
analogous to the way a segment manager creates a freespace segment to represent unused disk
space.  </p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2872475"></a>9.1. When to create regions</h2></div></div><p>You can create regions because you want the features provided by 
a certain region manager or because you want the features provided by 
that region manager. You can also create regions to be compatible with 
other volume management technologies, such as MD or LVM. 
For example, if you wanted to make a volume that is compatible with Linux LVM, 
you would create a region out of a Linux LVM container and then a compatibility volume from that region.  </p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="crregex"></a>9.2. Example: create a region</h2></div></div><p>This section tells how to create a region with EVMS by 
providing instructions to help you complete the following task.</p><blockquote class="blockquote"><div class="example"><a name="id2872512"></a><p class="title"><b>Example 9.1. Create &quot;Sample Region&quot;</b></p><p>Given the container &quot;Sample Container,&quot; which has a freespace region of 
8799 MB, create a data region 1000 MB in size named &quot;Sample Region.&quot;</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guireg"></a>9.2.1. Using the EVMS GUI</h3></div></div><p>To create a region, follow these steps:
	</p><div class="orderedlist"><ol type="1"><li><p>Select
		<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Region</b>
</p></li><li><p>Select
		the LVM Region
		Manager. Click <b>Next</b>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>You might
		see additional region managers that were
			not in the selection list when you were creating the storage container
			 because not all region
			managers are required to support containers.</p></div></li><li><p>Select the freespace region from
			the container you created in 
			<a href="#evmscreatecont" title="Chapter 8. Creating a container ">Chapter 8. &quot;<i>Creating a container </i>&quot;</a>.
			Verify that the region is named  
			<tt>lvm/Sample Container/Freespace</tt>.
				Click <b>Next</b>.</p><p>The fields in the next window are the options for the
				LVM Region Manager plug-in, the options marked with an &quot;*&quot; are required. </p></li><li><p>Fill in the name, <b><tt>Sample Region</tt></b>.</p></li><li><p>Enter <b><tt>1000MB</tt></b> in the <i>size</i> field.</p></li><li><p>Click the
				<b>Create</b> button to complete the
				operation. A window opens to display the outcome.</p></li></ol></div><p>
		      </p><p>Alternatively, you can perform some of the steps for creating a region with the GUI context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Regions</b> tab, right click 
	<tt>lvm/Sample Container/Freespace</tt>.</p></li><li><p>Click <b>Create Region</b>.</p></li><li><p>Continue beginning with step 4 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="ncurreg"></a>9.2.2. Using Ncurses</h3></div></div><p>To create a region, follow these steps:
			</p><div class="orderedlist"><ol type="1"><li><p>Select
				<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Region</b>.</p></li><li><p>Select the
				<b>LVM Region
				Manager</b>. Activate <b>Next</b>.</p></li><li><p>Select the freespace
				region from the container you created
				earlier in <a href="#evmscreatecont" title="Chapter 8. Creating a container ">Chapter 8. &quot;<i>Creating a container </i>&quot;</a>. Verify that
				the region is named 
				<tt>lvm/Sample Container/Freespace</tt>.</p></li><li><p>Scroll to the <i>Name</i> field, and press 
				<b>spacebar</b>.</p></li><li><p>Type <b><tt>Sample Region</tt></b> at the &quot;::&quot; prompt. 
				Press <b>Enter</b>.</p></li><li><p>Scroll to the <i>size</i> field, 
				and press <b>spacebar</b>.</p></li><li><p>Type <b><tt>1000MB</tt></b> at the &quot;::&quot; prompt. 
				Press <b>Enter</b>.</p></li><li><p>Activate <b>Create</b>.</p></li></ol></div><p>
			</p><p>Alternatively, you can perform some of the steps for creating a region with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Storage Regions view, press <b>Enter</b> on
<tt>lvm/Sample Container/Freespace</tt>.</p></li><li><p>Activate the <b>Create Region</b> menu item.</p></li><li><p>Continue beginning with step 4 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="clireg"></a>9.2.3. Using the CLI</h3></div></div><p>Create regions with the <b>Create</b>
			command. Arguments to the <b>Create </b>command are
			the following: keyword Region, the name of the
			region manager to use, the region managers
			options, and the objects to consume. The form of this command is:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Create:region, LvmRegMgr={name=&quot;Sample Region&quot;, size=1000MB},
&quot;lvm/Sample Container/Freespace&quot;</pre></td></tr></table><p>The LVM Region Manager supports many
			options for creating regions. To see the
			available options for creating regions and
			containers, use the following <b>Query</b>:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query:plugins,plugin=LvmRegMgr,list options</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmscreatedrivelinking"></a>Chapter 10. Creating drive links</h2></div></div><p>This chapter discusses the EVMS drive linking feature, which is
implemented by the drive link plug-in, and tells how to create, expand, shrink,
and delete a drive link.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whatisdrivelinking"></a>10.1. What is drive linking?</h2></div></div><p>Drive linking linearly concatenates objects, allowing you to
create larger storage objects and volumes from smaller individual pieces.
For example, say you need a 1 GB volume but do
not have contiguous space available of that length.  Drive linking lets you 
link two or more objects together to form the 1 GB volume.</p><p>
The types of objects that can be drive linked include disks, segments, 
regions, and other feature objects. 
</p><p>
Any resizing of an existing drive link, whether to grow it or shrink it,
must be coordinated with the appropriate file system operations.
EVMS handles these file system operations automatically.
</p><p> 
Because drive linking is an EVMS-specific feature that contains EVMS metadata, 
it is not backward compatible with other volume-management schemes.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="howimp"></a>10.2. How drive linking is implemented</h2></div></div><p>The drive link plug-in consumes storage objects, called link
objects, which produce a larger drive link object whose address space spans
the link objects.
The drive link plug-in knows how to assemble the link objects so as to 
create the exact same address space every time.
The information required to do this is kept on each link child as persistent
drive-link metadata.
During discovery, the drive link plug-in inspects each known storage
object for this metadata.
The presence of this metadata identifies the storage object as a link object.
The information contained in the metadata is sufficient to:</p><div class="itemizedlist"><ul type="disc"><li><p>Identify the link object itself.</p></li><li><p>Identify the drive link storage object that the link object belongs to.
</p></li><li><p>Identify all link objects belonging to the drive link storage.
object</p></li><li><p>Establish the order in which to combine the child link objects.</p></li></ul></div><p>If any link objects are missing at the conclusion of the discovery
process, the drive link storage object contains gaps where the missing
link objects occur.
In such cases, the drive link plug-in attempts to fill in the gap with a
substitute link object and construct the drive link storage object in
read-only mode, which allows for recovery action.
The missing object might reside on removable storage that has been removed or
perhaps a lower layer plug-in failed to produce the missing object.
Whatever the reason, a read-only drive link storage object, together
logging errors, help you take the appropriate actions to recover the drive link.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2872992"></a>10.3. Creating a drive link</h2></div></div><p>The drive link plug-in provides a list of acceptable objects from
which it can create a drive-link object.
When you create an EVMS storage object and then choose the drive
link plug-in, a list of acceptable objects is provided that you can choose
from.
The ordering of the drive link is implied by the order in which you pick 
objects from the provided list.
After you provide a name for the new drive-link object, the identified
link objects are consumed and the new drive-link object is produced. 
The name for the new object is the only option when creating a drive-link.
</p><p>Only the last object in a drive link
can be expanded, shrunk or removed.  Additionally, a new object can be added to the
end of an existing drive link only if the file system (if one exists) permits.
Any resizing of a drive link, whether to grow it or shrink it, must be coordinated with the
appropriate file system operations.  EVMS handles these file system operations
automatically.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="drivelinkex"></a>10.4. Example: create a drive link</h2></div></div><p> This section shows how to create a drive link with EVMS:</p><blockquote class="blockquote"><div class="example"><a name="id2873735"></a><p class="title"><b>Example 10.1. Create a drive link</b></p><p>Create a new drive link consisting of <tt>sde4</tt> and <tt>hdc2</tt>, and call it &quot;dl.&quot;</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guidrivelinking"></a>10.4.1. Using the EVMS GUI</h3></div></div><p>To create the drive link using the GUI, follow these steps:
	</p><div class="orderedlist"><ol type="1"><li><p>Select
		<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Feature Object</b>
		to see a list of EVMS features.
		</p></li><li><p>Select
		<b>Drive Linking Feature</b>.
		</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Click the objects you want to compose the drive link: 
		sde4 and hdc2.</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Type <tt>dl</tt> in the &quot;name&quot; field</p></li><li><p>Click
		<b>Create</b>. </p><p>The last dialog window
		presents the free space object you
		selected as well as the available
		configuration options for that
		object.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a drive link with the GUI
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Available Objects</b> tab, 
	right click <tt>sde4</tt>.</p></li><li><p>Click <b>Create Feature Object...</b></p></li><li><p>Continue creating the drive link beginning with step 2 of the GUI
	instructions.  In step 4, <tt>sde4</tt> is selected for you.  You can also
	select <tt>hdc2</tt>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="ncursdrivelink"></a>10.4.2. Using Ncurses</h3></div></div><p>To create the drive link, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Feature Object</b> to see a list of EVMS features.</p></li><li><p>Select <b>Drive Linking Feature</b>.</p></li><li><p>Activate <b>Next</b>.</p></li><li><p>Use <b>spacebar</b> 
			 to select the objects you want to compose the drive
				link from: <tt>sde4</tt> and <tt>hdc2</tt>.</p></li><li><p>Activate <b>Next</b>.</p></li><li><p>Press 
				<b>spacebar</b> to edit the Name field.</p></li><li><p>Type <b><tt>dl</tt></b> at the &quot;::&quot; prompt. 
				Press <b>Enter</b>.</p></li><li><p>Activate <b>Create</b>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a drive link with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Available Objects view, press <b>Enter</b> on <tt>sde4</tt>.</p></li><li><p>Activate the <b>Create Feature Object</b> menu item.</p></li><li><p>Continue creating the drive link beginning with step 4 of the Ncurses
instructions.  <tt>sde4</tt> will be pre-selected.  You can also select <tt>hdc2</tt>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="drlinkseg"></a>10.4.3. Using the CLI</h3></div></div><p>Use the
	<b>create</b> command to create a drive link through the CLI.  You pass the &quot;object&quot; keyword to the <b>create</b> command, followed by the plug-in and its options, and finally the objects.</p><p>To determine the options for the plug-in you are going to use, issue the following command:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: plugins, plugin=DriveLink, list options</pre></td></tr></table><p>Now construct the <b>create</b> command, as follows:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">create: object, DriveLink={Name=dl}, sde4, hdc2</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="expandpartitions"></a>10.5. Expanding a drive link</h2></div></div><p>
A drive link is an aggregating storage object that is built by combining a number of
storage objects into a larger resulting object.  A drive link consumes link objects in order
to produce a larger storage object.  The ordering of the link objects as well as the
number of sectors they each contribute is described by drive link metadata.  The metadata
allows the drive link plug-in to recreate the drive link, spanning the link objects in a
consistent manner.  Allowing any of these link objects to expand would corrupt the
size and ordering of link objects; the ordering of link objects is vital to the correct
operation of the drive link.  However, expanding a drive link can be controlled by only
allowing sectors to be added at the end of the drive link storage object.  This does not
disturb the ordering of link objects in any manner and, because sectors are only added
at the end of the drive link, existing sectors have the same address (logical sector
number) as before the expansion.  Therefore, a drive link can be expanded by adding
additional sectors in two different ways:</p><div class="itemizedlist"><ul type="disc"><li><p>
By adding an additional storage object to the end of the drive link.
</p></li><li><p>
By expanding the last storage object in the drive link.
</p></li></ul></div><p>
If the expansion point is the drive link storage object, you can perform the
expansion by adding an additional storage object to the drive link.  This is done
by choosing from a list of acceptable objects during the expand operation. Multiple objects 
can be selected and added to the drive link.
</p><p>
If the expansion point is the last storage object in the drive link, then you expand the
drive link by interacting with the plug-in that produced the object.  For example, if
the link was a segment, then the segment manager plug-in that produced the storage
object expands the link object.  Afterwords, the drive link plug-in notices the size
difference and updates the drive link metadata to reflect the resize of the child object.</p><p>
There are no expand options.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="shrinkdrivelink"></a>10.6. Shrinking a drive link</h2></div></div><p>
Shrinking a drive link has the same restrictions as expanding a drive link.  A drive link
object can only be shrunk by removing sectors from the end of the drive link.  This can
be done in the following ways:
</p><div class="itemizedlist"><ul type="disc"><li><p>By removing link objects from the end of the drive link.</p></li><li><p>By shrinking the last storage object in the drive link.</p></li></ul></div><p>
</p><p>
The drive link plug-in attempts to orchestrate the shrinking of a 
drive-link storage object by only listing the last link object.
If you select this object, the drive link plug-in then lists the next-to-last 
link object, and so forth, moving backward through the link
objects to satisfy the shrink command.
</p><p>If the shrink point is the last storage object in the drive link, then you shrink the
drive link by interacting with the plug-in that produced the object.</p><p>
There are no shrink options.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="deletedrivelink"></a>10.7. Deleting a drive link</h2></div></div><p>
A drive link can be deleted as long as it is not currently a
compatibility volume, an EVMS volume, or consumed by another EVMS plug-in.
</p><p>
No options are available for deleting a drive link storage object.
</p></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmscreatesnap"></a>Chapter 11. Creating snapshots</h2></div></div><p>This chapter discusses snapshotting and tells how to create 
a snapshot.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whatissnapshotting"></a>11.1. What is a snapshot?</h2></div></div><p>A snapshot represents a frozen image of a volume.  
The source of a snapshot is
called an &quot;original.&quot;  
When a snapshot is created, it looks exactly like the original
at that point in time.  
As changes are made to the original, the snapshot remains the
same and looks exactly like the original at the time the snapshot was 
created.
</p><p>
Snapshotting allows you to keep a volume online while a backup is created.
This method is much more convenient than a data backup where a volume
must be taken offline to perform a consistent backup.
When snapshotting, a snapshot of the volume is created and the backup
is taken from the snapshot, while the original remains in active use.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="createactivsnap"></a>11.2. Creating and activating snapshot objects</h2></div></div><p>Creating and activating a snapshot is a two-step process.  
The first step is to create the snapshot object.  
The snapshot object specifies where the saved data will
be stored when changes are made to the original.  
The second step is to activate the
object, which is to make an EVMS volume from the object.</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2873686"></a>11.2.1. Creating a snapshot</h3></div></div><p>You can create a snapshot object from any unused storage object in EVMS
(disks, segments, regions, or feature objects).  
The size of this consumed object is
the size available to the snapshot object.  The snapshot object can be smaller
or larger than the original volume.  
If the object is smaller, the snapshot volume could fill up as data is copied
from the original to the snapshot, given sufficient activity on the original. 
In this situation, the snapshot is deactivated and additional 
I/O to the snapshot fails.
</p><p>Base the size of the snapshot object on the amount of activity that 
is likely to take place on the original during the lifetime of the snapshot.  
The more changes that occur on the
original and the longer the snapshot is expected to remain active, 
the larger the snapshot object should be.  
Clearly, determining this calculation is not simple and requires trial and 
error to determine the correct snapshot object size to use for a 
particular situation.  
The goal is to create a snapshot object large enough to prevent the 
shapshot from being
deactivated if it fills up, yet small enough to not waste disk space.  
If the snapshot
object is the same size as the original volume, or a little larger, 
to account for the snapshot mapping tables, the snapshot is 
never deactivated.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2873571"></a>11.2.2. Activating a snapshot</h3></div></div><p>After you create a snapshot, activate it by making an EVMS volume from the object.
After you create the volume and save the changes, the snapshot is active.  
The only option you have to specify for activating snapshots is 
the name to give the EVMS volume.  
This name can be
the same as or different than the name of the snapshot object.</p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="snapshotex"></a>11.3. Example: create a snapshot</h2></div></div><p> This section shows how to create a snapshot with EVMS:</p><blockquote class="blockquote"><div class="example"><a name="id2873608"></a><p class="title"><b>Example 11.1. Create a snapshot of a volume</b></p><p>Create a new snapshot of <tt>/dev/evms/vol</tt> on 
<tt>lvm/Sample Container/Sample Region</tt>, and call 
it &quot;snap.&quot;</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guisnapshot"></a>11.3.1. Using the EVMS GUI</h3></div></div><p>To create the snapshot using the GUI, follow these steps:
	</p><div class="orderedlist"><ol type="1"><li><p>Select
		<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Feature Object</b>
		to see a list of EVMS feature objects.
		</p></li><li><p>Select
		<b>Snapshot Feature</b>.
		</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select <b>lvm/Sample Container/Sample Region</b>. 			</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select <b>/dev/evms/vol</b> from the list in the
		&quot;Volume to be Snapshotted&quot; field.</p></li><li><p>Type <tt>snap</tt> in the &quot;Snapshot Object Name&quot; field.
		</p></li><li><p>Click <b>Create</b>.
		</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a snapshot with the GUI
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Available Objects</b> tab, right click
	<b>lvm/Sample Container/Sample Region</b>.</p></li><li><p>Click <b>Create Feature Object...</b></p></li><li><p>Continue creating the snapshot beginning with step 2 of the
	GUI instructions.  You can skip steps 4 and 5 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="ncursnapshot"></a>11.3.2. Using Ncurses</h3></div></div><p>To create the snapshot, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Feature Object</b>
			to see a list of EVMS feature objects.</p></li><li><p>Select <b>Snapshot Feature</b>.</p></li><li><p>Activate <b>Next</b>.</p></li><li><p>Select <tt>lvm/Sample Container/Sample Region.</tt></p></li><li><p>Activate <b>Next</b>.</p></li><li><p>Press 
				<b>spacebar</b> to edit the &quot;Volume to be Snapshotted&quot; field.</p></li><li><p>Highlight <tt>/dev/evms/vol</tt> and press <b>spacebar</b> to select.</p></li><li><p>Activate <b>OK</b>.</p></li><li><p>Highlight &quot;Snapshot Object Name&quot; and press <b>spacebar</b> to edit.</p></li><li><p>Type <b><tt>snap</tt></b> at the &quot;::&quot; prompt. 
				Press <b>Enter</b>.</p></li><li><p>Activate <b>Create</b>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a snapshot with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Available Objects view, press <b>Enter</b> on <tt>lvm/Sample Container/Sample Region</tt>.</p></li><li><p>Activate the <b>Create Feature Object</b> menu item.</p></li><li><p>Continue creating the snapshot beginning with step 6 of the Ncurses
instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="clisnapshot"></a>11.3.3. Using the CLI</h3></div></div><p>Use the
	<b>create</b> command to create a snapshot through the CLI.  You pass the &quot;Object&quot; keyword to the <b>create</b> command, followed by the plug-in and its options, and finally the objects. </p><p>To determine the options for the plug-in you are going to use, issue the following command:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: plugins, plugin=Snapshot, list options</pre></td></tr></table><p>Now construct the <b>create</b> command, as follows:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">create: object, Snapshot={original=/dev/evms/vol, snapshot=snap}, 
&quot;lvm/Sample Container/Sample Region&quot;</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2875148"></a>11.4. Reinitializing a snapshot</h2></div></div><p>Snapshots can be reinitialized. Reinitializing causes all of the 
saved data to be erased and
starts the snapshot from the current point in time.  
A reinitialized snapshot has the same
original, chunk size, and writeable flags as the original 
snapshot.</p><p>To reinitialize a snapshot, use the <b>Reset</b> 
command on the snapshot object
(not the snapshot volume).  
This command reinitializes the snapshot without requiring you to
manually delete and recreate the volume.
The snapshot volume must be unmounted for it to be reinitialized.
</p><p>This section continues the example from the previous section, 
where a snapshot object and volume were created.  
The snapshot object is called &quot;snap&quot; and the volume
is called &quot;/dev/evms/snap.&quot;</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2875186"></a>11.4.1. Using the EVMS GUI or Ncurses</h3></div></div><p>To reinitialize a snapshot, follow these steps:
</p><div class="orderedlist"><ol type="1"><li><p>Select
		<b>Actions</b>-&gt;<b>Other</b>-&gt;<b>Storage Object Tasks</b>
		</p></li><li><p>Select the volume &quot;snap.&quot;</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select <b>Reset</b>.</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Click <b>Reset</b> on the action panel.
		</p></li><li><p>Click <b>Reset</b> on the warning panel.</p></li></ol></div><p>

</p><p>Alternatively, you can perform these same steps with the context sensitive menus:</p><div class="orderedlist"><ol type="1"><li><p>From the Feature Objects panel, right click (or press <b>Enter</b> on) 
the object <b>snap</b>.
</p></li><li><p>Click <b>Reset</b> on the popup menu.</p></li><li><p>Click <b>Reset</b> on the action panel.</p></li><li><p>Click <b>Reset</b> on the warning panel.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2875384"></a>11.4.2. Using the CLI</h3></div></div><p>Follow these steps to reinitialize a snapshot with the CLI:</p><div class="orderedlist"><ol type="1"><li><p>Issue the following command to the CLI:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">task:reset,snap</pre></td></tr></table></li><li><p>Press <b>Enter</b> to select &quot;Reset&quot; (the default choice) at the warning message.</p></li></ol></div></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2875436"></a>11.5. Expanding a snapshot</h2></div></div><p>
As mentioned in the <a href="#createactivsnap" title="11.2. Creating and activating snapshot objects">Section 11.2, &quot;Creating and activating snapshot objects&quot;</a>, as data is 
copied from the original volume to the snapshot, the space available
for the snapshot might fill up, causing the snapshot to be invalidated.
This situation might cause your data backup to end prematurely, as the
snapshot volume begins returning I/O errors after it is invalidated.
</p><p>
To solve this problem, EVMS now has the ability to expand the storage
space for a snapshot object while the snapshot volume is active and mounted.
This feature allows you to initially create a small snapshot object and expand
the object as necessary as the space begins to fill up.
</p><p>
In order to expand the snapshot object, the underlying object must
be expandable.
Continuing the example from the previous sections, the object &quot;snap&quot; is
built on the LVM region <tt>lvm/Sample Container/Sample Region</tt>.
When we refer to expanding the &quot;snap&quot; object, the region
<tt>lvm/Sample Container/Sample Region</tt> is the 
object that actually gets
expanded, and the object &quot;snap&quot; simply makes use of the new space on
that region.
Thus, to have expandable snapshots, you will usually want to build
your snapshot objects on top of LVM regions that have extra freespace
available in their LVM container.  DriveLink objects and some disk
segments also work in certain situations.
</p><p>
One notable quirk about expanding snapshots is that the snapshot
object and volume do not actually appear to expand after the operation
is complete.
Because the snapshot volume is supposed to be a frozen image of the original
volume, the snapshot volume always has the same size as the original,
even if the snapshot has been expanded.
However, you can verify that the snapshot object is using the
additional space by displaying the details for the snapshot object
and comparing the percent-full field before and after the expand operation.
</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2875514"></a>11.5.1. Using the EVMS GUI or Ncurses</h3></div></div><p>To create the snapshot using the GUI or Ncurses, follow these steps:
	</p><div class="orderedlist"><ol type="1"><li><p>Select
		<b>Actions</b>-&gt;<b>Expand</b>-&gt;<b>Volume</b>
		to see a list of EVMS feature objects.
		</p></li><li><p>Select the volume <b>/dev/evms/snap</b>.</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select <b>lvm/Sample Container/Sample Region</b>.
		This object is the object that will actually be expanded.	</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select the options for expanding the LVM region,
		including the amount of extra space to add to the region.
		</p></li><li><p>Click <b>Expand</b>.
		</p></li></ol></div><p>Alternatively, you can perform the same steps using the context sensitive menus.</p><div class="orderedlist"><ol type="1"><li><p>From the <i>Volumes</i> panel, right click (or press <b>Enter</b> on) 
<b>/dev/evms/snap</b>.
</p></li><li><p>Select <b>Expand</b> from the popup menu.</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select the region <b>lvm/Sample Container/Sample Region</b>. This is the object that will
actually be expanded.</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select the options for expanding the LVM region, including the
amount of extra space to add to the region.</p></li><li><p>Click <b>Expand</b>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2875754"></a>11.5.2. Using the CLI</h3></div></div><p>The CLI expands volumes by targeting the object to be
expanded.
The CLI automatically handles expanding the volume and other objects above the volume
in the volume stock.  As with a regular expand operation, the options are determined
by the plug-in that owns the object being expanded.</p><p>Issue the following command to determine the expand options for the
region <tt>lvm/Sample Container/Sample Region</tt>:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query:region,region=&quot;lvm/Sample Container/Sample Region&quot;,lo</pre></td></tr></table><p>The option to use for expanding this region is called &quot;add_size.&quot;
Issue the following command to expand the snapshot by 100 MB:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">expand:&quot;lvm/Sample Container/Sample Region&quot;, add_size=100MB</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2875808"></a>11.6. Deleting a snapshot</h2></div></div><p>When a snapshot is no longer needed, you can remove it by deleting the EVMS
volume from the snapshot object, and then deleting the snapshot object.  Because the
snapshot saved the initial state of the original volume (and not the changed state),
the original is always up-to-date and does not need any modifications when a snapshot
is deleted.</p><p>No options are available for deleting snapshots.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2874456"></a>11.7. Rolling back a snapshot</h2></div></div><p>Situations can arise where a user wants to restore the original volume to
the saved state of the snapshot.  This action is called a rollback.  One such scenario
is if the data on the original is lost or corrupted.  Snapshot rollback acts as a quick
backup and restore mechanism, and allows the user to avoid a more lengthy restore
operation from tapes or other archives.</p><p>Another situation where rollback can be particularly useful is when you are
testing new software.  Before you install a new software package, create a writeable
snapshot of the target volume.  You can then install the software to the snapshot
volume, instead of to the original, and then test and verify the new software on the
snapshot.  If the testing is successful, you can then roll back the snapshot to the
original and effectively install the software on the regular system.  If there is a problem
during the testing, you can simply delete the snapshot without harming the original
volume.</p><p>You can perform a rollback when the following conditions are met:
</p><div class="itemizedlist"><ul type="disc"><li><p>
Both the snapshot and the original volumes
are unmounted and otherwise not in use.  
</p></li><li><p>
There is only a single snapshot of an original.</p><p>
If an original has multiple snapshots,
all but the desired snapshot must be deleted before rollback can take place.
</p></li></ul></div><p>No options are available for rolling back snapshots.</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2874529"></a>11.7.1. Using the EVMS GUI or Ncurses</h3></div></div><p>Follow these steps to roll back a snapshot with the EVMS GUI or Ncurses:</p><div class="orderedlist"><ol type="1"><li><p>Select 
<b>Actions</b>-&gt;<b>Other</b>-&gt;<b>Storage Object Tasks</b> </p></li><li><p>Select the object &quot;snap.&quot;</p></li><li><p>Click <b>Next</b>.</p></li><li><p>Select <b>Rollback</b></p>.</li><li><p>Click <b>Next</b>.</p></li><li><p>Click <b>Rollback</b> on the action panel.
</p></li><li><p>Click <b>Rollback</b> on the warning panel.
</p></li></ol></div><p>Alternatively, you can perform these same steps with the context sensitive menus:</p><div class="orderedlist"><ol type="1"><li><p>From the Feature Objects panel, right click (or press 
<b>Enter</b> on) the object &quot;snap.&quot;</p></li><li><p>Click <b>Rollback</b> on the popup menu.</p></li><li><p>Click <b>Rollback</b> on the action panel.</p></li><li><p>Click <b>Rollback</b> on the warning panel.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2876251"></a>11.7.2. Using the CLI</h3></div></div><p>Follow these steps to roll back a snapshot with the CLI:</p><div class="orderedlist"><ol type="1"><li><p>Issue the following command to the CLI:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">task:rollback,snap</pre></td></tr></table></li><li><p>Press <b>Enter</b> to select &quot;Rollback&quot; (the default choice) at the warning message.</p></li></ol></div></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmscreatevol"></a>Chapter 12. Creating volumes</h2></div></div><p>This chapter discusses when and how to create volumes.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2876072"></a>12.1. When to create a volume</h2></div></div><p>EVMS treats volumes and storage objects separately. 
A storage object does not automatically 
become a volume; it must be made into a volume.</p><p>Volumes are created from storage objects.
	Volumes are either EVMS native volumes or compatibility volumes.  Compatibility volumes
	are intended to be compatible with a volume manager other than EVMS, such as the Linux
	LVM, MD, OS/2 or AIX. Compatibility volumes might have restrictions on what EVMS can do with
	them.  EVMS native volumes have no such restrictions, but they can be used only by an
	EVMS equipped system. Volumes are mountable and can contain file systems.</p><p>EVMS native volumes contain EVMS-specific information
	to identify the name and minor number. After this volume information is
	applied, the volume is no longer fully backward compatible
	with existing volume types.</p><p>Instead of
	adding EVMS metadata to an existing object, you can tell EVMS to make an object directly available as a volume. This type of
	volume is known as a compatibility volume. Using this method, the final product is fully
	backward-compatible with the desired system. </p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="crvolexcomp"></a>12.2. Example: create an EVMS native volume</h2></div></div><p>This section provides a detailed explanation of how to create an EVMS native
	volume with EVMS by providing instructions to help you complete the following task.</p><blockquote class="blockquote"><div class="example"><a name="id2875829"></a><p class="title"><b>Example 12.1. Create an EVMS native volume </b></p><p>Create an EVMS native volume called &quot;Sample Volume&quot; from the region, <tt>/lvm/Sample Container/Region</tt>, you created in <a href="#evmscreatereg" title="Chapter 9. Creating regions">Chapter 9. &quot;<i>Creating regions</i>&quot;</a>.</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="evmsguivol"></a>12.2.1. Using the EVMS GUI</h3></div></div><p>Follow these instructions to create an EVMS volume:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>EVMS Volume</b>.</p></li><li><p>Choose <tt>lvm/Sample Container/Sample Region</tt>.
			</p></li><li><p>Type <b><tt>Sample Volume</tt></b> in the 
			<i>name field</i>.</p></li><li><p>Click <b>Create</b>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create an EVMS
volume from the GUI context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Available Options</b> tab, right click
	<tt>lvm/Sample Container/Sample Region</tt>.</p></li><li><p>Click <b>Create EVMS Volume...</b></p></li><li><p>Continue beginning with step 3 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="ncurevmsvol"></a>12.2.2. Using Ncurses</h3></div></div><p>To create a volume, follow these steps:
	</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>EVMS Volume</b>.</p></li><li><p>Enter <b><tt>Sample Volume</tt></b> at the &quot;name&quot; prompt. 
		Press <b>Enter</b>.</p></li><li><p>Activate <b>Create</b>.</p></li></ol></div><p>
   	</p><p>Alternatively, you can perform some of the steps to create an EVMS volume
from the context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Available Objects view, press <b>Enter</b> on 
<tt>lvm/Sample Container/Sample Region</tt>.</p></li><li><p>Activate the <b>Create EVMS Volume</b> menu item.</p></li><li><p>Continue beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2876550"></a>12.2.3. Using the CLI</h3></div></div><p>To create a volume, use the <b>Create</b> command. The arguments 
		the <b>Create</b> command accepts vary depending on what is being created. In 
		the case of the example, the first argument is the key word <tt>volume</tt> that
		specifies what is being created. The second argument is the object being made into a volume, 
		in this case <tt>lvm/Sample Container/Sample Region</tt>. 
		The third argument is type specific for an EVMS 
		volume, <tt>Name=</tt>, followed by what 
		you want to call the volume, in this case <tt>Sample Volume</tt>. The following command 
		creates the volume from the example. </p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Create: Volume, &quot;lvm/Sample Container/Sample Region&quot;, Name=&quot;Sample Volume&quot;</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="crvolexevms"></a>12.3. Example: create a compatibility volume</h2></div></div><p>This section provides a detailed explanation of how to create a compatibility 
	volume with EVMS by providing instructions to help you complete the following task.</p><blockquote class="blockquote"><div class="example"><a name="id2876629"></a><p class="title"><b>Example 12.2. Create a compatibility volume</b></p><p>Create a compatibility volume called &quot;Sample Volume&quot; from 
	the region, <tt>/lvm/Sample Container/Region</tt>, you created in <a href="#evmscreatereg" title="Chapter 9. Creating regions">Chapter 9. &quot;<i>Creating regions</i>&quot;</a>.</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guicompvol"></a>12.3.1. Using the GUI</h3></div></div><p>To create a compatibility volume, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select 
			<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Compatibility Volume</b>.
			</p></li><li><p>Choose the region <tt>lvm/Sample Container/Sample Region</tt> 
			from the list.</p></li><li><p>Click the <b>Create</b> button.</p></li><li><p>Click the <i>Volume</i> tab in the GUI to
			see a volume named <tt>/dev/evms/lvm/Sample Container/Sample Region</tt>. 
			This volume is your compatibility volume.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a compatibility volume from
the GUI context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Available Objects</b> tab, right click
	<tt>lvm/Sample Container/Sample Region</tt>.</p></li><li><p>Click <b>Create Compatibility Volume...</b></p></li><li><p>Continue beginning with step 3 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="ncurcompatvol"></a>12.3.2. Using Ncurses</h3></div></div><p>To create a compatibility volume, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Compatibility Volume</b>.</p></li><li><p>Choose the region <tt>lvm/Sample Container/Storage Region</tt> from the list.. 
			</p></li><li><p>Activate <b>Create</b>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to create a compatibility volume from
the context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Available Objects view, press <b>Enter</b> on 
<tt>lvm/Sample Container/Sample Region</tt>.</p></li><li><p>Activate the <b>Create Compatibility Volume</b> menu item.</p></li><li><p>Continue beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2876950"></a>12.3.3. Using the CLI</h3></div></div><p>To create a volume, use the <b>Create</b> command. The arguments 
		the <b>Create</b> command accepts vary depending on what is being created. In 
		the case of the example, the first argument is the key word <tt>volume</tt> that
		specifies what is being created. The second argument is the object being made into a volume, 
		in this case <tt>lvm/Sample Container/Sample Region</tt>. 
		The third argument, <tt>compatibility</tt>, indicates that this is a compatibility 
		volume and should be named as such. </p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">Create:Volume,&quot;lvm/Sample Container/Sample Region&quot;,compatibility</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmsfsimops"></a>Chapter 13. FSIMs and file system operations</h2></div></div><p>This chapter discusses the five File System Interface Modules (FSIMs) shipped with EVMS, and then provides examples of adding file systems and coordinating file system checks with the FSIMs.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="FSIMsuppevms"></a>13.1. The FSIMs supported by EVMS</h2></div></div><p>EVMS currently ships with five FSIMs.  These file system modules allow EVMS to interact with file system utilities such as <b>mkfs</b> and <b>fsck</b>.  Additionally, the FSIMs ensure that EVMS safely performs operations, such as expanding and shrinking file systems, by coordinating these actions with the file system. </p><p>You can invoke operations such as <b>mkfs</b> and <b>fsck</b> through the various EVMS user interfaces.  Any actions you initiate through an FSIM are not committed to disk until the changes are saved in the user interface.  Later in this chapter we provide examples of creating a new file system and coordinating file system checks through the EVMS GUI, Ncurses, and command-line interfaces.</p><p>The FSIMs supported by EVMS are:</p><div class="itemizedlist"><ul type="disc"><li><p>JFS</p></li><li><p>XFS</p></li><li><p>ReiserFS</p></li><li><p>Ext2/3</p></li><li><p>SWAPFS</p></li></ul></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimjfs"></a>13.1.1. JFS</h3></div></div><p>
The JFS module supports the IBM journaling file system (JFS). 
Current support includes <b>mkfs</b>, <b>unmkfs</b>, 
<b>fsck</b>, and online file system expansion.   
You must
have at least version 1.0.9 of the JFS utilities for your system
to work with this EVMS FSIM.  You can download the latest utilities
from the <a href="http://oss.software.ibm.com/jfs" target="_top">JFS for Linux</a> 
site.  
</p><p>
For more information on the JFS FSIM, refer to <a href="#jfsfsim" title="Appendix E. JFS file system interface module">Appendix E: &quot;JFS file system interface module&quot;</a>.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimxfs"></a>13.1.2. XFS</h3></div></div><p>
The XFS FSIM supports the XFS file system from SGI.
Command support includes <b>mkfs</b>, <b>unmkfs</b>, 
<b>fsck</b>, and online expansion.  Use version 1.2 or higher, which you can download from <a href="ftp://oss.sgi.com/projects/xfs/download" target="_top">the SGI open source FTP directory.</a>
</p><p>
For more information on the XFS FSIM, refer to <a href="#xfsfsim" title="Appendix F. XFS file system interface module">Appendix F: &quot;XFS file system interface module&quot;</a>.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimreiserfs"></a>13.1.3. ReiserFS</h3></div></div><p>
The ReiserFS module supports the ReiserFS journaling file system.
This module supports <b>mkfs</b>, <b>unmkfs</b>, <b>fsck</b>, online and offline 
expansion and offline shrinkage.  You need version 3.x.1a or higher
of the ReiserFS utilities for use with the EVMS FSIM modules.  You can download
the ReiserFS utilities from <a href="http://www.namesys.com" target="_top">The Naming 
System Venture (Namesys) </a> web site.
</p><p>
For more information on the ReiserFS FSIM, refer to <a href="#reiserfsim" title="Appendix G. ReiserFS file system interface module">Appendix G: &quot;ReiserFS file system interface module&quot;</a>.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimext23"></a>13.1.4. Ext2/3</h3></div></div><p>
The EXT2/EXT3 FSIM supports both the ext2 and ext3 file system formats.
The FSIM supports <b>mkfs</b>, <b>unmkfs</b>, 
<b>fsck</b>, and offline shrinkage and expansion.
</p><p>
For more information on the Ext2/3 FSIM, refer to <a href="#ext23fsim" title="Appendix H. Ext-2/3 file system interface module">Appendix H: &quot;Ext-2/3 file system interface module&quot;</a>.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimswapfs"></a>13.1.5. SWAPFS</h3></div></div><p>
The SWAPFS FSIM supports Linux swap devices.  The FSIM lets you create
and delete swap devices, and supports <b>mkfs</b>, 
<b>unmkfs</b>, shrinkage and expansion.  
Currently, you are responsible for issuing the
<b>swapon</b> and <b>swapoff</b> commands either in 
the startup scripts or manually.
You can resize swap device with the SWAPFS FSIM as long as the device is
not in use.
</p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="fsimmkfs"></a>13.2. Example: add a file system to a volume</h2></div></div><p>After you have made an EVMS or compatibility volume, add a file system to the volume before mounting it.  You can add a file system to a volume through the EVMS interface of your choice.</p><blockquote class="blockquote"><div class="example"><a name="id2877417"></a><p class="title"><b>Example 13.1. Add a JFS File System to a Volume</b></p><p>This example creates a new JFS file system, named <tt>jfs_vol</tt>, on volume <tt>/dev/evms/my_vol</tt>.
</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimmkfsgui"></a>13.2.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to create a JFS file system with the EVMS GUI:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>File Systems</b>-&gt;<b>Make</b>.
	</p></li><li><p>Select <b>JFS File System Interface Module</b>.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Select <b>/dev/evms/my_vol</b>.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Type  <b><tt>jfs_vol</tt></b> in the &quot;Volume Label&quot; 
	field. Customize any other options you are interested in.
	</p></li><li><p>Click <b>Make</b>.
	</p></li><li><p>The operation is completed when you save.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to create a file system with the GUI
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click 
	<tt>/dev/evms/my_vol</tt>.</p></li><li><p>Click <b>Make Filesystem...</b></p></li><li><p>Continue creating the file system beginning with step 2 of the
	GUI instructions.  You can skip steps 4 and 5 of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimmkfsncurses"></a>13.2.2. Using Ncurses</h3></div></div><p>Follow these steps to create a JFS file system with Ncurses:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>File Systems</b>-&gt;<b>Make</b>.
	</p></li><li><p>Select JFS File System Interface Module.</p></li><li><p>Activate <b>Next</b>.</p></li><li><p>Select <tt>/dev/evms/my_vol</tt>.</p></li><li><p>Activate <b>Next</b>.</p></li><li><p>Scroll down using the <b>down</b> arrow until
	 <b>Volume Label</b> is highlighted.
	</p></li><li><p>Press <b>Spacebar</b>.
	</p></li><li><p>At the &quot;::&quot; prompt enter <b><tt>jfs_vol</tt></b>.
	</p></li><li><p>Press <b>Enter</b>.
	</p></li><li><p>Activate <b>Make</b>.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to create a file system with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Volumes view, press <b>Enter</b> on 
<tt>/dev/evms/my_vol</tt>.</p></li><li><p>Activate the <b>Make Filesystem</b> menu item.</p></li><li><p>Continue creating the file system beginning with step 2 of the
Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimmkfscli"></a>13.2.3. Using the CLI</h3></div></div><p>Use the
	<b>mkfs</b> command to create the new file system.  
The arguments to <b>mkfs</b> include the FSIM type (in our example, JFS), followed
by any option pairs, and then the volume name.  The command to accomplish
this is:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">mkfs: JFS={vollabel=jfs_vol}, /dev/evms/my_vol</pre></td></tr></table><p>The command is completed upon saving.</p><p>If you are interested in other options that <b>mkfs</b> can 
use, look at the results of the following query:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: plugins, plugin=JFS, list options</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="fsimmkfsaex"></a>13.3. Example: check a file system</h2></div></div><p>You can also coordinate file system checks from the EVMS user interfaces.</p><blockquote class="blockquote"><div class="example"><a name="id2877956"></a><p class="title"><b>Example 13.2. Check a JFS File System</b></p><p>This example shows how to perform a file system check on a JFS file system, named <tt>jfs_vol</tt>, on volume <tt>/dev/evms/my_vol</tt>, with verbose output.
</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="FSIMmkfsgui"></a>13.3.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to check a JFS file system with the EVMS GUI:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>File Systems</b>-&gt;<b>Check/Repair</b>.
	</p></li><li><p>Select <b>/dev/evms/my_vol</b>.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Click the <b>Yes</b>  button by <b>Verbose Output</b>.  
	 Customize any other options you are interested in.
	</p></li><li><p>Click <b>Check</b>.
	</p></li><li><p>The operation is completed when you save.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to check a file system with the GUI context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click
	<tt>/dev/evms/my_vol</tt>.</p></li><li><p>Click <tt>Check/Repair File System...</tt>
	</p></li><li><p>Continue checking the file system beginning with step 3 of the
	GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="fsimfsckncurses"></a>13.3.2. Using Ncurses</h3></div></div><p>Follow these steps to check a JFS file system with Ncurses:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>File System</b>-&gt;<b>Check/Repair</b>
	</p></li><li><p>Select
	<tt> /dev/evms/my_vol</tt>.
	</p></li><li><p>Activate <b>Next</b>.
	</p></li><li><p>Scroll down using the <b>down</b> arrow until
	<b>Verbose Output</b> is highlighted.
	</p></li><li><p>Press <b>Spacebar</b> to change <b>Verbose Output</b> to <b>Yes</b>.
	</p></li><li><p>Activate <b>Check</b>.
	</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to check a file system with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Volumes view, press <b>Enter</b> on <tt>/dev/evms/my_vol</tt>.</p></li><li><p>Activate the <b>Check/Repair File System</b> menu item.</p></li><li><p>Continue checking the file system beginning with step 3 of the Ncurses
instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="FSIMmkfscli"></a>13.3.3. Using the CLI</h3></div></div><p>The CLI <b>check</b> command takes a volume name and options as
	 input.  The command to check the file system on <tt>/dev/evms/my_vol</tt> is the following:
	</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">check: /dev/evms/my_vol, verbose=TRUE</pre></td></tr></table><p>Currently, a query command for viewing additional options is not available.</p></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="clusterops"></a>Chapter 14. Clustering operations</h2></div></div><p>This chapter discusses how to configure cluster storage containers (referred to throughout
this chapter as &quot;cluster containers&quot;), a feature provided by the EVMS Cluster Segment
Manager (CSM).</p><p>Disks that are physically accessible from all of the nodes of the cluster can be
grouped together as a single manageable entity.  EVMS storage objects can then be
created using storage from these containers.</p><p>Ownership is assigned to a container to make the container either private or shared.
A container that is owned by any one node of the cluster is called a private container.
EVMS storage objects and storage volumes created using space from a private
container are accessible from only the owning node.</p><p>A container that is owned by all the nodes in a cluster is called a shared container.
EVMS storage objects and storage volumes created using space from a shared
container are accessible from all nodes of the cluster simultaneously.</p><p>EVMS provides the tools to convert a private container to a shared container, and
a shared container to a private container.  EVMS also provides the flexibility to
change the ownership of a private container from one cluster node to another
cluster node.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2877138"></a>14.1. Rules and restrictions for creating cluster containers</h2></div></div><p>Note the following rules and limitations for creating cluster containers:</p><div class="itemizedlist"><ul type="disc"><li><p>Do not assign non-shared disks to a cluster container.</p></li><li><p>Storage objects created on a cluster container must not span across
multiple cluster containers.  Currently, the EVMS Engine cannot enforce this rule, so
you must ensure that objects and volumes created from cluster storage manager
segments do not span multiple containers.</p></li><li><p>A disk should not span cluster containers.</p></li><li><p>Do not assign RAID, snapshot, and BBR features to storage
objects on a cluster container.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2877038"></a>14.2. Example: create a private cluster container</h2></div></div><p>This section tells how to create a sample private
container and provides instructions for completing the following task:</p><blockquote class="blockquote"><div class="example"><a name="id2877052"></a><p class="title"><b>Example 14.1. Create a private cluster container</b></p><p>Given a system with three available shared disks 
(<tt>sdd</tt>, <tt>sde</tt>, and 
<tt>sdf</tt>),
use the EVMS Cluster Segment Manager to combine these disk drives into a
container called <tt>Priv1</tt> owned by <tt>node1</tt>.
</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2878582"></a>14.2.1. Using the EVMS GUI</h3></div></div><p>To create a container with the EVMS GUI, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select 
<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Container</b> to see a list of plug-ins that support container creation.
</p></li><li><p>Select the <b>Cluster Segment Manager</b>.</p></li><li><p>Click <b>Next</b>.</p><p>The next dialog window contains a list of storage objects that
the CSM can use to create a container.</p></li><li><p>Select <tt>sdd</tt>, <tt>sde</tt>, and <tt>sdf</tt> from the list.</p></li><li><p>Click <b>Next</b>.</p></li><li><p>In the first pull-down menu, select the &quot;Node Id&quot; of the cluster node that
owns this container (<b>node1</b>).  Select &quot;Storage Type&quot; as 
<b>private</b> from the second pull-down menu.</p></li><li><p>Enter the name <b><tt>Priv1</tt></b> for the Container Name.</p></li><li><p>Click <b>Create</b>.</p><p>A window opens that displays the outcome.</p></li><li><p>Commit the changes.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2878774"></a>14.2.2. Using Ncurses</h3></div></div><p>To create the private container with the Ncurses interface, follow these steps:
</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Container</b> to see a list 
of plug-ins that support container creation.</p></li><li><p>Scroll down with the <b>down</b> arrow and select Cluster Segment Manager by
pressing <b>spacebar</b>.  The plug-in you selected is marked with an &quot;x.&quot;  </p></li><li><p>Press <b>Enter</b>.</p><p>The next submenu contains a list of disks that the Cluster Segment Manager finds
acceptable to use for the creation of a container.</p></li><li><p>Use <b>spacebar</b> to select <tt>sdd</tt>, <tt>sde</tt>, 
and <tt>sdf</tt> from the list.  The disks you select are marked with an &quot;x.&quot;</p></li><li><p>Press <b>Enter</b>.</p></li><li><p>On the Create Storage Container - Configuration Options menu, press 
<b>spacebar</b> on the Node Id, which will provide a list of nodes from
which to select.</p></li><li><p>Press <b>spacebar</b> on the node <tt>node1</tt> and 
then press <b>Enter</b>.</p></li><li><p>Scroll down with the <b>down</b> arrow and press <b>spacebar</b> on the
Storage Type.  A list of storage types opens.</p></li><li><p>Scroll down with the <b>down</b> arrow to 
<b>private entry</b> and press <b>spacebar</b>.</p></li><li><p>Press <b>Enter</b>.</p></li><li><p>Scroll down with the <b>down</b> arrow to 
<b>Container Name</b> and press <b>spacebar</b>.</p><p>The Change Option Value menu opens and asks for the Container Name.  Type
in the name of the container as <b><tt>Priv1</tt></b>, and press <b>Enter</b>.</p></li><li><p>Press <b>Enter</b> to complete the operation.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2879087"></a>14.2.3. Using the CLI</h3></div></div><p>An operation to create a private cluster container with the CLI takes three parameters: the name 
of the container, the type of the container, and the nodeid to which the container belongs.
</p><p>On the CLI, type the following command to create the private container
<tt>Priv1</tt>:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">create: container,CSM={name=&quot;Priv1&quot;,type=&quot;private&quot;,nodeid=&quot;node1&quot;},sdd,sde,sdf</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2879123"></a>14.3. Example: create a shared cluster container</h2></div></div><p>This section tells how to create a sample shared container and provides
instructions to help you complete the following task:</p><blockquote class="blockquote"><div class="example"><a name="id2879138"></a><p class="title"><b>Example 14.2. Create a shared cluster container</b></p><p>Given a system with three available shared disks 
(<tt>sdd</tt>, <tt>sde</tt>, and 
<tt>sdf</tt>),
use the EVMS Cluster Segment Manager to combine these disk drives into a shared
container called <tt>Shar1</tt>.
</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2879180"></a>14.3.1. Using the EVMS GUI</h3></div></div><p>To create a shared cluster container with the EVMS GUI, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select 
<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Container</b> to see a list of plug-ins that support container creation.
</p></li><li><p>Select the <b>Cluster Segment Manager</b>.</p></li><li><p>Click <b>Next</b>.</p><p>The next dialog window contains a list of storage objects that
the CSM can use to create a container.</p></li><li><p>Select <tt>sdd</tt>, <tt>sde</tt>, and <tt>sdf</tt> from the list.</p></li><li><p>Click <b>Next</b>.</p></li><li><p>You do not need to change the &quot;Node Id&quot; field. Select 
Storage Type as 
<b>shared</b> from the second pull-down menu.</p></li><li><p>Enter the name <b><tt>Shar1</tt></b> for the Container Name.</p></li><li><p>Click <b>Create</b>.  A window opens to display the outcome.</p></li><li><p>Commit the changes.</p></li><li><p>Quit the GUI and run <b>evms_activate</b> on each of the cluster 
nodes so that the nodes discover the volume.  
This process will be automated in future releases of EVMS.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2879376"></a>14.3.2. Using Ncurses</h3></div></div><p>To create a shared cluster contained with the Ncurses interface, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Container</b> to see a list of plug-ins that support container creation.</p></li><li><p>Scroll down with the <b>down</b> arrow and select Cluster Segment Manager by
pressing <b>spacebar</b>.  The plug-in you selected is marked with an &quot;x.&quot;  </p></li><li><p>Press <b>Enter</b>.</p><p>The next submenu contains a list of disks that the Cluster Segment Manager finds
acceptable to use for the creation of a container.</p></li><li><p>Use <b>spacebar</b> to select <tt>sdd</tt>, <tt>sde</tt>, 
and <tt>sdf</tt> from the list.  The disks you select are marked with an &quot;x.&quot;</p></li><li><p>Press <b>Enter</b>.</p></li><li><p>The Create Storage Container - Configuration Options menu open;
ignore the &quot;Node Id&quot; menu.</p></li><li><p>Scroll down with the <b>down</b> arrow and press <b>spacebar</b> on the
Storage Type.  A list of storage types opens.</p></li><li><p>Scroll down with the <b>down</b> arrow to 
<b>shared entry</b> and press <b>spacebar</b>.</p></li><li><p>Press <b>Enter</b>.</p></li><li><p>Scroll down with the <b>down</b> arrow to 
<b>Container Name</b> and press <b>spacebar</b>.</p><p>The Change Option Value menu opens and asks for the Container Name.  Type
in the name of the container as <b><tt>Shar1</tt></b>, and press <b>Enter</b>.</p></li><li><p>Press <b>Enter</b> to complete the operation.</p></li><li><p>Quit Ncurses and run <b>evms_activate</b> on each of the cluster 
nodes.  This process will be automated in future releases of EVMS.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2879671"></a>14.3.3. Using the CLI</h3></div></div><p>An operation to create a shared cluster container with the CLI takes two parameters:
the name of the container and the type of the container.</p><p>On the CLI,  type the following command to create shared container <tt>Shar1</tt>:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">create: container,CSM={name=&quot;Shar1&quot;,type=&quot;shared&quot;},sdd,sde,sdf</pre></td></tr></table><p>Run <b>evms_activate</b> on each node of the cluster.  This process will be automated in future releases of EVMS.</p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2879719"></a>14.4. Example: convert a private container to a shared container</h2></div></div><p>This section tells how to convert a sample private container to a shared
container and provides instructions for completing the following task:</p><blockquote class="blockquote"><div class="example"><a name="id2879734"></a><p class="title"><b>Example 14.3. Convert a private container to shared</b></p><p>Given a system with a private storage container <tt>Priv1</tt> owned 
by <tt>evms1</tt>, convert
<tt>Priv1</tt> to a shared storage container with the same name.</p></div></blockquote><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">CAUTION</h3><p>Ensure that no application
is using the volumes on the container on any node of the cluster.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2879780"></a>14.4.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to convert a private cluster container to a shared cluster 
container with the EVMS GUI:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Modify</b>-&gt;<b>Container</b> to see a list of containers.</p></li><li><p>Select the container <b>csm/Priv1</b> and press <b>Next</b>.</p><p>A Modify Properties dialog box opens.</p></li><li><p>Change &quot;Type Field&quot; to &quot;shared&quot; and click <b>Modify</b>.</p><p>A window opens that displays the outcome.</p></li><li><p>Commit the changes.</p></li><li><p>Quit the GUI and run <b>evms_activate</b> on all the cluster nodes so that the nodes discover
all the volumes on the <tt>csm/Priv1</tt> container.  This process will be
automated in a future release of EVMS.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2879906"></a>14.4.2. Using Ncurses</h3></div></div><p>Follow these steps to convert a private cluster container to a shared cluster
container with the Ncurses interface:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Modify</b>-&gt;<b>Container</b> to see a list of containers.</p></li><li><p>The Modify Container Properties dialog opens.  Select the container 
<tt>csm/Priv1</tt> by
pressing <b>spacebar</b>.  The container you selected is marked with an &quot;x.&quot;</p><p>Press <b>Enter</b>.</p></li><li><p>Use <b>spacebar</b> to select <tt>sdd</tt>, <tt>sde</tt>, 
and <tt>sdf</tt> from the list.  The disks you select are marked with an &quot;x.&quot;</p></li><li><p>Press <b>Enter</b>.</p></li><li><p>The Modify Container Properties - Configuration Options&quot; dialog opens. Scroll down with the <b>down</b> arrow and press <b>spacebar</b> on the &quot;Type field&quot;.</p></li><li><p>Press <b>spacebar</b>.</p></li><li><p>The Change Option Value dialog opens.  Type <b><tt>shared</tt></b> and press <b>Enter</b>.</p><p>The changed value is now displays in the Modify Container Properties -
Configuration Options dialog.</p></li><li><p>Press <b>Enter</b>.</p><p>The outcome of the command is displayed at the bottom of the screen.</p></li><li><p>Save the changes by clicking <b>Save</b> in the <b>Actions</b> pulldown menu.</p></li><li><p>Quit Ncurses and run <b>evms_activate</b> on all the cluster nodes so that the nodes discover
all the volumes on the <tt>csm/Priv1</tt> container.  This process will be
automated in a future release of EVMS.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2880165"></a>14.4.3. Using the CLI</h3></div></div><p>The <b>modify</b> command modifies the properties of a container.  The first argument
of the command is the object to modify, followed by its new properties.  The command
to convert the private container to a shared container in the example is:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">modify: csm/Priv1,type=shared</pre></td></tr></table><p>Run <b>evms_activate</b> on all the cluster nodes so that the nodes discover
all the volumes on the <tt>csm/Priv1</tt> container.  This process will be
automated in a future release of EVMS.</p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2880216"></a>14.5. Example: convert a shared container to a private container</h2></div></div><p>This section tells how to convert a sample shared container to a private
container and provides instructions for completing the following task:</p><blockquote class="blockquote"><div class="example"><a name="id2880231"></a><p class="title"><b>Example 14.4. Convert a shared container to private</b></p><p>Given a system with a shared storage container <tt>Shar1</tt>, convert
<tt>Shar1</tt> to a private storage container owned by node <tt>node1</tt> (where
<tt>node1</tt> is the nodeid of one of the cluster nodes).</p></div></blockquote><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">CAUTION</h3><p>Ensure that no application
is using the volumes on the container of any node in the cluster.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2880285"></a>14.5.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to convert a shared cluster container to a private cluster 
container with the EVMS GUI:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Modify</b>-&gt;<b>Container</b> to see a list of containers.</p></li><li><p>Select the container <b>csm/Shar1</b> and press <b>Next</b>.</p><p>A Modify Properties dialog opens.</p></li><li><p>Change &quot;Type Field&quot; to &quot;private&quot; and the &quot;NodeID&quot; field to <tt>node1</tt>.  Click <b>Modify</b>.</p><p>A window opens that displays the outcome.</p></li><li><p>Commit the changes.</p></li><li><p>Quit the GUI and run <b>evms_activate</b>  on the other nodes to deactivate
the volumes of the shared container on the other nodes. This process will be
automated in a future release of EVMS.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2880411"></a>14.5.2. Using Ncurses</h3></div></div><p>Follow these steps to convert a shared cluster container to a private cluster
container with the Ncurses interface:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Modify</b>-&gt;<b>Container</b></p></li><li><p>The Modify Container Properties dialog opens.  Select the container 
<tt>csm/Shar1</tt> by
pressing <b>spacebar</b>.  The container you selected is marked with an &quot;x.&quot;</p><p>Press <b>Enter</b>.</p></li><li><p>The Modify Container Properties - Configuration Options&quot; dialog opens. Scroll down with the <b>down</b> arrow and press <b>spacebar</b> on the &quot;Type&quot; field.</p></li><li><p>Press <b>spacebar</b>.</p></li><li><p>The Change Option Value dialog opens.  Type <b><tt>private</tt></b> and press <b>Enter</b>.</p></li><li><p>The Modify Container Properties -
Configuration Options dialog opens.  Scroll down the list to <b>NodeId</b> 
with the <b>down</b> arrow 
and press <b>spacebar</b>.</p></li><li><p>The Change Option Value dialog opens.  Enter <b><tt>node1</tt></b> and press <b>Enter</b>.</p></li><li><p>The changed values now display in the Modify Container Properties -
Configuration Options dialog.  Press <b>Enter</b>. </p><p>The outcome of the command is displayed at the bottom of the screen.</p></li><li><p>Save the changes by clicking <b>Save</b> in the <b>Actions</b> pulldown.</p></li><li><p>Quit Ncurses and run <b>evms_activate</b> on all the cluster nodes to deactivate the volumes of the shared container on all the other nodes.  This process will be
automated in a future release of EVMS.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2880659"></a>14.5.3. Using the CLI</h3></div></div><p>The <b>modify</b> command modifies the properties of a container.  The first argument
of the command is the object to modify, followed by its new properties.  The command
to convert the shared container to a private container in the example is:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">modify: csm/Shar1,type=private,nodeid=node1</pre></td></tr></table><p>Run <b>evms_activate</b> on all the cluster nodes to deactivate the volumes
of the shared container on all the other nodes.  This process will be
automated in a future release of EVMS.</p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2880704"></a>14.6. Example: deport a private or shared container</h2></div></div><p>
When a container is deported, the node disowns the container and deletes
all the objects created in memory that belong to that container.  
No node in
the cluster can discover objects residing on a deported container or
create objects for a deported container.
This section explains how to deport a private or shared container.  
</p><blockquote class="blockquote"><div class="example"><a name="id2880722"></a><p class="title"><b>Example 14.5. Deport a cluster container</b></p><p>Given a system with a private or shared  storage container named 
<tt>c1</tt>, deport <tt>c1</tt>.
</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2880749"></a>14.6.1. Using the EVMS GUI</h3></div></div><p>
To deport a container with the EVMS GUI, follow these steps:
</p><div class="orderedlist"><ol type="1"><li><p>Select 
<b>Actions</b>-&gt;<b>Modify</b>-&gt;<b>Container</b>.
</p></li><li><p>Select the container <tt>csm/c1</tt> and press 
<b>Next</b>.
</p><p>
A Modify Properties dialog opens.
</p></li><li><p>Change &quot;Type Field&quot; to &quot;deported.&quot;  Click <b>Modify</b>.
</p><p>
A window opens that displays the outcome.
</p></li><li><p>Commit the changes.
</p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>
If the deported container was a shared container, quit the GUI and then
run <b>evms_activate</b> on each cluster node.  This operation
will be automated in a future release of EVMS.
</p></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2880878"></a>14.6.2. Using Ncurses</h3></div></div><p>
To deport a container with Ncurses, follow these steps: 
</p><div class="orderedlist"><ol type="1"><li><p>Scroll down the list with the <b>down</b> arrow to
<b>Modify</b>.  Press <b>Enter</b>.
</p><p>
A submenu is displayed.
</p></li><li><p>Scroll down until Container is highlighted.  Press <b>Enter</b>.
</p><p>
The Modify Container Properties dialog opens.
</p></li><li><p>Select the container <tt>csm/c1</tt> by pressing
<b>spacebar</b>.  The container you selected is marked with an &quot;x.&quot;
</p></li><li><p>
Press <b>Enter</b>.
</p><p>
The Modify Container Properties - Configuration Options dialog opens.
</p></li><li><p>Scroll down and press <b>spacebar</b> on the &quot;Type&quot; field.  
</p></li><li><p>
Press <b>spacebar</b>.
</p><p>
The Change Option Value dialog opens.
</p></li><li><p>Type <b><tt>deported</tt></b> and press <b>Enter</b>.
</p><p>
The changed value is displayed in the Modify Container Properties -
Configuration Options dialog.
</p></li><li><p>Press <b>Enter</b>.
</p><p>
The outcome of the command is displayed at the bottom of the screen.
</p></li><li><p>Commit the changes by clicking <b>Save</b> in the 
<b>Actions</b> pulldown.
</p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>
If the deported container was a shared container, quit Ncurses and then
run <b>evms_activate</b> on each cluster node.  This operation
will be automated in a future release of EVMS.
</p></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2881124"></a>14.6.3. Using the CLI</h3></div></div><p>
To deport a container from the CLI, execute the following command
at the CLI prompt:
</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">
modify: csm/c1,type=&quot;deported&quot;
</pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>
If the deported container was a shared container, 
run <b>evms_activate</b> on each cluster node.  This operation
will be automated in a future release of EVMS.
</p></div></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2881166"></a>14.7. Deleting a cluster container</h2></div></div><p>
The procedure for deleting a cluster container is the same for deleting
any container.  See <a href="#examdelrecur" title="19.2. Example: perform a delete recursive operation">Section 19.2, &quot;Example: perform a delete recursive operation&quot;</a>





</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2881186"></a>14.8. Failover and Failback of a private container on Linux-HA</h2></div></div><p>EVMS supports the Linux-HA cluster manager in EVMS V2.0 and later.  Support for 
the RSCT cluster
manager is also available as of EVMS V2.1, but is not as widely tested.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>Ensure that <b>evms_activate</b> is called in one of the startup scripts
before the <b>heartbeat</b> startup script is called. If <b>evms_activate</b> is not called, failover
might not work correctly. </p></div><p>Follow these steps to set up failover and failback of a private container:</p><div class="orderedlist"><ol type="1"><li><p>Add an entry in <tt>/etc/ha.d/haresources</tt> for each 
private container to be failed over.  For example, if <tt>container1</tt> and 
<tt>container2</tt> are to
be failed over together to the same node with <tt>node1</tt> as the owning node, add the
following entry to <tt>/etc/ha.d/haresources</tt>:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">node1 evms_failover::container1 evms_failover::container2</pre></td></tr></table><p><tt>node1</tt> is the cluster node that owns this resource.  The resource is failed over
to the other node when <tt>node1</tt> dies.</p><p>Similarly, if <tt>container3</tt> and <tt>container4</tt> are to be failed over together to the same
node with <tt>node2</tt> as the owning node, then add the following entry to 
<tt>/etc/ha.d/haresources</tt>:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">node2 evms_failover::container3 evms_failover::container4</pre></td></tr></table><p>Refer to the following source for more details on the semantics of resource groups:
<a href="http://www.linux-ha.org/download/GettingStarted.html" target="_top">http://www.linux-ha.org/download/GettingStarted.html</a>.</p></li><li><p>Validate that the <tt>/etc/ha.d</tt>, <tt>/etc/ha.cf</tt> and <tt>/etc/ha.d/haresources</tt> files are the same
on all the nodes of the cluster.</p></li><li><p>The heartbeat cluster manager must be restarted, as follows, after the
<tt>/etc/ha.d/haresources</tt> file has been changed:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">/etc/init.d/heartbeat restart</pre></td></tr></table><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>
Do not add shared containers to the list of failover resources; doing so causes
EVMS to respond unpredictably.</p></div></li></ol></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2881442"></a>14.9. Remote configuration management</h2></div></div><p>EVMS supports the administration of cluster nodes by any node in the cluster.  For
example, storage on remote cluster node <tt>node1</tt> can be administered from cluster node
<tt>node2</tt>.  The following sections show how to set up remote administration
through the various EVMS user interfaces.</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2881471"></a>14.9.1. Using the EVMS GUI</h3></div></div><p>To designate <tt>node2</tt> as the node to administer from the GUI, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Settings</b>-&gt;<b>Node Administered...</b></p></li><li><p>Select <tt>node2</tt>.</p></li><li><p>Click <b>Administer</b> to switch to the new node.</p></li></ol></div><p>
The discovery of the remote configuration is initiated and the status
bar displays the message &quot;Now administering node node2,&quot; which indicates
that the GUI is switched over to node node2.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2881558"></a>14.9.2. Using Ncurses</h3></div></div><p>To designate <tt>node2</tt> as the node to administer from Ncurses, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Go to the <b>Settings</b> pulldown menu.</p></li><li><p>Scroll down with the <b>down</b> arrow to the &quot;Node Administered&quot; option and
press <b>Enter</b>.</p></li><li><p>The Administer Remote Node dialog opens.  Select <tt>node2</tt> and press
<b>spacebar</b>.</p><p>The node you selected is marked with an &quot;x.&quot;</p></li><li><p>Press <b>Enter</b>.</p></li><li><p>The &quot;EVMS is examining your system.  Please wait&quot; dialog opens.  After a
while you will be switched over to the node <tt>node2</tt>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2881676"></a>14.9.3. Using the CLI</h3></div></div><p>To designate <tt>node2</tt> as a node administrator from the CLI, issue this command:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">evms -n node2</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2881704"></a>14.10. Forcing a cluster container to be imported</h2></div></div><p>
A private container and its objects are made active on a node if:</p><div class="itemizedlist"><ul type="disc"><li><p>
the private container is owned by the node
</p></li><li><p>
the container is not deported
</p></li><li><p>
the node currently has quorum
</p></li></ul></div><p>
Similarly, a shared container and its objects are made active on a node if
the node currently has quorum. However, the administrator can force the
importation of private and shared containers by overriding these rules, as
follows:
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>
Use extreme caution when performing this operation by ensuring that the
node on which the cluster container resides is the only active node in the
cluster.  Otherwise, the data in volumes on shared and private containers
on the node can get corrupted.
</p></div><div class="orderedlist"><ol type="1"><li><p>
Enabling the maintenance mode in the <b>evms.conf</b> file.
The option to modify in the <b>evms.conf</b> file is the following:
</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">
# cluster segment manager section
csm {
#	admin_mode=yes	# values are: yes or no
				# The default is no. Set this key to
				# yes when you wish to force the CSM
				# to discover objects from all cluster
				# containers, allowing you to perform
				# configuration and maintenance.  Setting
				# admin_mode to yes will cause the CSM
				# to ignore container ownership, which
				# will allow you to configure storage
				# in a maintenance mode.
</pre></td></tr></table><p>
</p></li><li><p>
Running <b>evms_activate</b> on the node.
</p></li></ol></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmsconvert"></a>Chapter 15. Converting volumes</h2></div></div><p> This chapter discusses converting compatibility volumes to EVMS
volumes and converting EVMS volumes to compatibility volumes. For a discussion 
of the differences between compatibility and EVMS volumes, see <a href="#evmscreatevol" title="Chapter 12. Creating volumes">Chapter 12. &quot;<i>Creating volumes</i>&quot;</a>.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2878543"></a>15.1. When to convert volumes</h2></div></div><p>There are several different scenarios that might help you determine what type of volumes you need. For example, if you wanted persistent names or to make full use of EVMS features, such as BBR, Drive Linking, or Snapshotting, you would convert your compatibility volumes to EVMS volumes. In another situation, you might decide that a volume needs to be read by a system that understands the underlying volume management scheme. In this case, you would convert your EVMS volume to a compatibility volume.</p><p>A volume can only be converted when it is offline.  This means the volume must
be unmounted and otherwise not in use.  The volume must be unmounted because the conversion operation changes both the name and the device number of the volume.  Once the volume
is converted, you can remount it using its new name.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="comptoevms"></a>15.2. Example: convert compatibility volumes to EVMS volumes</h2></div></div><p>A compatibility volume 
can be converted to an EVMS volume in the following situations:
</p><div class="itemizedlist"><ul type="disc"><li><p>The compatibility volume has no file system (FSIM) on it.</p></li><li><p>The compatibility volume has a file system, but the file system can be shrunk (if necessary) to make 
room for the EVMS metadata.</p></li></ul></div><p>This section provides a detailed explanation of how to convert compatibility 
	volumes to EVMS volumes and provides instructions to help you complete the following task.  </p><blockquote class="blockquote"><div class="example"><a name="id2878483"></a><p class="title"><b>Example 15.1. Convert a compatibility volume</b></p><p>You have a compatibility volume <tt>/dev/evms/hda3</tt>
	that you want to make into an EVMS volume named <tt>my_vol</tt>.</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="c2egui"></a>15.2.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to convert a compatibility volume with the EVMS GUI:</p><div class="orderedlist"><ol type="1"><li><p>Choose <b>Action</b>-&gt;<b>Convert </b>-&gt;<b>Compatibility Volume to EVMS</b>.  </p></li><li><p>Select  <tt>/dev/evms/hda3</tt> 
		from the list of available volumes.</p></li><li><p>Type <tt>my_vol</tt> in the name field.</p></li><li><p>Click the <b>Convert</b> button 
		to convert the volume.</p></li></ol></div><p>Alternatively, you can perform some of the steps to convert the volume from the GUI
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click 
	on <tt>/dev/evms/hda3</tt>.</p></li><li><p>Click <b>Convert to EVMS Volume...</b></p></li><li><p>Continue to convert the volume beginning with step 3 of the GUI 
	instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="c2encur"></a>15.2.2. Using Ncurses</h3></div></div><p>Follow these instructions to convert a compatibility volume to an EVMS volume
	with the Ncurses
	interface:</p><div class="orderedlist"><ol type="1"><li><p>Choose <b>Actions</b>-&gt;<b>Convert</b>-&gt;<b>Compatibility Volume to EVMS Volume</b></p></li><li><p>Select <tt>/dev/evms/hda3</tt> from the list
		of available volumes.</p></li><li><p>Type <b><tt>my_vol</tt></b> when prompted for the name.
		Press <b>Enter</b>.</p></li><li><p>Activate <b>Convert</b>.</p></li></ol></div><p>Alternatively, you can perform some of the steps to convert the volume from the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Volumes view, press <b>Enter</b> on <tt>/dev/evms/hda3</tt>.</p></li><li><p>Activate the <b>Convert to EVMS Volume</b> menu item.</p></li><li><p>Continue to convert the volume beginning with step 3 of the Ncurses
instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2882270"></a>15.2.3. Using the CLI</h3></div></div><p>To convert a volume, use the <b>Convert</b> command. 
		The <b>Convert</b> command takes the name of a volume as its first argument, and 
		then <tt>name=</tt> for what you want to name the new volume 
		as the second argument. To complete the example and convert a volume, type the 
		following command at the <tt>EVMS:</tt> prompt:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">convert: /dev/evms/hda3, Name=my_vol</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="evmstocomp"></a>15.3. Example: convert EVMS volumes to compatibility volumes</h2></div></div><p>An EVMS volume can be converted to a compatibility volume only if the volume does not have EVMS 
	features on it. This section provides a detailed explanation of how to convert EVMS volumes to compatibility volumes 
	by providing instructions to help you complete the following task. </p><blockquote class="blockquote"><div class="example"><a name="id2882341"></a><p class="title"><b>Example 15.2. Convert an EVMS volume</b></p><p>You have an EVMS volume, <tt>/dev/evms/my_vol</tt>,
	that you want to make a compatibility volume.</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="e2cgui"></a>15.3.1. Using the EVMS GUI</h3></div></div><p>Follow these instructions to convert an EVMS volume to a compatibility
	volume with the EVMS GUI:</p><div class="orderedlist"><ol type="1"><li><p>Choose <b>Action</b>-&gt;<b>Convert </b>-&gt;<b>EVMS Volume to Compatibility Volume</b>.  </p></li><li><p>Select  <tt>/dev/evms/my_vol</tt> 
		from the list of available volumes.</p></li><li><p>Click the <b>Convert</b> button 
		to convert the volume.</p></li></ol></div><p>Alternatively, you can perform some of the steps to convert the volume through
	the GUI context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click 
	<tt>/dev/evms/my_vol</tt>.</p></li><li><p>Click <b>Convert to Compatibility Volume...</b></p></li><li><p>Continue converting the volume beginning with step 3 of the
	GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="e2cncur"></a>15.3.2. Using Ncurses</h3></div></div><p>Follow these instructions to convert an EVMS volume to a compatibility volume
with the Ncurses interface:</p><div class="orderedlist"><ol type="1"><li><p>Choose <b>Actions</b>-&gt;<b>Convert</b>-&gt;<b>EVMS Volume to 
		Compatibility Volume</b></p></li><li><p>Select <tt>/dev/evms/my_vol</tt> from the
		list of available volumes.</p></li><li><p>Activate <b>Convert</b>. 
		</p></li></ol></div><p>Alternatively, you can perform some of the steps to convert the volume through
the context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Volumes view, press <b>Enter</b> on <tt>/dev/evms/my_vol</tt>.</p></li><li><p>Activate the <b>Convert to Compatibility Volume</b> menu item.</p></li><li><p>Continue to convert the volume beginning with step 3 of the Ncurses
instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="e2ccli"></a>15.3.3. Using the CLI</h3></div></div><p>To convert a volume use the <b>Convert</b> command. 
		The <b>Convert</b> command takes the name of a volume as its first argument, and 
		the keyword <tt>compatibility</tt> to indicate  a change to a compatibility volume  
		as the second argument. To complete the example and convert a volume, type the 
		following command at the <tt>EVMS:</tt> prompt:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">convert: /dev/evms/my_vol, compatibility</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="expandshrink"></a>Chapter 16. Expanding and shrinking volumes</h2></div></div><p>This chapter tells how to expand and shrink EVMS volumes with the EVMS 
GUI, Ncurses, and CLI interfaces.  Note that you can also expand and shrink compatibility volumes and EVMS objects.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whyexpandshrink"></a>16.1. Why expand and shrink volumes?</h2></div></div><p>Expanding and shrinking volumes are common volume operations on most systems.  For example, it might be necessary to shrink a particular volume to create
free space for another volume to expand into or to create a new volume.</p><p>EVMS simplifies the process for expanding and shrinking volumes, and
protects the integrity of your data, by coordinating expand and shrink
operations with the volume's file system.  For example, when shrinking a
volume, EVMS first shrinks the underlying file system appropriately to protect
the data.  When expanding a volume, EVMS expands the file system automatically
when new space becomes available.</p><p>Not all file system interface modules (FSIM) types supported by EVMS 
allow shrink and expand operations, and some only perform the operations when
the file system is mounted (&quot;online&quot;).  The following table details the 
shrink and expand options available for each type of FSIM.
</p><div class="table"><a name="id2881958"></a><p class="title"><b>Table 16.1. FSIM support for expand and shrink operations</b></p><table summary="FSIM support for expand and shrink operations" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>FSIM type</th><th>Shrinks</th><th>Expands</th></tr></thead><tbody><tr><td>JFS</td><td>No</td><td>Online only</td></tr><tr><td>XFS</td><td>No</td><td>Online only</td></tr><tr><td>ReiserFS</td><td>Offline only</td><td>Offline and online</td></tr><tr><td>ext2/3</td><td>Offline only</td><td>Offline only</td></tr><tr><td>SWAPFS</td><td>Offline only</td><td>Offline only</td></tr></tbody></table></div><p>You can perform all of the supported shrink and expand operations with each of the EVMS user interfaces.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="exshrink"></a>16.2. Example: shrink a volume</h2></div></div><p>This section tells how to shrink a compatibility volume by 500 MB.</p><blockquote class="blockquote"><div class="example"><a name="id2882876"></a><p class="title"><b>Example 16.1. Shrink a volume</b></p><p>Shrink the volume 
<tt>/dev/evms/lvm/Sample Container/Sample Region</tt>, which
is the compatibility volume that was created in the chapter entitled 
&quot;Creating Volumes,&quot; by 500 MB.</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="shrinkgui"></a>16.2.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to shrink the volume with the EVMS GUI:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Shrink</b>-&gt;<b>Volume...</b></p></li><li><p>Select <b>/dev/evms/lvm/Sample Container/Sample Region</b> 
	from the list of volumes.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Select <b>/lvm/Sample Container/Sample Region</b> from the list of volumes.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Enter <b><tt>500MB</tt></b> in the &quot;Shrink by Size&quot; field.</p></li><li><p>Click <b>Shrink</b>.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to shrink the volume with the GUI
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click
	<tt>/dev/evms/lvm/Sample Container/Sample Region</tt></p></li><li><p>Click <b>Shrink...</b></p></li><li><p>Continue the operation beginning with step 3 of the GUI
	instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="shrinkncurses"></a>16.2.2. Using Ncurses</h3></div></div><p>Follow these steps to shrink a volume with Ncurses:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Shrink</b>-&gt;<b>Volume</b>.
	</p></li><li><p>Select
	 <b>/dev/evms/lvm/Sample Container/Sample Region</b> from the
	list of volumes.
	</p></li><li><p>Activate <b>Next</b>.
	</p></li><li><p>Select
	 <b>lvm/Sample Container/Sample Region</b> from the
	shrink point selection list.
	</p></li><li><p>Activate <b>Next</b>.
	</p></li><li><p>Scroll down using the <b>down</b> arrow until
	<b>Shrink by Size</b> is highlighted.
	</p></li><li><p>Press <b>spacebar</b>.
	</p></li><li><p>Press <b>Enter</b>.
	</p></li><li><p>At the &quot;::&quot; prompt enter <b><tt>500MB</tt></b>.
	</p></li><li><p>Press <b>Enter</b>.
	</p></li><li><p>Activate <b>Shrink</b>.
	</p></li></ol></div><p>
</p><p>
Alternatively, you can perform some of the steps to shrink the volume with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Volumes view, press <b>Enter</b> on <tt>/dev/evms/lvm/Sample Container/Sample Region</tt>.</p></li><li><p>Activate the <b>Shrink</b> menu item.</p></li><li><p>Continue the operation beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="shrinkcli"></a>16.2.3. Using the CLI</h3></div></div><p>The <b>shrink</b> command takes a shrink point followed by an optional name
value pair or an optional shrink object.  To find the shrink point, use the <b>query</b> command with the shrink points filter on the object or volume you plan to shrink.  For example:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: shrink points, &quot;/dev/evms/lvm/Sample Container/Sample Region&quot;</pre></td></tr></table><p>Use a list options filter on the object of the shrink point to determine the name-value pair to use, as follows:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: objects, object=&quot;lvm/Sample Container/Sample Region&quot;, list options</pre></td></tr></table><p>With the option information that is returned, you can construct the command, as follows:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">shrink: &quot;lvm/Sample Container/Sample Region&quot;, remove_size=500MB</pre></td></tr></table></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="mkfs"></a>16.3. Example: expand a volume</h2></div></div><p>This section tells how to expand a volume a compatibility volume by 500 MB.</p><blockquote class="blockquote"><div class="example"><a name="id2883428"></a><p class="title"><b>Example 16.2. Expand a volume</b></p><p>Expand the volume <tt>/dev/evms/lvm/Sample Container/Sample Region</tt>, which is the compatibility volume that was created in the chapter entitled &quot;Creating Volumes,&quot; by 500 MB.
</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="expandgui"></a>16.3.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to expand the volume with the EVMS GUI:

</p><div class="orderedlist"><ol type="1"><li><p>Select
	<b>Actions</b>-&gt;<b>Expand</b>-&gt;<b>Volume...</b>
	</p></li><li><p>Select 
	<b>/dev/evms/lvm/Sample Container/Sample Region</b>
	from the list of volumes.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Select <b>lvm/Sample Container/Sample Region</b>  from the list as the expand point.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Enter <b><tt>500MB</tt></b> in the &quot;Additional Size&quot; field.</p></li><li><p>Click <b>Expand.</b></p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to expand the volume with the GUI
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click
	<tt>/dev/evms/lvm/Sample Container/Sample Region</tt>.</p></li><li><p>Click <b>Expand...</b></p></li><li><p>Continue the operation to expand the volume beginning with step 3
	of the GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="expandncurses"></a>16.3.2. Using Ncurses</h3></div></div><p>Follow these steps to expand a volume with Ncurses:

	</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Expand</b>-&gt;<b>Volume</b>.
	</p></li><li><p>Select
	 <b>/dev/evms/lvm/Sample Container/Sample Region</b> from the
	list of volumes.
	</p></li><li><p>Activate <b>Next</b>.
	</p></li><li><p>Select	<b>lvm/Sample Container/Sample Region</b> from
	the list of expand points.
	</p></li><li><p>Activate <b>Next</b>.</p></li><li><p>Press <b>spacebar</b> on the <b>Additional Size</b> field.
	</p></li><li><p>At the &quot;::&quot; prompt enter <b><tt>500MB</tt></b>.
	</p></li><li><p>Press <b>Enter</b>.
	</p></li><li><p>Activate <b>Expand</b>.
	</p></li></ol></div><p>


</p><p>Alternatively, you can perform some of the steps to shrink the volume with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Volumes view, press <b>Enter</b> on /<b>dev/evms/lvm/Sample Container/Sample Region</b>.</p></li><li><p>Activate the <b>Expand</b> menu item.</p></li><li><p>Continue the operation beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="expandcli"></a>16.3.3. Using the CLI</h3></div></div><p>The <b>expand</b> command takes an expand point followed by an optional name
value pair and an expandable object.  To find the expand point, use the <b>query</b> command with the Expand Points filter on the object or volume you plan to expand.  For example:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: expand points, &quot;/dev/evms/lvm/Sample Container/Sample Region&quot;</pre></td></tr></table><p>Use a list options filter on the object of the expand point to determine the name-value pair to use, as follows:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: objects, object=&quot;lvm/Sample Container/Sample Region&quot;, list options</pre></td></tr></table><p>The free space in your container is the container name plus <tt>/Freespace</tt>.</p><p>With the option information that is returned, you can construct the command, as follows:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">expand: &quot;lvm/Sample Container/Sample Region&quot;, add_size=500MB, 
&quot;lvm/Sample Container/Freespace&quot;</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="addfeatures"></a>Chapter 17. Adding features to an existing volume</h2></div></div><p>This chapter tells how to add additional EVMS features to an
already existing EVMS volume.
</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whyadd"></a>17.1. Why add features to a volume?</h2></div></div><p>EVMS lets you add features such as drive linking or bad block relocation to 
a volume that already exists.  By adding features, you avoid having to potentially
destroy the volume and recreate it from scratch.  For example, take the
scenario of a volume that contains important data but is almost full.
If you wanted to add more data to that volume but no free space existed on the
disk immediately after the segment, you could add a drive link to the volume.
The drive link concatenates another object to the end of the volume and 
continues seamlessly.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="exaddfeature"></a>17.2. Example: add drive linking to an existing volume</h2></div></div><p> The following example shows how to add drive linking to a volume with
the EVMS GUI, Ncurses, and CLI interfaces.
</p><blockquote class="blockquote"><div class="example"><a name="id2882831"></a><p class="title"><b>Example 17.1. Add drive linking to an existing volume</b></p><p>The following sections show how to add a drive link to volume
<tt>/dev/evms/vol</tt> and call the drive link &quot;DL.&quot;  

</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">NOTE</h3><p>Drive linking can be done only on
EVMS volumes; therefore, <tt>/dev/evms/vol</tt> must be converted to an EVMS volume if it is not
already. </p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="addfeaturegui"></a>17.2.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to add a drive link to the volume with the EVMS GUI:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Add</b>-&gt;<b>Feature to Volume</b>.
	</p></li><li><p>Select <b>/dev/evms/vol</b>
	</p></li><li><p>Click <b>Next</b>.  
	</p></li><li><p>Select <b>Drive Linking Feature</b>. 
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Type <b><tt>DL</tt></b> in the Name Field.</p></li><li><p>Click <b>Add</b>.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to add a drive link with the GUI
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click
	<tt>/dev/evms/vol</tt>.</p></li><li><p>Click <b>Add feature...</b></p></li><li><p>Continue adding the drive link beginning with step 3 of the
	GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="addfeaturesncurses"></a>17.2.2. Using Ncurses</h3></div></div><p>Follow these steps to add a drive link to a volume with Ncurses:

	</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Add</b>-&gt;<b>Feature to Volume</b>.

	</p></li><li><p>Select
	 <b>/dev/evms/vol</b>.
	</p></li><li><p>Activate <b>Next</b>.
	</p></li><li><p>Select 
	<b>Drive Linking Feature</b>.
	</p></li><li><p>Activate <b>Next</b>.
	</p></li><li><p>Press <b>Spacebar</b> to edit the Name field.
	</p></li><li><p>At the &quot;::&quot; prompt enter <b><tt>DL</tt></b>.
	</p></li><li><p>Press <b>Enter</b>.
	</p></li><li><p>Activate <b>Add</b>.</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the steps to add a drive link with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Volumes view, press <b>Enter</b> on <b>/dev/evms/vol</b>.</p></li><li><p>Activate the <b>Add feature</b> menu item.</p></li><li><p>Continue adding the drive link beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="addfeaturescli"></a>17.2.3. Using the CLI</h3></div></div><p>Use the
	<b>add feature</b> to add a feature to an existing volume.
	Specify the command name followed by a colon, followed by any options
	and the volume to operate on.  To determine the options for a given
	feature, use the following query:
	</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: plugins, plugin=DriveLink, list options</pre></td></tr></table><p>
The option names and descriptions are listed to help you construct
your command.  For our example, the command would look like the following:
</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">add feature: DriveLink={ Name=&quot;DL }, /dev/evms/vol</pre></td></tr></table></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="plugintasks"></a>Chapter 18. Plug-in operations tasks</h2></div></div><p>This chapter discusses plug-in operations tasks and shows how to complete a plug-in task with the EVMS GUI, Ncurses, and CLI interfaces.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="aboutplugintasks"></a>18.1. What are plug-in tasks?</h2></div></div><p>Plug-in tasks are functions that are available only within the context of a particular plug-in.  These functions are not common to all plug-ins.  For example, tasks to add spare disks to a RAID array make sense only in the context of the MD plug-in, and tasks to reset a snapshot make sense only in the context of the Snapshot plug-in.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="pluginexample"></a>18.2. Example: complete a plug-in operations task</h2></div></div><p> This section shows how to complete a plug-in operations task with the EVMS GUI, Ncurses, and CLI interfaces.</p><blockquote class="blockquote"><div class="example"><a name="id2884083"></a><p class="title"><b>Example 18.1. Add a spare disk to a compatibility volume made from an MDRaid5 region</b></p><p>This example adds disk <tt>sde</tt> as a spare disk onto volume <tt>/dev/evms/md/md0</tt>, which is a compatibility volume that was created from an MDRaid5 region.</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="plugingui"></a>18.2.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to add <tt>sde</tt> to <tt>/dev/evms/md/md0</tt>  with the EVMS GUI:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Other</b>-&gt;<b>Storage Object Tasks...</b>
	</p></li><li><p>Select <b>md/md0</b>.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Select <b>Add spare object</b>.
	</p></li><li><p>Click <b>Next</b>.
	</p></li><li><p>Select <b>sde</b>.</p></li><li><p>Click <b>Add</b>.
	</p></li><li><p>The operation is completed when you save.</p></li></ol></div><p>
</p><p>Alternatively, you could use context-sensitive menus to 
complete the task, as follows:		

</p><div class="orderedlist"><ol type="1"><li><p>View the region <tt>md/md0</tt>.  You can view the region either 
	by clicking on the small plus sign beside the volume name 
	(<tt>/dev/evms/md/md0</tt>) on the <b>volumes tab</b>, 
	or by selecting the <b>regions tab</b>.</p></li><li><p>Right click the region (<tt>md/md0</tt>).  A list of acceptable
	Actions and Navigational shortcuts displays.  The last items on the
	list are the tasks that are acceptable at this time.</p></li><li><p>Point to <b>Add spare object</b> and 
	left click.</p></li><li><p>Select <b>sde</b>.</p></li><li><p>Click <b>Add</b>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="plugintasksncurses"></a>18.2.2. Using Ncurses</h3></div></div><p>Follow these steps to add <tt>sde</tt> to <tt>/dev/evms/md/md0</tt> with Ncurses:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Other</b>-&gt;<b>Storage Object Tasks</b>
	</p></li><li><p>Select
	<b>md/md0</b>.
	</p></li><li><p>Activate <b>Next</b>.
	</p></li><li><p>Select
	<b>Add spare object</b>.
	</p></li><li><p>Activate <b>Next</b>.
	</p></li><li><p>Select
	<b>sde</b>.
	</p></li><li><p>Activate <b>Add</b>.
	</p></li></ol></div><p>
</p><p>Alternatively, you can use the context sensitive menu to complete the task:</p><div class="orderedlist"><ol type="1"><li><p>From the Regions view, press <b>Enter</b> on <b>md/md0</b>.</p></li><li><p>Activate the <b>Add spare object</b> menu item.</p></li><li><p>Select <b>sde</b>.</p></li><li><p>Activate <b>Add</b>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="plugincli"></a>18.2.3. Using the CLI</h3></div></div><p>With the EVMS CLI, all plug-in tasks must be 
accomplished with the <b>task</b> command.  Follow these steps 
to add <tt>sde</tt> to <tt>/dev/evms/md/md0</tt> 
with the CLI:
	
	</p><div class="orderedlist"><ol type="1"><li><p>The following query command with the list 
	options filter to determines 
	the acceptable tasks for a particular object and the name-value 
	pairs it supports. The command returns information about which
	plug-in tasks are available at the current time and provides
	the information necessary for you to complete the command.
	</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query: objects, object=md/md0, list options</pre></td></tr></table></li><li><p>The command takes the name of the task 
	(returned from the previous query), the object to operate on 
	(in this case, md/md0), any required options (none in this case) 
	and, if necessary, another object to be manipulated 
	(in our example, <tt>sde</tt>, which is the spare disk 
	we want to add):

	</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">task: addspare, md/md0, sde</pre></td></tr></table><p>

	The command is completed upon saving.</p></li></ol></div></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="deleterecurs"></a>Chapter 19. Deleting objects</h2></div></div><p>This chapter tells how to delete EVMS objects through the delete and
delete recursive operations.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="howtodel"></a>19.1. How to delete objects: delete and delete recursive</h2></div></div><p>There are two ways in EVMS that you can destroy objects that you no longer want: Delete and Delete Recursive.  The Delete option destroys only the specific object you specify.  The Delete Recursive option destroys the object you specify and its underlying objects, down to the container, if one exists, or else down to the disk.  In order for an object to be deleted, it must not be mounted.  EVMS verifies that the object you are attempting to delete is not mounted and does not perform the deletion if the object is mounted.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="examdelrecur"></a>19.2. Example: perform a delete recursive operation</h2></div></div><p> The following example shows how to destroy a volume and the objects below it with the EVMS GUI, Ncurses, and CLI interfaces.</p><blockquote class="blockquote"><div class="example"><a name="id2884647"></a><p class="title"><b>Example 19.1. Destroy a volume and the region and container below it</b></p><p>This example uses the delete recursive operation to destroy volume <tt>/dev/evms/Sample Volume</tt> and the region and container below it.  Volume <tt>/dev/evms/Sample Volume</tt> is the volume that was created in earlier.  Although we could also use the delete option on each of the objects, the delete recursive option takes fewer steps.  Note that because we intend to delete the container as well as the volume, the operation needs to be performed in two steps: one to delete the volume and its contents, and one to delete the container and its contents.
</p></div></blockquote><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="mkfsgui"></a>19.2.1. Using the EVMS GUI</h3></div></div><p>Follow these steps to delete the volume and the container with the EVMS GUI:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Delete</b>-&gt;<b>Volume</b>.
	</p></li><li><p>Select volume <b>/dev/evms/Sample Volume</b>
	from the list.
	</p></li><li><p>Click <b>Recursive Delete</b>.  This step deletes the volume 
	and the region <tt>lvm/Sample Container/Sample Region</tt>.  If you want to 
	keep the 
	underlying pieces or want to delete each piece separately, you would click 
	<b>Delete</b> instead of <b>Delete Recursive</b>.
	</p></li><li><p>Assuming you chose Delete Recursive (if not, delete the region before
	continuing with these steps), select <b>Actions</b>-&gt;<b>Delete</b>-&gt;<b>Container</b>.
	</p></li><li><p>Select container <b>lvm/Sample Container</b> from the list.
	</p></li><li><p>Click <b>Recursive Delete</b> to destroy the container and anything
	under it.  Alternatively, click <b>Delete</b> to destroy only the container (if you built the container on
	 disks as in the example, either command has the same effect).
	</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the volume deletion steps with the GUI context
sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Volumes</b> tab, right click 
	<tt>/dev/evms/Sample Volume</tt>.</p></li><li><p>Click <b>Delete...</b></p></li><li><p>Continue with the operation beginning with step 3 of the
	GUI instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="mkfsncurses"></a>19.2.2. Using Ncurses</h3></div></div><p>Follow these steps to delete the volume and the container with Ncurses:

</p><div class="orderedlist"><ol type="1"><li><p>Select <b>Actions</b>-&gt;<b>Delete</b>-&gt;<b>Volume</b>.
	</p></li><li><p>Select volume
	 <b>/dev/evms/Sample Volume</b> from the list.
	</p></li><li><p>Activate 
	<b>Delete Volume Recursively</b>. 
	This step deletes the volume and the region 
	<tt>lvm/Sample Container/Sample Region</tt>.  If you want to keep the 
	underlying pieces or want to delete each piece separately, activate 
	<b>Delete</b> instead of <b>Delete Recursive</b>.
	</p></li><li><p>Assuming you chose <b>Delete Volume Recursively</b> 
	(if not, delete the region before continuing with 
	these steps), select <b>Actions</b>-&gt;<b>Delete</b>-&gt;<b>Container</b>.
	</p></li><li><p>Select container
	<b>lvm/Sample Container</b> from the list.
	</p></li><li><p>Click 
	<b>Recursive Delete</b> to destroy the container and
	everything under it.  Alternatively, activate <b>Delete</b> to delete
	only the container (if you built the container on disks as in the
	example, either command has the same effect).</p></li><li><p>Press <b>Enter</b>.
	</p></li></ol></div><p>
</p><p>Alternatively, you can perform some of the volume deletion steps with the
context sensitive menu:</p><div class="orderedlist"><ol type="1"><li><p>From the Volumes view, press <b>Enter</b> on <b>/dev/evms/Sample Volume</b>.</p></li><li><p>Activate <b>Delete</b>.</p></li><li><p>Continue with the operation beginning with step 3 of the Ncurses instructions.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="deleterecurcli"></a>19.2.3. Using the CLI</h3></div></div><p>Use the
	<b>delete</b> and <b>delete recursive</b> 
	commands to destroy EVMS objects.
	Specify the command name followed by a colon, and then specify the 
	volume, object, or container name.  For example: 

</p><div class="orderedlist"><ol type="1"><li><p>Enter this command to perform the delete recursive 
operation:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">delete recursive: &quot;/dev/evms/Sample Volume&quot;</pre></td></tr></table><p>This step deletes the volume and the region 
<tt>/lvm/Sample Container/Sample Region</tt>.  If you wanted to keep the
underlying pieces or wanted to delete each piece separately, use the <b>delete</b> command, as follows:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">delete: &quot;/dev/evms/Sample Volume&quot;</pre></td></tr></table></li><li><p>Assuming you chose <b>Delete Volume Recursively</b> (if not, delete the region before
continuing with these steps) enter the following to destroy the container and everything under it:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">delete recursive: &quot;lvm/Sample Container&quot;</pre></td></tr></table><p>To destroy only the container, enter the following:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">delete: &quot;lvm/Sample Container&quot;</pre></td></tr></table></li></ol></div><p>
</p></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="evmsreplaceobjects"></a>Chapter 20. Replacing objects</h2></div></div><p>This chapter discusses how to replace objects.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whatisobjectreplace"></a>20.1. What is object-replace?</h2></div></div><p>Occasionally, you might wish to change the configuration of a volume or
storage object.  For instance, you might wish to replace one of the disks in a
drive-link or RAID-0 object with a newer, faster disk.  As another example, you
might have an EVMS volume created from a simple disk segment, and want to
switch that segment for a RAID-1 region to provide extra data redundancy.  
Object-replace accomplishes such tasks.</p><p>
Object-replace gives you the ability to swap one object for another object.
The new object is added while the original object is still in place.  The data is
then copied from the original object to the new object.  When this is complete,
the original object is removed.  This process can be performed while the volume is
mounted and in use.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="replacedlchildobj"></a>20.2. Replacing a drive-link child object</h2></div></div><p>For this example, we will start with a drive-link object named <tt>link1</tt>, 
which is composed of two disk segments named sda1 and sdb1.  The goal is to replace
sdb1 with another segment named sdc1.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The drive-linking plug-in allows the target object (sdc1 in this
example) to be the same size or larger than the source object.
If the target is larger, the extra space will be unused.  Other plug-ins
have different restrictions and might require that both objects be the 
same size.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guiobjectreplace"></a>20.2.1. Using the EVMS GUI or Ncurses</h3></div></div><p>Follow these steps to replace sdb1 with sdc1:
	</p><div class="orderedlist"><ol type="1"><li><p>Select
		<b>Actions</b>-&gt;<b>Replace.</b>
		</p></li><li><p>In the &quot;Replace Source Object&quot; panel select
		<b>sdb1</b>.
		</p></li><li><p>Activate <b>Next</b>.</p></li><li><p>In the &quot;Select Replace Target Object&quot; panel, select 
		<b>sdc1</b>. 			</p></li><li><p>Activate <b>Replace</b>.</p></li></ol></div><p>Alternatively, you can perform these same steps with the
context sensitive menus:</p><div class="orderedlist"><ol type="1"><li><p>From the &quot;Disk Segments&quot; panel, right click (or Press
	<b>Enter</b> on) the object 
	<b>sdb1</b>.</p></li><li><p>Choose <b>Replace</b> on the popup menu.</p></li><li><p>In the &quot;Select Replace Target Object&quot; panel, select
	<b>sdc1.</b></p></li><li><p>Activate <b>Replace</b>.</p></li></ol></div><p>When you save changes, EVMS begins to copy the data from sdb1 to sdc1.
The status bar at the bottom of the UI will reflect the percent-complete of the
copy operation.  The UI must remain open until the copy is finished.  At that time,
the object sdb1 will be moved to the &quot;Available Objects&quot; panel.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="clireplace"></a>20.2.2. Using the CLI</h3></div></div><p>The replace command has not yet been implemented in the EVMS CLI.  
It will be available in a future release.</p></div></div></div><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="segstorobjs"></a>Chapter 21. Moving segment storage objects</h2></div></div><p>This chapter discusses how and why to move segments.
</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whatissegmove"></a>21.1. What is segment moving?</h2></div></div><p>A segment move is when a data segment is relocated to another
location on the underlying storage object.  The new location of
the segment cannot overlap with the current segment location.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="whymove"></a>21.2. Why move a segment?</h2></div></div><p>
Segments are moved for a variety of reasons.  The most compelling among
them is to make better use of disk freespace.  Disk freespace is an unused
contiguous extent of sectors on a disk that has been identified by EVMS
as a freespace segment.  A data segment can only be expanded by adding
sectors to the end of the segment, moving the end of the data segment
up into the freespace that immediately follows the data segment.  However,
what if there is no freespace following the data segment?  A segment or
segments could
be be moved around to put freespace after the segment that is to be
expanded.  For example:
</p><div class="itemizedlist"><ul type="disc"><li><p>The segment following the segment to be expanded can be moved
elsewhere on the disk, thus freeing up space after the segment that
is to be expanded.</p></li><li><p>The segment to be expanded can be moved into freespace where
there is more room for the segment to be expanded.
</p></li><li><p>The segment can be moved into freespace that precedes the
segment so that after the move the data segment can be expanded into the freespace
created by the move.</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2885910"></a>21.3. Which segment manager plug-ins implement the move function?</h2></div></div><p>The following segment manager plug-ins support the move function:
</p><div class="itemizedlist"><ul type="disc"><li><p>
DOS
</p></li><li><p>
s390
</p></li><li><p>
GPT
</p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="movesegex"></a>21.4. Example: move a DOS segment</h2></div></div><p> This section shows how to move a DOS segment:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
In the following example, the DOS segment manager has a single
primary partition on disk sda that is located at the very end of the disk.
We want to move it to the front of the drive because we want to expand
the segment but there is currently no freespace following the segment.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="guimoveseg"></a>21.4.1. Using the EVMS GUI context sensitive menu</h3></div></div><p>To move the DOS segment through the GUI context sensitive menu,
follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>From the <b>Segments</b> 
		tab, right click
		<tt>sda1</tt>.
		</p></li><li><p>Click <b>Move</b>.</p></li><li><p>Select <tt>sda_freespace1</tt>.
		</p></li><li><p>Click <b>Move</b>.</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="ncursmoveseg"></a>21.4.2. Using Ncurses</h3></div></div><p>To move the DOS segment, follow these steps:</p><div class="orderedlist"><ol type="1"><li><p>Use <b>Tab</b> 
		 to select the Disk Segments view.
		</p></li><li><p>Scroll down with the down arrow and
		select <tt>sda1</tt>.</p></li><li><p>Press 
		<b>Enter</b>.</p></li><li><p>Scroll down with the down arrow and
		select <b>Move</b> by pressing
		<b>Enter</b>.</p></li><li><p>Use the spacebar to select
		<tt>sda_freespace1</tt>.</p></li><li><p>Use <b>Tab</b> 
		 to select <b>Move</b> and press
		<b>Enter</b>.
		</p></li></ol></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="clisegmove"></a>21.4.3. Using the CLI</h3></div></div><p>Use the
	<b>task</b> command to move a DOS segment with the CLI.  
</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">task:Move,sda1,sda_freespace1</pre></td></tr></table></div></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="appxdos"></a>Appendix A. The DOS plug-in</h2></div></div><p>The DOS plug-in is the most commonly used EVMS segment manager
plug-in.  The DOS plug-in supports DOS disk partitioning as well as:</p><div class="itemizedlist"><ul type="disc"><li><p>OS/2 partitions that require extra metadata sectors.</p></li><li><p>Embedded partition tables: SolarisX86, BSD, and UnixWare.</p></li></ul></div><p>The DOS plug-in reads metadata and constructs segment storage
objects that provide mappings to disk partitions.
</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="DOShow"></a>A.1. How the DOS plug-in is implemented</h2></div></div><p>The DOS plug-in provides compatibility with DOS partition tables.
The plug-in produces EVMS segment storage objects that map primary partitions
described by the MBR partition table and logical partitions
described by EBR partition tables.
</p><p>DOS partitions have names that are constructed from two pieces
of information:</p><div class="itemizedlist"><ul type="disc"><li><p>The device they are found on.</p></li><li><p>The partition table entry that provided the information.</p></li></ul></div><p>Take, for example, partition name <tt>hda1</tt>, which 
describes a partition that is found on device <tt>hda</tt> 
in the MBR partition table.
DOS partition tables can hold four entries.
Partition numbers 1-4 refer to MBR partition records.  Therefore, our
example is telling us that partition <tt>hda1</tt> is described
by the very first partition record entry in the MBR partition table.
Logical partitions, however, are different than primary partitions.
EBR partition tables are scattered across a disk but are linked together
in a chain that is first located using an extended partition record found
in the MBR partition table.
Each EBR partition table contains a partition record that describes a logical
partition on the disk.
The name of the logical partition reflects its position in the EBR chain.
Because the MBR partition table reserves numerical names 1-4, the very
first logical partition is always named 5.
The next logical partition, found by following the EBR chain, is called 6,
and so forth.
So, the partition <tt>hda5</tt> is a logical partition that is
described by a partition record in the very first EBR partition table.
</p><p>While discovering DOS partitions, the DOS plug-in also looks for
OS/2 DLAT metadata to further determine if the disk is an OS/2 disk.
An OS/2 disk has additional metadata and the metadata is validated during
recovery.
This information is important for the DOS plug-in to know because an OS/2 
disk must maintain additional partition information.  (This is why the 
DOS plug-in asks, when being assigned to a disk, if the disk is a
Linux disk or an OS/2 disk.)  The DOS plug-in needs to know how much
information must be kept on the disk and what kind of questions it should
ask the user when obtaining the information.
</p><p>
An OS/2 disk can contain compatibility volumes as well as logical volumes.
A compatibility volume is a single partition with an assigned drive
letter that can be mounted.  An OS/2 logical volume is a drive link of 1
or more partitions that have software bad-block relocation at the
partition level.
</p><p>
Embedded partitions, like those found on a SolarisX86 disk or a BSD
compatibility disk, are found within a primary partition.
Therefore, the DOS plug-in inspects primary partitions that it has
just discovered to further determine if any embedded partitions exist.
Primary partitions that hold embedded partition tables have partition
type fields that indicate this. 
For example, a primary partition of type 0xA9 probably has a BSD partition
table that subdivides the primary partition into BSD partitions.
The DOS plug-in looks for a BSD disk label and BSD data partitions in the
primary partition.
If the DOS plug-in finds a BSD disk label, it exports the BSD partitions.  Because
this primary partition is actually just a container that holds the BSD
partitions, and not a data partition itself, it is not exported by the
DOS plug-in.
Embedded partitions are named after the primary partition they were
discovered within.  As an example, <tt>hda3.1</tt> is
the name of the first embedded partition found within primary partition
<tt>hda3</tt>.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="assignDOS"></a>A.2. Assigning the DOS plug-in</h2></div></div><p>
Assigning a segment manager to a disk means that you want the plug-in
to manage partitions on the disk.
In order to assign a segment manager to a disk, the plug-in needs to 
create and maintain the appropriate metadata, which is accomplished
through the &quot;disk type&quot; option.
When you specify the &quot;disk type&quot; option and choose
Linux or OS/2, the plug-in knows what sort of metadata it needs to keep
and what sort of questions it should ask when creating partitions.
</p><p>
An additional OS/2 option is the &quot;disk name&quot; option, by which you can 
provide a name for the disk that will be saved in OS/2 metadata and that
will be persistent across reboots.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="creatingDOS"></a>A.3. Creating DOS partitions</h2></div></div><p>
There are two basic DOS partition types:</p><div class="orderedlist"><ol type="1"><li><p>A primary partition, which is described by a partition record
in the MBR partition table.</p></li><li><p>A logical partition, which is described by a partition record
in the EBR partition table.</p></li></ol></div><p>Every partition table has room for four partition records; however,
there are a few rules that impose limits on this.
</p><p>
An MBR partition table can hold four primary partition records unless you
also have logical partitions.
In this case, one partition record is used to describe an extended
partition and the start of the EBR chain that in turn describes
logical partitions.
</p><p>
Because all logical partitions must reside in the extended partition, you
cannot allocate room for a primary partition within the extended partition 
and you
cannot allocate room for a logical partition outside or adjacent to this area.
</p><p>
Lastly, an EBR partition table performs two functions:</p><div class="orderedlist"><ol type="1"><li><p>It describes a logical partition and therefore uses a partition
record for this purpose.</p></li><li><p>It uses a partition record to locate the next EBR partition table.</p></li></ol></div><p>
EBR partition tables use at most two entries.</p><p>
When creating a DOS partition, the options you are presented with depend
on the kind of disk you are working with.  However, both OS/2 disks and
Linux disks require that you choose a freespace segment on the disk
within which to create the new data segment.  The create options are:</p><div class="variablelist"><dl><dt><b>size</b></dt><dd><p>The size of the partition you are creating.
Any adjustments that are needed for alignment are performed by the
DOS plug-in and the resulting size might differ slightly from the
value you enter.
</p></dd><dt><b>offset</b></dt><dd><p>Lets you skip sectors and
start the new partition within the freespace area by specifying a
sector offset.
</p></dd><dt><b>type</b></dt><dd><p>Lets you enter a partition type or choose from a list of
partition types; for example, native Linux.
</p></dd><dt><b>primary</b></dt><dd><p>Lets you  choose between creating a primary or logical partition.
Due to the rules outlined above, you might or might not have a choice.
The DOS plug-in can determine if a primary or logical partition can be
created in the freespace area you chose and disable this choice.
</p></dd><dt><b>bootable</b></dt><dd><p>Lets you  enable the sys_ind flag field in a primary partition
and disable it when creating a logical partition.
The sys_ind flag field identifies the active primary partition for booting.
</p></dd></dl></div><p>
Additional OS/2 options are the following:</p><div class="variablelist"><dl><dt><b>partition name</b></dt><dd><p>
An OS/2 partition can have a name, like Fred or Part1.
</p></dd><dt><b>volume name</b></dt><dd><p>
OS/2 partitions belong to volumes, either
compatibility or logical, and volumes have names.  However, because
the DOS plug-in is not a logical volume manager, it cannot actually
create OS/2 logical volumes.
</p></dd><dt><b>drive letter</b></dt><dd><p>You can specify the drive letter for an OS/2 partition, but it
is not a required field.  Valid drive letters are: C,D...Z.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="expandDOS"></a>A.4. Expanding DOS partitions</h2></div></div><p>
A partition is a physically contiguous run of sectors on a disk.
You can expand a partition by adding unallocated sectors to the initial
run of sectors on the disk.  Because the partition must remain physically
contiguous, a partition can only be expanded by growing into an unused
area on the disk.
These unused areas are exposed by the DOS plug-in as freespace segments.
Therefore, a data segment is only expandable if a freespace segment
immediately follows it.  Lastly, because a DOS partition must end on a
cylinder boundary, DOS segments are expanded in
cylinder size increments.  This means that if the DOS segment you want
to expand is followed by a freespace segment, you might be unable to
expand the DOS segment if the freespace segment is less than a cylinder
in size.
</p><p>
There is one expand option, as follows:</p><div class="variablelist"><dl><dt><b>size</b></dt><dd><p>
This is the amount by which you want to expand the data segment.  The amount must
be a multiple of the disk's cylinder size.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="shrinkDOS"></a>A.5. Shrinking DOS partitions</h2></div></div><p>
A partition is shrunk when sectors are removed from the end of the
partition.
Because a partition must end on a cylinder boundary, a partition is
shrunk by removing cylinder amounts from the end of the segment.</p><p>
There is one shrink option, as follows:</p><div class="variablelist"><dl><dt><b>size</b></dt><dd><p>The amount by which you want to reduce the size of the segment.
Because a segment ends on a cylinder boundary, this value must be
some multiple of the disk's cylinder size.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="deleteDOS"></a>A.6. Deleting partitions</h2></div></div><p>You can delete an existing DOS data segment as long as it is not
currently a compatibility volume, an EVMS volume, or consumed by another
EVMS plug-in.
No options are available for deleting partitions.
</p></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="appxmdreg"></a>Appendix B. The MD region manager</h2></div></div><p>
Multiple disks (MD) support in Linux is a software implementation of RAID
(Redundant Array of Independent Disks).  The basic idea of software RAID
is to combine multiple inexpensive hard disks into an array of disks to
obtain performance, capacity, and reliability that exceeds that of a single
large disk.
</p><p>
Linux software RAID works on most block devices.  A Linux RAID device
can be composed of a mixture of IDE or SCSI devices.  Furthermore,
because a Linux RAID device is itself a block device, it can be a 
member of another Linux RAID device.
</p><p>
Whereas there are six standard types of RAID arrays (RAID-0 through RAID-5) in the hardware implementation, the Linux implementation of software
RAID has RAID-0, RAID-1, RAID-4, and RAID-5 levels.  In addition to these
four levels, Linux also has support for other non-redundant arrays called
&quot;Linear Mode&quot; and &quot;MULTIPATH.&quot;
</p><p>
All levels of Linux software RAID are discussed in greater detail in the
Software RAID HOWTO of The Linux Documentation Project 
(<a href="www.tldp.org" target="_top">TLDP</a>).  
One important thing to remember is RAID is not a substitute for backups.
</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="createmdreg"></a>B.1. Creating an MD region</h2></div></div><p>There are four EVMS MD region plug-ins: Linear, RAID-0, RAID-1,
and RAID-4/5.  The RAID-4/5 region plug-in provides support for both
RAID-4 and RAID-5 arrays.  After an MD region manager is selected, the software
provides a 
list of acceptable objects.  The ordering of the MD array is
implied by the order in which you pick objects from the provided list.  The
following are MD region configuration options:
</p><div class="variablelist"><dl><dt><b>chunk size</b></dt><dd><p>The smallest chunk size is 4 KB and the largest is 4096 KB.  The
chunk size is a power of 2 of the previous value.  Consider the intended use of the
MD region when selecting chunk size.  For example,
if the MD region contains mostly large files, you might see better performance
by having a larger chunk size.  The block size of the file system being used is
also an important factor when selecting chunk size.</p><p>This option is available for use with RAID-0 and RAID-4/5.</p></dd><dt><b>spare disk</b></dt><dd><p>The benefit of having a spare disk is that when an active disk fails,
the kernel MD code automatically replaces the failed disk with the spare disk.
Otherwise, the MD array operates in a degraded mode.</p><p>This option is available for use with RAID-1 and RAID-4/5.</p></dd><dt><b>RAID-5 algorithms</b></dt><dd><p>There are four RAID-5 parity algorithms: left asymmetric, right
asymmetric, left symmetric, and right symmetric.  The <a href="http://www.accs.com/p_and_p/RAID/LinuxRAID.html" target="_top">ACCS</a> web
page provides examples of what the different parity algorithms do.</p><p>This option is available for use with the RAID-5 algorithm.</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="addremspare"></a>B.2. Adding and removing a spare object (RAID-1 and RAID-4/5)</h2></div></div><p>When adding a spare disk to an existing MD region, select an available object
that has the same size as the disks that are currently active in the MD region.
If the MD region consists of objects with different sizes, use the smallest size.</p><p>Note that after adding a spare to a degraded MD region, the kernel MD code
automatically starts the reconstruction of the MD array.  When reconstruction finishes,
the spare disks becomes an active disk.</p><p>If you want to reorganize disks and segments, you can remove an existing
spare disk from the MD region.  This is a safe operation because the spare disk does
not contain any data.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="rmactiveraid"></a>B.3. Reconfiguring MD arrays</h2></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2887479"></a>B.3.1. Expanding and shrinking MD arrays (linear and RAID-1)</h3></div></div><p>If the MD region is part of a compatibility volume and the MD region is
the topmost object of the volume, it's possible to expand and shrink the MD region.</p><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2887493"></a>B.3.1.1. Expanding a linear MD region</h4></div></div><p>A linear MD region can be expanded either by expanding the last member
or by adding a new member.</p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2887506"></a>B.3.1.2. Shrinking a linear MD region</h4></div></div><p>A linear MD region can be shrunk either by shrinking the last member
or by removing disks from the array (last member first).</p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2887520"></a>B.3.1.3. Expanding a RAID-1 MD region</h4></div></div><p>A RAID-1 MD region can only be expanded if all members can be expanded.</p></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2887532"></a>B.3.1.4. Shrinking a RAID-1 MD region</h4></div></div><p>A RAID-1 MD region can only be shrunk if all members can be shrunk.</p></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2887546"></a>B.3.2. Adding an active object (RAID-1 only)</h3></div></div><p>Use this option to increase the number of mirrors of the RAID-1 region, from
n-way mirrors to (n+1)-way mirrors.  When the operation is committed, the
kernel MD driver performs a resync of the MD array.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2887562"></a>B.3.3. Removing an active object (RAID-1 only)</h3></div></div><p>Use this option to decrease the number of mirrors of the RAID-1 region, from
n-way mirrors to (n-1)-way mirrors.  </p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="rmfaultyobj"></a>B.4. Removing a faulty object (RAID-1 and RAID-4/5)</h2></div></div><p>When an I/O error occurs on a disk, the disk is marked faulty by the kernel
MD driver.  Use this function to permanently remove the faulty disk from the MD region.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="markobjfaulty"></a>B.5. Marking an object faulty (RAID-1 and RAID-4/5)</h2></div></div><p>There are two scenarios for marking an active disk faulty:</p><div class="itemizedlist"><ul type="disc"><li><p>When the MD region has at least one spare disk, the active disk will
be swapped with a spare disk.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>When the MD region has no spare disks, the active disk will be marked
faulty and the MD array will operate in degraded mode.</p></li></ul></div><p>When the active disk is successfully marked
faulty, it can be immediately removed from the MD region.  Alternatively, the
faulty disk can be later removed, as described in <a href="#rmfaultyobj" title="B.4. Removing a faulty object (RAID-1 and RAID-4/5)">Section B.4, &quot;Removing a faulty object (RAID-1 and RAID-4/5)&quot;</a>.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="replaceobj"></a>B.6. Replacing an object</h2></div></div><p>In EVMS 2.0 and later, you can replace a member of an MD region with an 
available storage object.  The new object must be the same size as the replaced object.
This option is currently only supported for volumes that are offline.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="characsraid"></a>B.7. Characteristics of Linux RAID levels</h2></div></div><p>The following subsections describe the characteristics of each Linux RAID level.</p><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2887686"></a>B.7.1. Linear mode</h3></div></div><p>Characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>
Two or more disks are combined into one virtual MD device.</p></li><li><p>
The disks are appended to each other, so writing linearly to the MD device
fills up disk 0 first, then 1, and so on.</p></li><li><p>
The disks do not have to be of the same size.</p></li></ul></div><p>Advantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
Can be used to build a very large MD device.
</p></li><li><p>
No parity calculation overhead is involved.
</p></li></ul></div><p>Disadvantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
Not a &quot;true&quot; RAID because it is not fault-tolerant.
</p></li><li><p>
One disk crash will probably result in loss of most or all data.
</p></li><li><p>
Should never be used in mission-critical environments.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2887794"></a>B.7.2. RAID-0</h3></div></div><p>Characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>
Two or more disks are combined into one virtual MD device.</p></li><li><p>
Also called &quot;stripe&quot; mode.
</p></li><li><p>
Stripe size determines how data is written to disk.  For example,
writing 16 K bytes to a RAID-0 array of three disks with stripe size
of 4 K bytes is broken down into:</p><div class="itemizedlist"><ul type="circle"><li><p>
4 K bytes of disk 0
</p></li><li><p>
4 K bytes to disk 1
</p></li><li><p>
4 K bytes to disk 2
</p></li><li><p>
4 K bytes to disk 0
</p></li></ul></div></li><li><p>
The disks should be the same size but they do not have to be the same size.
</p></li></ul></div><p>Advantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
Can be used to build a very large MD device.
</p></li><li><p>
I/O performance is greatly improved by spreading I/O load across many
controllers and disks.
</p></li><li><p>
No parity calculation overhead is involved.
</p></li></ul></div><p>Disadvantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
Not a &quot;true&quot; RAID because it is not fault-tolerant.
</p></li><li><p>
One disk crash is liable to result in the loss of the whole array.
</p></li><li><p>
Should never be used in mission-critical environments.</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2887960"></a>B.7.3. RAID-1</h3></div></div><p>Characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>
Consists of two or more disks to provide a two-way or N-way mirrored MD device.
</p></li><li><p>
Writes result in writing identical data to all active disks in the array.
</p></li><li><p>
Reads can be performed on any active disk of the array.
</p></li><li><p>
Data is intact as long as there is at least one &quot;good&quot; active disk in the array.
</p></li><li><p>
The disks should be the same size.  If they are different sizes, the size
of the RAID-1 array is determined by the smallest disk.
</p></li></ul></div><p>Advantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
100% redundancy of data.
</p></li><li><p>
Under certain circumstances, a RAID-1 array can sustain multiple simultaneous
disk failures.
</p></li><li><p>
Kernel MD code provides good read-balancing algorithm.
</p></li><li><p>
No parity calculation overhead is involved.
</p></li></ul></div><p>Disadvantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
Write performance is often worse than on a single device.
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888088"></a>B.7.4. RAID-4</h3></div></div><p>Characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>
Consists of three or more striped disks.
</p></li><li><p>
Parity information is kept on one disk.  When a disk fails, parity information
is used to reconstruct all data.
</p></li><li><p>
The disks should be the same size.  If they are different sizes, the size of
the RAID-4 array is determined by the smallest disk.
</p></li></ul></div><p>Advantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
Like RAID-0, I/O performance is greatly improved by spreading the I/O load
across many controllers and disks.
</p></li></ul></div><p>Disadvantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
The parity disk becomes a bottleneck.  Therefore, a slow parity disk degrades
I/O performance of the whole array.
</p></li><li><p>
Cannot sustain a two-disk simultaneous failure.
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888181"></a>B.7.5. RAID-5</h3></div></div><p>Characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>
Consists of three or more striped disks.
</p></li><li><p>
Parity information is distributed evenly among the participating disks.
</p></li><li><p>
The disks should be the same size.  If they are different sizes, the size of
the RAID-5 array is determined by the smallest disk.
</p></li></ul></div><p>Advantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
Like RAID-0, I/O performance is greatly improved by spreading the I/O load
across many controllers and disks.
</p></li><li><p>
Read performance is similar to RAID-0.
</p></li></ul></div><p>Disadvantages:</p><div class="itemizedlist"><ul type="disc"><li><p>
Writes can be expensive when required read-in blocks for parity calculations
are not in the cache.
</p></li><li><p>
Cannot sustain a two-disk simultaneous failure.
</p></li></ul></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888281"></a>B.7.6. MULTIPATH</h3></div></div><p>Characteristics:</p><div class="itemizedlist"><ul type="disc"><li><p>Consists of 1 or more disks.</p></li><li><p>Disks are actually I/O paths to the same physical disk.</p></li><li><p>Spreads I/O across active disks for simple load balancing.</p></li><li><p>Like other RAID levels, I/O failures will mark a disk faulty.</p></li><li><p>Failed I/O will be automatically retried on remaining active disks.</p></li></ul></div><p>Advantages:</p><div class="itemizedlist"><ul type="disc"><li><p>Achieves fault-tolerance through redundant I/O paths.</p></li><li><p>Possible performance improvements through load balancing.</p></li></ul></div><p>Disadvantages:</p><div class="itemizedlist"><ul type="disc"><li><p>Cannot survive a single disk crash.</p></li></ul></div></div></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="appxsnap"></a>Appendix C. The LVM plug-in</h2></div></div><p>The LVM plug-in combines storage objects into groups called containers.
From these containers, new storage objects can be created, with a variety of
mappings to the consumed objects.  Containers allow the storage capacity of
several objects to be combined, allow additional storage to be added in the future,
and allow for easy resizing of the produced objects.</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="lvmimp"></a>C.1. How LVM is implemented</h2></div></div><p>The Linux LVM plug-in is compatible with volumes and volume groups from
the original Linux LVM tools from Sistina Software.  The original LVM is based on the
concept of volume groups.  A volume group (VG) is a grouping of physical volumes 
(PVs), which are usually disks or disk partitions.  The volume group is not directly
usable as storage space; instead, it represents a pool of available storage.
You create logical volumes (LVs) to use this storage.  The storage space of the LV can 
map to one or more of the group's PVs.</p><p>The Linux LVM concepts are represented by similar concepts in the EVMS LVM plug-in.
A volume group is called a container, and the logical volumes that are produced are
called regions.  The physical volumes can be disks, segments, or other regions.
Just as in the original LVM, regions can map to the consumed objects in a variety of ways.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="containerops"></a>C.2. Container operations</h2></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="createlvmconts"></a>C.2.1. Creating LVM containers</h3></div></div><p>Containers are created with an initial set of objects.  In the LVM plug-in, the
objects can be disks, segments, or regions.  LVM has two options for creating containers.
The value of these options cannot be changed after the container has been created.  The
options are:</p><div class="variablelist"><dl><dt><b>name</b></dt><dd><p>The name of the new container.</p></dd><dt><b>pe_size</b></dt><dd><p>The physical extent (PE) size, which is the granularity with which regions can be created.  The default is 16 MB.  Each region must have a whole number of extents.  
Also, each region can have only up to 65534 extents.  Thus, the PE size for the container
limits the maximum size of a region in that container.  With the default PE size, an LVM
region can be, at most 1 TB.  In addition, each object consumed by the container must
be big enough to hold at least five extents.  Thus, the PE size cannot be arbitrarily large.  Choose wisely.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2887328"></a>C.2.2. Adding objects to LVM containers</h3></div></div><p>You can add objects to existing LVM containers in order to increase the pool of
storage that is available for creating regions.  A single container can consume up to 256
objects.  Because the name and PE size of the containers are set when the container is
created, no options are available when you add new objects to a container.  Each object
must be large enough to hold five physical extents.  If an object is not large enough to
satisfy this requirement, the LVM plug-in will not allow the object to be added to the container.
</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2887424"></a>C.2.3. Removing objects from LVM containers</h3></div></div><p>You can remove a consumed object from its container as long as no regions
are mapped to that object.  The LVM plug-in does not allow objects that are in use to
be removed their their container.  If an object must be removed, you can delete or
shrink regions, or move extents, in order to free the object from use.</p><p>No options are available for removing objects from LVM containers.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888540"></a>C.2.4. Deleting LVM containers</h3></div></div><p>You can delete a container as long as the container does not have any produced
regions.  The LVM plug-in does not allow containers to be deleted if they have any
regions.  No options are available for deleting LVM containers.</p></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2888557"></a>C.3. Region operations</h2></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888563"></a>C.3.1. Creating LVM regions</h3></div></div><p>You create LVM regions from the freespace in LVM containers.  If there is at least
one extent of freespace in the container, you can create a new region.</p><p>The following options are available for creating LVM regions:</p><div class="variablelist"><dl><dt><b>name</b></dt><dd><p>The name of the new region.</p></dd><dt><b>extents</b></dt><dd><p>The number of extents to allocate to the new region.  A new region must
have at least one extent and no more than the total available free extents in the container,
or 65534 (whichever is smaller).  If you use the <tt>extents</tt> option, the appropriate value
for the size option is automatically calculated.  By default, a new region uses all
available extents in the container.</p></dd><dt><b>size</b></dt><dd><p>The size of the new region.  This size must be a multiple of the
container's PE size.  If you use the <tt>size</tt> option, the appropriate value for the
extents options is automatically calculated.  By default, a new region uses all
available freespace in the container.</p></dd><dt><b>stripes</b></dt><dd><p>If the container consumes two or more objects, and each object has
unallocated extents, then the new region can be striped across multiple objects.
This is similar to RAID-0 striping and achieves an increased amount of I/O
throughput across multiple objects.  This option specifies how many objects the
new region should be striped across.  By default, new regions are not striped, and
this value is set to 1.</p></dd><dt><b>stripe_size</b></dt><dd><p>The granularity of striping.  The default value is 16 KB.  Use this option
only if the <tt>stripes</tt> option is greater than 1.</p></dd><dt><b>contiguous</b></dt><dd><p>This option specifies that the new region must be allocated on a single
object, and that the extents on that object must be physically contiguous.  By default,
this is set to false, which allows regions to span objects.  This option cannot be used
if the <tt>stripes</tt> option is greater than 1.</p></dd><dt><b>pv_names</b></dt><dd><p>A list of names of the objects the new region should map to.  By default,
this list is empty, which means all available objects will be used to allocate space
to the new region.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888738"></a>C.3.2. Expanding LVM regions</h3></div></div><p>You can expand an existing LVM region if there are unused extents in the
container.  If a region is striped, you can expand it only by using free space on
the objects it is striped across.  If a region was created with the contiguous option,
you can only expand it if there is physically contiguous space following the
currently allocated space.</p><p>The following options are available for expanding LVM regions:</p><div class="variablelist"><dl><dt><b>add_extents</b></dt><dd><p>The number of extents to add to the region.  If you specify this
option, the appropriate value for the add_size option is automatically
calculated.  By default, the region will expand to use all free extents in the
container.</p></dd><dt><b>add_size</b></dt><dd><p>The amount of space to add to the region.  If you specify this option,
the appropriate value for the add_extents option is automatically calculated.
By default, the region will expand to use all freespace in the container.</p></dd><dt><b>pv_names</b></dt><dd><p>A list of names of the objects to allocate the additional space from.
By default,  this list is empty, which means all available objects will be used to
allocate new space to the region.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888815"></a>C.3.3. Shrinking LVM regions</h3></div></div><p>You can shrink an existing LVM region by removing extents from the end of the
region.  Regions must have at least one extent, so regions cannot be shrunk to zero.</p><p>The following options are available when shrinking LVM regions.  Because regions
are always shrunk by removing space from the end of the region, a list of objects
cannot be specified in this command.</p><div class="variablelist"><dl><dt><b>remove_extents</b></dt><dd><p>The number of extents to remove from the region.  If you specify this option,
the appropriate value for the <tt>remove_size</tt> option is automatically calculated.  By
default, one extent is removed from the region.</p></dd><dt><b>remove_size</b></dt><dd><p>The amount of space to shrink the region by.  If you specify this option,
the appropriate value for the <tt>remove_extents</tt> option is automatically calculated.</p></dd></dl></div></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888887"></a>C.3.4. Deleting LVM regions</h3></div></div><p>You can delete an existing LVM region as long as it is not currently a 
compatibility volume, an EVMS volume, or consumed by another EVMS plug-in.
No options are available for deleting LVM regions.</p></div><div class="sect2"><div class="titlepage"><div><h3 class="title"><a name="id2888902"></a>C.3.5. Moving LVM regions</h3></div></div><p>The LVM plug-in lets you change the logical-to-physical mapping
for an LVM region and move the necessary data in the process.
This capability is most useful if a PV needs to be removed from a container.
There are currently two LVM plug-in functions for moving regions: 
<b>move_pv</b> and <b>move_extent</b>.</p><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2888931"></a>C.3.5.1. move_pv</h4></div></div><p>When a PV needs to be removed from a container, all PEs on that PV that are
allocated to regions must be moved to other PVs.  The <b>move_pv</b> command lets you move PEs to other PVs. 
<b>move_pv</b> is targeted at the LVM container and the desired PV is used as 
the selected object.  The following options are available:</p><div class="variablelist"><dl><dt><b>target_pvs</b></dt><dd><p>By default, all remaining PVs in the container are used to find
available extents to move the PEs.  You can specify a subset of the PVs with this option.</p></dd><dt><b>maintain_stripes</b></dt><dd><p>When the target PV contains striped regions, there are three choices
for handling moving extents that belong to those regions:</p><div class="variablelist"><dl><dt><b>no</b></dt><dd><p>Don't bother to maintain true striping.  This choice allows
extents to be moved to PVs that the region already uses for other stripes.
This means that the performance will not be as optimal as it is with true
striping, but allows the most flexibility in performing the move operation.
This choice is the default for the <b>maintain_stripes</b> option.</p></dd><dt><b>loose</b></dt><dd><p>Ensure that moved extents do not end up on any PVs that the
striped region already uses.  However, this does not ensure that all moved
extents end up on the same PV.  For example, a region with three stripes may
end up mapping to four or more PVs.</p></dd><dt><b>strict</b></dt><dd><p>Ensure that all moved extents end up on the same PV, thus ensuring
true striping with the same number of PVs that the striped region originally used.
This is the most restricted choice, and may prevent the <b>move_pv</b> operation from
proceeding (depending on the particular configuration of the container).</p></dd></dl></div><p>If the target PV has no striped regions, the <b>maintain_stripes</b> option is ignored.</p></dd></dl></div></div><div class="sect3"><div class="titlepage"><div><h4 class="title"><a name="id2889089"></a>C.3.5.2. move_extent</h4></div></div><p>In addition to moving all the extents from one PV, the LVM plug-in provides
the ability to move single extents.
This allows a fine-grain tuning of the allocation of extents.
This command is targeted at the region owning the extent to move.  There are
three required options for the <b>move_extent</b> command:</p><div class="variablelist"><dl><dt><b>le</b></dt><dd><p>The number of the logical extent to move.  LE numbers start at 0.</p></dd><dt><b>pv</b></dt><dd><p>The target object to move the extent to.</p></dd><dt><b>pe</b></dt><dd><p>The target physical extent on the target object.  PE numbers
also start at 0.</p></dd></dl></div><p>To determine the source LE and target PE, it is often helpful to view the
extended information about the region and container in question.
The following are command-line options that can be used to gather this
information:</p><p>To view the map of LEs in the region, enter this command:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query:ei,&lt;region_name&gt;,Extents</pre></td></tr></table><p>To view the list of PVs in the container, enter this command:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query:ei,&lt;container_name&gt;,Current_PVs</pre></td></tr></table><p>To view the current PE map for the desired target PV, enter this command:</p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">query:ei,&lt;container_name&gt;,PEMapPV#</pre></td></tr></table><p># is the number of the target PV in the container.</p><p>This information is also easily obtainable in the GUI and Text-Mode UIs by
using the &quot;Display Details&quot; item in the context-popup menus for the desired
region and container.</p></div></div></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="appxcsm"></a>Appendix D. The CSM plug-in</h2></div></div><p>The Cluster Segment Manager (CSM) is the EVMS plug-in that identifies and
manages cluster storage.  The CSM protects disk storage objects by writing metadata
at the start and end of the disk, which prevents other plug-ins from attempting to use the disk.
Other plug-ins can look at the disk, but they cannot see their own metadata signatures
and cannot consume the disk.  The protection that CSM provides allows the CSM to
discover cluster storage and present it in an appropriate fashion to the system. </p><p>All cluster storage disk objects must be placed in containers that have the
following attributes:</p><div class="itemizedlist"><ul type="disc"><li><p>cluster ID that identifies the cluster management software
</p></li><li><p>node ID that identifies the owner of the disk objects
</p></li><li><p>storage type: private, shared, or deported
</p></li></ul></div><p>
The CSM plug-in reads metadata and constructs containers that consume
the disk object.  Each disk provides a usable area, mapped as an EVMS
data segment, but only if the disk is accessible to the node viewing
the storage.</p><p>The CSM plug-in performs these operations:
</p><div class="itemizedlist"><ul type="disc"><li><p>
examines disk objects
</p></li><li><p>
creates containers
</p></li><li><p>
uses the containers to consume disk objects
</p></li><li><p>
produces data segment objects if the disk is accessible to the node
</p></li></ul></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="csmassn"></a>D.1. Assigning the CSM plug-in</h2></div></div><p>Assigning a segment manager to a disk means that you want the plug-in to
manage partitions on the disk.  In order to do this, the plug-in needs to create and
maintain appropriate metadata.  The CSM creates the follow three segments on the disk:</p><div class="itemizedlist"><ul type="disc"><li><p>primary metadata segment</p></li><li><p>usable area data segment</p></li><li><p>secondary metadata segment</p></li></ul></div><p>The CSM collects the information it needs to perform the assign operation with the
following options:</p><div class="variablelist"><dl><dt><b>NodeId</b></dt><dd><p>Choose only from a list of configured node IDs that have been
provided to the CSM by clustering software.  The default selection is the
node from which you are running the EVMS user interface.</p></dd><dt><b>Container Name</b></dt><dd><p>The name for the container.  Currently, you need to keep this name unique
across the cluster to prevent name-in-conflict errors should the container fail over to
another node that has a container with the same name.  Later releases of EVMS will assist 
you with this. </p></dd><dt><b>Storage Type</b></dt><dd><p>Can be either: share, private, or deported. </p></dd></dl></div><p>Note that you would typically assign the CSM to a disk when you want to
add a disk to an existing CSM container.  If you are creating a new container, you
have a choice of using either:
<b>Actions</b>-&gt;<b>Create</b>-&gt;<b>Container</b> or
<b>Actions</b>-&gt;<b>Add</b>-&gt;<b>Segment Manager</b>.
</p><p>If the container doesn't exist, it will be created for the disk.  If the container already
exists, the disk will be added to it.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="unassignCSM"></a>D.2. Unassigning the CSM plug-in</h2></div></div><p>Unassigning a CSM plug-in results in the CSM removing its metadata from
the specified disk storage object.  The result is that the disk has no segments
mapped and appears as a raw disk object.  The disk is removed from the
container that consumed it and the data segment is removed as well.</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="id2889526"></a>D.3. Deleting a CSM container</h2></div></div><p>An existing CSM container cannot be deleted if it is producing any data segments, 
because other EVMS plug-ins might be building higher-level objects on the CSM objects.
To delete a CSM container, first remove disk objects from the container.  When the last
disk is removed, the container is also removed.</p></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="jfsfsim"></a>Appendix E. JFS file system interface module</h2></div></div><p>
The JFS FSIM lets EVMS users create and manage JFS file systems from
within the EVMS interfaces.  In order to use the JFS FSIM, version 1.0.9 or
later of the JFS utilities must be installed on your system.  The latest
version of JFS can be found at 
<a href="http://oss.software.ibm.com/jfs/" target="_top">http://oss.software.ibm.com/jfs/</a>.
</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="createjfsfsim"></a>E.1. Creating JFS file systems</h2></div></div><p>
JFS file systems can be created with <b>mkfs</b> on any EVMS
or compatibility volume (at least 16 MB in size) that does not already
have a file system.  The following options are available for creating
JFS file systems:</p><div class="variablelist"><dl><dt><b>badblocks</b></dt><dd><p>Perform a read-only check for bad blocks on the volume
before creating the file system.  The default is false.</p></dd><dt><b>caseinsensitive</b></dt><dd><p>Mark the file system as case-insensitive (for OS/2 compatibility).
The default is false.</p></dd><dt><b>vollabel</b></dt><dd><p>Specify a volume label for the file system.  The default is none.
</p></dd><dt><b>journalvol</b></dt><dd><p>Specify the volume to use for an external journal.  This option
is only available with version 1.0.20 or later of the JFS utilities.
The default is none.
</p></dd><dt><b>logsize</b></dt><dd><p>
Specify the inline log size (in MB).  This option is only available if
the journalvol option is not set.  The default is 0.4% of the size of
the volume up to 32 MB.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="checkjfsfsim"></a>E.2. Checking JFS file systems</h2></div></div><p>
The following options are available for checking JFS file systems with
<b>fsck</b>:
</p><div class="variablelist"><dl><dt><b>force</b></dt><dd><p>Force a complete file system check, even if the file system is
already marked clean.  The default is false.</p></dd><dt><b>readonly</b></dt><dd><p>Check the file system is in read-only mode.  Report but do not
fix errors.  If the file system is mounted, this option is
automatically selected.  The default is false.</p></dd><dt><b>omitlog</b></dt><dd><p>Omit replaying the transaction log.  This option should only
be specified if the log is corrupt.  The default is false.</p></dd><dt><b>verbose</b></dt><dd><p>Display details and debugging information during the check.
The default is false.</p></dd><dt><b>version</b></dt><dd><p>Display the version of <tt>fsck.jfs</tt> and exit without 
checking the file system.  The default is false.</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="removejfsfsim"></a>E.3. Removing JFS file systems</h2></div></div><p>
A JFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="expandjfsfsim"></a>E.4. Expanding JFS file systems</h2></div></div><p>
A JFS file system is automatically expanded when its volume is expanded.
However, JFS only allows the volume to be expanded if it is mounted,
because JFS performs all of its expansions online.  In addition, JFS only
allows expansions if version 1.0.21 or later of the JFS utilities are
installed.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="shrinkjfsfsim"></a>E.5. Shrinking JFS file systems</h2></div></div><p>
At this time, JFS does not support shrinking its file systems.
Hence, volumes with JFS file systems cannot be shrunk.
</p></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="xfsfsim"></a>Appendix F. XFS file system interface module</h2></div></div><p>
The XFS FSIM lets EVMS users create and manage XFS file systems from
within the EVMS interfaces.  In order to use the XFS FSIM, version 2.0.0 or
later of the XFS utilities must be installed on your system.  The latest
version of XFS can be found at 
<a href="http://oss.sgi.com/projects/xfs/" target="_top">http://oss.sgi.com/projects/xfs/</a>.
</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="createxfsfsim"></a>F.1. Creating XFS file systems</h2></div></div><p>
XFS file systems can be created with <b>mkfs</b> on any EVMS
or compatibility volume that does not already
have a file system.  The following options are available for creating
XFS file systems:</p><div class="variablelist"><dl><dt><b>vollabel</b></dt><dd><p>Specify a volume label for the file system.  The default is none.
</p></dd><dt><b>journalvol</b></dt><dd><p>Specify the volume to use for an external journal. 
The default is none.
</p></dd><dt><b>logsize</b></dt><dd><p>
Specify the inline log size (in MB).  This option is only available if
the journalvol option is not set.  The default is 4 MB; the
allowed range is 2 to 256 MB.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="checkxfsfsim"></a>F.2. Checking XFS file systems</h2></div></div><p>
The following options are available for checking XFS file systems with
<b>fsck</b>:
</p><div class="variablelist"><dl><dt><b>readonly</b></dt><dd><p>Check the file system is in read-only mode.  Report but do not
fix errors.  The default is false.</p></dd><dt><b>verbose</b></dt><dd><p>Display details and debugging information during the check.
The default is false.</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="removexfsfsim"></a>F.3. Removing XFS file systems</h2></div></div><p>
An XFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="expandxfsfsim"></a>F.4. Expanding XFS file systems</h2></div></div><p>
An XFS file system is automatically expanded when its volume is expanded.
However, XFS only allows the volume to be expanded if it is mounted,
because XFS performs all of its expansions online.  
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="shrinkxfsfsim"></a>F.5. Shrinking XFS file systems</h2></div></div><p>
At this time, XFS does not support shrinking its file systems.
Hence, volumes with XFS file systems cannot be shrunk.
</p></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="reiserfsim"></a>Appendix G. ReiserFS file system interface module</h2></div></div><p>
The ReiserFS FSIM lets EVMS users create and manage ReiserFS file systems from
within the EVMS interfaces.  In order to use the 
ReiserFS FSIM, version 3.x.0 or
later of the ReiserFS utilities must be installed on your system.  
In order to get full functionality from the ReiserFS FSIM, use version
3.x.1b or later. The latest
version of ReiserFS can be found at 
<a href="http://www.namesys.com/" target="_top">http://www.namesys.com/</a>.
</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="createreiserfsim"></a>G.1. Creating ReiserFS file systems</h2></div></div><p>
ReiserFS file systems can be created with <b>mkfs</b> on any EVMS
or compatibility volume that does not already
have a file system.  The following option is available for creating
ReiserFS file systems:</p><div class="variablelist"><dl><dt><b>vollabel</b></dt><dd><p>Specify a volume label for the file system.  The default is none.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="checkreiserfsim"></a>G.2. Checking ReiserFS file systems</h2></div></div><p>
The following option is available for checking XFS file systems with
<b>fsck</b>:
</p><div class="variablelist"><dl><dt><b>mode</b></dt><dd><p>There are three possible modes for checking a ReiserFS file system:
Check Read-Only, Fix, and Rebuild Tree.&quot;</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="removexreiserfsim"></a>G.3. Removing ReiserFS file systems</h2></div></div><p>
A ReiserFS file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="expandreiserFSfsim"></a>G.4. Expanding ReiserFS file systems</h2></div></div><p>
A ReiserFS file system is automatically expanded when its volume is expanded.
ReiserFS file systems can be expanded if the volume is mounted or
unmounted.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="shrinkreiserfsim"></a>G.5. Shrinking ReiserFS file systems</h2></div></div><p>
A ReiserFS file system is automatically shrunk if the volume is shrunk.
ReiserFS file systems can only be shrunk if the volume is unmounted.
</p></div></div><div class="appendix"><div class="titlepage"><div><h2 class="title"><a name="ext23fsim"></a>Appendix H. Ext-2/3 file system interface module</h2></div></div><p>
The Ext-2/3 FSIM lets EVMS users create and manage Ext2 and
Ext3 file systems from
within the EVMS interfaces.  In order to use the Ext-2/3 FSIM, 
the e2fsprogs package 
must be installed on your system.  The e2fsprogs package
can be found at 
<a href="http://e2fsprogs.sourceforge.net/" target="_top">http://e2fsprogs.sourceforge.net/</a>.
</p><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="createext23fsim"></a>H.1. Creating Ext-2/3 file systems</h2></div></div><p>
Ext-2/3 file systems can be created with <b>mkfs</b> on any EVMS
or compatibility volume that does not already
have a file system.  The following options are available for creating
Ext-2/3 file systems:</p><div class="variablelist"><dl><dt><b>badblocks</b></dt><dd><p>Perform a read-only check for bad blocks on the volume
before creating the file system.  The default is false.</p></dd><dt><b>badblocks_rw</b></dt><dd><p>Perform a read/write check for bad blocks on the volume before
creating the file system.  The default is false.
</p></dd><dt><b>vollabel</b></dt><dd><p>Specify a volume label for the file system.  The default is none.
</p></dd><dt><b>journal</b></dt><dd><p>Create a journal for use with the Ext2 file system.  The default
is true.
</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="checkext23fsim"></a>H.2. Checking Ext-2/3 file systems</h2></div></div><p>
The following options are available for checking Ext-2/3 file systems with
<b>fsck</b>:
</p><div class="variablelist"><dl><dt><b>force</b></dt><dd><p>Force a complete file system check, even if the file system is
already marked clean.  The default is false.</p></dd><dt><b>readonly</b></dt><dd><p>Check the file system is in read-only mode.  Report but do not
fix errors.  If the file system is mounted, this option is
automatically selected.  The default is false.</p></dd><dt><b>badblocks</b></dt><dd><p>Check for bad blocks on the volume and mark them as busy.  The
default is false.
</p></dd><dt><b>badblocks_rw</b></dt><dd><p>Perform a read-write check for bad blocks on the volume and mark
them as busy. The default is false.</p></dd></dl></div></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="removereiserfsim"></a>H.3. Removing Ext-2/3 file systems</h2></div></div><p>
An Ext-2/3 file system can be removed from its volume if the file system is
unmounted.  This operation involves erasing the superblock from the volume
so the file system will not be recognized in the future.  There are no
options available for removing file systems.
</p></div><div class="sect1"><div class="titlepage"><div><h2 class="title" style="clear: both"><a name="expandshrinkext23fsim"></a>H.4. Expanding and shrinking Ext-2/3 
file systems</h2></div></div><p>
An Ext-2/3 file system is automatically expanded or shrunk when its volume 
is expanded or shrunk.
However, Ext-2/3 only allows these operations if the volume is
unmounted, because online expansion and shrinkage is not yet supported.
</p></div></div></div></body></html>
