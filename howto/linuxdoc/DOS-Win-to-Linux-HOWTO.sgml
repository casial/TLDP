<!doctype linuxdoc system>
<!-- From DOS/Windows HOWTO, by Guido Gonzato  -*- linuxdoc -*-  --> 


<article>

<title> From DOS/Windows to Linux HOWTO 

<author> By Guido Gonzato, <tt>ggonza at tin.it</tt>

<date> Version 1.3.5. 31 August 2000.


<abstract>

This HOWTO is dedicated to all the (soon to be former?) DOS and Windows
users who have decided to switch to Linux, the free UNIX clone. The purpose
of this document is to help the reader translate his or her knowledge of DOS
and Windows into the Linux environment, as well as providing hints on
exchanging files and resources between the two OSes.

</abstract>

<toc>


<sect> Introduction

<p>

<sect1> Is Linux Right for You?

<p>

Let's start politically correct. Throughout this document I say ``Linux'',
but I mean ``GNU/Linux''. Please go to <url
url="http://www.gnu.org/gnu/linux-and-gnu.html"> to see why.

You want to switch from the DOS/Windows world to Linux? Good idea: Linux is
technically superior to DOS, Windows 9x and even Windows NT. But beware: it
might not be useful for you. These are the main differences between
DOS/Windows and Linux:

<itemize>

<item> Windows runs Microsoft Office and lots of games; is perceived to be
easy to install and configure; is notoriously unstable; performs poorly;
crashes are frequent.

<item> Linux runs StarOffice, scores of technical software and fewer games;
can be tricky to install and configure; is rock solid; performs
impeccably; crashes are extremely rare.

</itemize>

It's up to you to decide what you need. Furthermore, Linux gives you power,
but it takes some time to learn how to harness it. Thus, if mostly need
commercial sw, or if you don't feel like learning new commands and concepts,
you had better look elsewhere. Be aware that many newcomers give up because
of initial difficulties.

Work is underway to make Linux simpler to use, but <em>don't expect to be
proficient with it unless you read a lot of documentation and use it at
least for a few months</em>. Linux won't give you instant results. In spite
of these warnings, I'm 100&percnt; confident that if you are the right user
type you'll find in Linux your computer Nirvana. By the way, Linux + DOS/Win
can coexist happily on the same machine.

Prerequisites for this howto: I'll assume that

<itemize>

<item> you know the basic DOS commands and concepts;

<item> Linux, possibly with X Window System (X11 for short), is properly
installed on your PC;

<item> your shell (the equivalent of <tt>COMMAND.COM</tt>) is <tt>bash</tt>.

</itemize>

Unless specified, all information in this work is aimed at bad ol' DOS.
There is information about Windows here and there, but bear in mind that
Windows and Linux are totally different, unlike DOS that is sort of a UNIX
poor relation.

Please also note that this work is neither a complete primer nor a
configuration guide!

The latest version of this document is available in several formats on <url
url="http://www.linuxdoc.org">.


<sect1> It Is. Tell Me More

<p>

You installed Linux and the programs you needed on the PC. You gave yourself
an account (if not, type <tt>adduser yourname</tt> <em>now!</em>) and Linux
is running. You've just entered your name and password, and now you are
looking at the screen thinking: ``Well, now what?''

Now, don't despair. You're almost ready to do the same things you used to do
with DOS/Win, and many more. If you were running DOS/Win instead of Linux,
you would be doing some of the following tasks:

<itemize>

<item> running programs and creating, copying, viewing, deleting, printing,
renaming files;

<item> CD'ing, MD'ing, RD'ing, and DIR'ring your directories;

<item> formatting floppies and copying files from/to them;

<item> tailoring the system;

<item> surfing the Internet;

<item> writing .BAT files and programs in your favourite language;

<item> the remaining 1&percnt;.

</itemize>

You'll be glad to know that these tasks can be accomplished under Linux in a
fashion similar to DOS. Under DOS, the average user uses very few of the
100+ commands available: the same, up to a point, applies to Linux.


<sect2> Introductory Concepts

<p>

The best way to learn something new is to get your feet wet. You are
strongly encouraged to experiment and play with Linux: unless you login as
``root'', you can't damage the system that way. A few points:

<itemize>

<item> first of all, how to quit Linux safely. If you see a text mode
screen, press &lt;CTRL-ALT-DEL&gt;, wait for the system to reboot, then
switch off the PC. If you are working under X Window System, press
&lt;CTRL-ALT-BACKSPACE&gt; first, then &lt;CTRL-ALT-DEL&gt;. <em>Never</em>
switch off or reset the PC directly: this could damage the file system;

<item> unlike DOS or Windows, Linux has built-in security mechanisms. Files
and directories have permissions associated to them; as a result, some
cannot be accessed by the normal user; (see Section <ref id="Permissions"
name="Permissions and Ownership">). DOS and Windows, on the contrary, will
let you wipe out the entire contents of your hard disk;

<item> there's a special user called ``root'': the system administrator,
with full power of life and death on the machine. If you work on your own
PC, you'll be root as well. Working as root is <em>dangerous</em>: any
mistake can seriously damage or destroy the system just like with
DOS/Windows. Don't work as root unless absolutely necessary;

<item> much of the complexity of Linux comes from its extreme
configurability: virtually every feature and every application can be
tailored through one or more configuration files. Complexity is the price to
pay for power;

<item> redirection and piping are a side DOS feature, a very inportant one
and much more powerful under Linux. Simple commands can be strung together
to accomplish complex tasks. I strongly suggest that you learn how to use
them.

</itemize>


<sect2> Getting Help

<p>

There are many ways to get help with Linux. The most important are:

<itemize>

<item> <em>reading the documentation</em>---I mean it. Although the HOWTO
you are reading may serve as an introduction to Linux, there are several
books that you really should read: at least, Matt Welsh's ``Linux
Installation and Getting Started'' (<url
url="http://www.linuxdoc.org/LDP/gs/gs.html">) and the Linux FAQ (<url
url="http://www.linuxdoc.org/FAQ/Linux-FAQ/index.html">). Feel a guilty
conscience until you have read at least one of them;

<item> the documentation of the packages installed on the machine is often
found in subdirectories under <file>/usr/doc/</file>;

<item> to get some help about the ``internal commands'' of the shell, type
<tt>help</tt> or, better, <tt>man bash</tt> or <tt>info bash</tt>;

<item> to get help about a command, type <tt>man command</tt> that invokes
the manual (``man'') page of <tt>command</tt>. Alternatively, type <tt>info
command</tt> that invokes, if available, the info page pertinent of
<tt>command</tt>; info is a hypertext-based documentation system, perhaps
not intuitive to use at first. Finally, you may try <tt>apropos command</tt>
or <tt>whatis command</tt>. With all of these commands, press `q' to exit.

<item> finally, on the Internet: the right place for getting help is Usenet,
like <url url="news:comp.os.linux.setup">. Please don't email me for help,
because I'm quite overloaded.

</itemize>


<sect1> Conventions

<p>

Throughout this work, examples will often follow the following format:
<tt><...></tt> is a required argument, while <tt>[...]</tt> an optional one.
Example:

<tscreen><verb>
$ tar -tf <file.tar> [> redir_file]
</verb></tscreen>

<tt>file.tar</tt> must be indicated, but redirection to <tt>redir_file</tt>
is optional.

``RMP'' means ``please Read the Man Pages for further information''. I can't
stress enough how important reading the documentation is.

When the prompt of a command example is <tt>&num;</tt>, the command can only
be performed by root.


<sect> For the Impatient

<p>

Want to strike out? Have a look at this table:

<!-- I'd like to make this an sgml table, but lynx wouldn't display it
correctly. I'll think it over. -->

<tscreen><verb>
DOS                     Linux                   Notes
------------------------------------------------------------------------------

ATTRIB (+-)attr file    chmod <mode> file       completely different
BACKUP                  tar -Mcvf device dir/   ditto
CD dirname\             cd dirname/             almost the same syntax
COPY file1 file2        cp file1 file2          ditto
DEL file                rm file                 beware - no undelete
DELTREE dirname         rm -R dirname/          ditto
DIR                     ls                      not exactly the same syntax
DIR file /S             find . -name file       completely different
EDIT file               vi file                 I think you won't like it
                        jstar file              feels like dos' edit
EDLIN file              ed file                 forget it
FORMAT                  fdformat,
                        mount, umount           quite different syntax
HELP command            man command,            same philosophy
                        info command
MD dirname              mkdir dirname/          almost the same syntax
MORE < file             less file               much better
MOVE file1 file2        mv file1 file2          ditto
NUL                     /dev/null               ditto
PRINT file              lpr file                ditto
PRN                     /dev/lp0,
                        /dev/lp1                ditto
RD dirname              rmdir dirname/          almost the same syntax
REN file1 file2         mv file1 file2          not for multiple files
RESTORE                 tar -Mxpvf device       different syntax
TYPE file               less file               much better
WIN                     startx                  poles apart!
</verb></tscreen>

If you need more than a table of commands, please refer to the following
sections.


<sect> Meet bash

<p>

Good news: with Linux you type much less at the prompt, because the
<tt>bash</tt> shell types for you whenever possible, and features cool line
editing capabilities. To begin with, the arrow-up key recalls previous
command lines; but there's more. Pressing &lt;TAB&gt; completes file and
directory names, so typing

<tscreen><verb>
$ ls /uTABloTABbTAB
</verb></tscreen>

is like typing

<tscreen><verb>
$ ls /usr/local/bin
</verb></tscreen>

If there were ambiguities, as typing

<tscreen><verb>
$ ls /uTABloTABiTAB
</verb></tscreen>

<tt>bash</tt> stops because it doesn't know if you mean
<file>/usr/local/info</file> or <file>/usr/local/include</file>. Supply more
characters then press &lt;TAB&gt; again.

Other useful key presses are &lt;ESC-BACKSPACE&gt; that deletes a word to
the left, while &lt;ESC-D&gt; deletes a word to the right; &lt;ESC-F&gt;
moves the cursor one word to the right, &lt;ESC-B&gt; to the left;
&lt;CTRL-A&gt; moves to the beginning of the line, &lt;CTRL-E&gt; to the
end. The &lt;ALT&gt; key is equivalent to &lt;ESC&gt;.

Enough for now. Once you get used to these shortcuts, you'll find the DOS
prompt very annoying...


<sect> Files and Programs

<p>


<sect1> Files: Preliminary Notions

<p>

Linux has a structure of directories and files very similar to that of
DOS/Win. Files have filenames that obey special rules, are stored in
directories, some are executable, and among these most have command
switches. Moreover, you can use wildcard characters, redirection, and
piping. There are only a few minor differences:

<itemize>

<item> under DOS, file names are in the so-called 8.3 form; e.g.
<tt>NOTENOUG.TXT</tt>. Under Linux we can do better. If you installed Linux
using a file system like ext2 or umsdos, you can use longer filenames (up to
255 characters), and with more than one dot: for example,
<tt>This_is.a.VERY_long.filename</tt>. Please note that I used both upper
and lower case characters: in fact...

<item> upper and lower case characters in file names or commands are
different. Therefore, <tt>FILENAME.tar.gz</tt> and <tt>filename.tar.gz</tt>
are two different files. <tt>ls</tt> is a command, <tt>LS</tt> is a mistake;

<item> Windows users, beware when using long file names under Linux. If a
file name contains spaces (not recommended but possible), you must enclose
the file name in double quotes whenever you refer to it. For example:

<tscreen><verb>
$ # the following command makes a directory called "My old files"
$ mkdir "My old files"
$ ls
My old files    bin     tmp
</verb></tscreen>

Further, some characters shouldn't be used: some of those are
<tt>!*&dollar;&amp;&num;</tt>.

<item> there are no compulsory extensions like .COM and .EXE for programs,
or .BAT for batch files. Executable files are marked by an asterisk
`<tt>*</tt>' at the end of their name when you issue the <tt>ls -F</tt>
command. For example:

<tscreen><verb>
$ ls -F
I_am_a_dir/   cindy.jpg    cjpg*   letter_to_Joe    my_1st_script*  old~
</verb></tscreen>

The files <tt>cjpg*</tt> and <tt>my_1st_script*</tt> are executables, that
is ``programs''. Under DOS, backup files end in .BAK, while under Linux they
end with a tilde `<tt>&tilde;</tt>'. Further, a file whose name starts with
a dot is considered as hidden. Example: the file
<tt>.I.am.a.hidden.file</tt> won't show up after the <tt>ls</tt> command;

<item> DOS program switches are obtained with <tt>/switch</tt>, Linux
switches with <tt>-switch</tt> or <tt>--switch</tt>. Example: <tt>dir
/s<</tt>tt> becomes <tt>ls -R</tt>. Note that many DOS programs, like
<tt>PKZIP</tt> or <tt>ARJ</tt>, use UNIX-style switches.

</itemize>

You can now jump to Section <ref id="Files" name="Translating Commands from
DOS to Linux">, but if I were you I'd read on.


<sect1> Symbolic Links

<p>

UNIX has a type of file that doesn't exist under DOS: the symbolic link.
This can be thought of as a pointer to a file or to a directory, and can be
used instead of the file or directory it points to; it's similar to Windows
shortcuts. Examples of symbolic links are <tt>/usr/X11</tt>, which points to
<tt>/usr/X11R6</tt>; <tt>/dev/modem</tt>, which points to either
<tt>/dev/ttyS0</tt> or <tt>/dev/ttyS1</tt>.

To make a symbolic link:

<tscreen><verb>
$ ln -s <file_or_dir> <linkname>
</verb></tscreen>

Example:

<tscreen><verb>
$ ln -s /usr/doc/g77/DOC g77manual.txt
</verb></tscreen>

Now you can refer to <tt>g77manual.txt</tt> instead of
<tt>/usr/doc/g77/DOC</tt>. Links appear like this in directory listings:

<tscreen><verb>
$ ls -F
g77manual.txt@
$ ls -l
(several things...)           g77manual.txt -> /usr/doc/g77/DOC
</verb></tscreen>


<sect1> Permissions and Ownership <label id="Permissions">

<p>

DOS files and directories have the following attributes: A (archive), H
(hidden), R (read-only), and S (system). Only H and R make sense under
Linux: hidden files start with a dot, and for the R attribute, read on.

Under UNIX a file has ``permissions'' and an owner, who in turn belongs to a
``group''. Look at this example:

<tscreen><verb>
$ ls -l /bin/ls
-rwxr-xr-x  1  root  bin  27281 Aug 15 1995 /bin/ls*
</verb></tscreen>

The first field contains the permissions of the file <tt>/bin/ls</tt>, which
belongs to root, group bin. Leaving the remaining information aside,
remember that <tt>-rwxr-xr-x</tt> means, from left to right:

<tt>-</tt> is the file type (<tt>-</tt> = ordinary file, <tt>d</tt> =
directory, <tt>l</tt> = link, etc); <tt>rwx</tt> are the permissions for the
file owner (read, write, execute); <tt>r-x</tt> are the permissions for the
group of the file owner (read, execute); (I won't cover the concept of
group, you can survive without it as long as you're a beginner ;-)
<tt>r-x</tt> are the permissions for all other users (read, execute).

The directory <tt>/bin</tt> has permissions, too: see Section <ref
id="Directories Permissions" name="Directories Permissions"> for further
details. This is why you can't delete the file <tt>/bin/ls</tt> unless you
are root: you don't have the permission to do so. To change a file's
permissions, the command is:

<tscreen><verb>
$ chmod <whoXperm> <file>
</verb></tscreen>

where who is <tt>u</tt> (user, that is owner), <tt>g</tt> (group),
<tt>o</tt> (other), X is either <tt>+</tt> or <tt>-</tt>, perm is <tt>r</tt>
(read), <tt>w</tt> (write), or <tt>x</tt> (execute). Common examples of
<tt>chmod</tt> use are the following:

<tscreen><verb>
$ chmod +x file
</verb></tscreen>

this sets the execute permission for the file.

<tscreen><verb>
$ chmod go-rw file
</verb></tscreen>

this removes read and write permission for everyone but the owner.

<tscreen><verb>
$ chmod ugo+rwx file
</verb></tscreen>

this gives everyone read, write, and execute permission. 

<tscreen><verb>
# chmod +s file
</verb></tscreen>

this makes a so-called ``setuid'' or ``suid'' file---a file that everyone
can execute with its owner's privileges. Typically, you'll come across root
suid files; these are often important system files, like the X server.

A shorter way to refer to permissions is with digits: <tt>rwxr-xr-x</tt> can
be expressed as 755 (every letter corresponds to a bit: <tt>---</tt> is 0,
<tt>--x</tt> is 1, <tt>-w-</tt> is 2, <tt>-wx</tt> is 3...). It looks
difficult, but with a bit of practice you'll understand the concept. root,
being the superuser, can change everyone's file permissions. RMP.


<sect1> Files: Translating Commands <label id="Files">

<p>

On the left, the DOS commands; on the right, their Linux counterpart.

<tscreen><verb>
ATTRIB:         chmod
COPY:           cp
DEL:            rm
MOVE:           mv
REN:            mv
TYPE:           more, less, cat
</verb></tscreen>

Redirection and plumbing operators: <tt> < > >> |</tt>

Wildcards: <tt>* ?</tt>

<tt>nul:        /dev/null</tt>

<tt>prn, lpt1:  /dev/lp0 or /dev/lp1; lpr</tt>

<sect2> Examples

<p> 

<tscreen><verb>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO>ATTRIB +R FILE.TXT             $ chmod 400 file.txt
C:\GUIDO>COPY JOE.TXT JOE.DOC           $ cp joe.txt joe.doc
C:\GUIDO>COPY *.* TOTAL                 $ cat * > total
C:\GUIDO>COPY FRACTALS.DOC PRN          $ lpr fractals.doc
C:\GUIDO>DEL TEMP                       $ rm temp
C:\GUIDO>DEL *.BAK                      $ rm *~
C:\GUIDO>MOVE PAPER.TXT TMP\            $ mv paper.txt tmp/
C:\GUIDO>REN PAPER.TXT PAPER.ASC        $ mv paper.txt paper.asc
C:\GUIDO>PRINT LETTER.TXT               $ lpr letter.txt
C:\GUIDO>TYPE LETTER.TXT                $ more letter.txt
C:\GUIDO>TYPE LETTER.TXT                $ less letter.txt
C:\GUIDO>TYPE LETTER.TXT > NUL          $ cat letter.txt > /dev/null
        n/a                             $ more *.txt *.asc
        n/a                             $ cat section*.txt | less
</verb></tscreen>

Notes:

<itemize>

<item> <tt>*</tt> is smarter under Linux: <tt>*</tt> matches all files
except the hidden ones; <tt>.*</tt> matches all hidden files (but also the
current directory `<tt>.</tt>' and parent directory `<tt>..</tt>': beware!);
<tt>*.*</tt> matches only those that have a `<tt>.</tt>' in the middle or
that end with a dot; <tt>p*r</tt> matches both `peter' and `piper';
<tt>*c*</tt> matches both `picked' and `peck';

<item> when using <tt>more</tt>, press &lt;SPACE&gt; to read through the
file, `q' to exit. <tt>less</tt> is more intuitive and lets you use the
arrow keys;

<item> there is no <tt>UNDELETE</tt>, so <em>think twice</em> before
deleting anything;

<item> in addition to DOS' <tt>&lt; &gt; &gt;&gt;</tt>, Linux has
<tt>2&gt;</tt> to redirect error messages (stderr); moreover,
<tt>2&gt;&amp;1</tt> redirects stderr to stdout, while <tt>1&gt;&amp;2</tt>
redirects stdout to stderr;

<item> Linux has another wildcard: the <tt>[]</tt>. Usage: <tt>[abc]*</tt>
matches files starting with a, b, c; <tt>*[I-N1-3]</tt> matches files ending
with I, J, K, L, M, N, 1, 2, 3;

<item> <tt>lpr</tt> &lt;file&gt; prints a file in background. To check the
status of the print queue, use <tt>lpq</tt>; to remove a file from the print
queue, use <tt>lprm</tt>;

<item> there is no DOS-like <tt>RENAME</tt>; that is, <tt>mv *.xxx
*.yyy</tt> won't work. A REN-like command is available on <url
url="ftp://metalab.unc.edu/pub/Linux/utils/file">;

<item> use <tt>cp -i</tt> and <tt>mv -i</tt> to be warned when a file is
going to be overwritten.

</itemize>


<sect1> Running Programs: Multitasking and Sessions

<p>

To run a program, type its name as you would do under DOS. If the directory
(Section <ref id="Directories" name="Using Directories">) where the program
is stored is included in the PATH (Section <ref id="System Initialisation"
name="System Initialisation Files">), the program will start. Exception:
unlike DOS, under Linux a program located in the current directory won't run
unless the directory is included in the PATH. Escamotage: being
<tt>prog</tt> your program, type <tt>./prog</tt>.

This is what the typical command line looks like:

<tscreen><verb>
$ command [-s1 [-s2] ... [-sn]] [par1 [par2] ... [parn]] [< input] [> output]
</verb></tscreen>

where <tt>-s1</tt>, ..., <tt>-sn</tt> are the program switches,
<tt>par1</tt>, ..., <tt>parn</tt> are the program parameters. You can issue
several commands on the command line:

<tscreen><verb>
$ command1 ; command2 ; ... ; commandn
</verb></tscreen>

That's all about running programs, but it's easy to go a step beyond. One of
the main reasons for using Linux is that it is a multitasking os---it can
run several programs (from now on, processes) at the same time. You can
launch processes in background and continue working straight away. Moreover,
Linux lets you have several sessions: it's like having many computers to
work on at once!

<itemize>

<item> To switch to session 1..6 on the virtual consoles, press 
&lt;ALT-F1&gt; ... &lt;ALT-F6&gt;

<item> To start a new session in the same v.c. without leaving the current
one, type <tt>su - &lt;loginname&gt;</tt>. Example: <tt>su - root</tt>. This
is useful, for instance, when you need to perform a task that only root can
do.

<item> To end a session, type <tt>exit</tt>. If there are stopped jobs (see 
later), you'll be warned.

<item> To launch a process in background, add an ampersand '<tt>&amp;</tt>'
at the end of the command line:

<tscreen><verb>
$ progname [-switches] [parameters] [< input] [> output] &
[1] 123
</verb></tscreen>

the shell identifies the process with a job number (e.g. <tt>[1]</tt>; see
below), and with a PID (Process Identification Number; 123 in our example).

<item> To see how many processes there are, type <tt>ps ax</tt>. This will
output a list of currently running processes. 

<item> To kill (terminate) a process, type <tt>kill &lt;PID&gt;</tt>. You
may need to kill a process when you don't know how to quit it the right
way.... Unless you're root, you can't kill other people's processes.
Sometimes, a process will only be killed by <tt>kill -SIGKILL
&lt;PID&gt;</tt>.

In addition, the shell allows you to stop or temporarily suspend a process,
send a process to background, and bring a process from background to
foreground. In this context, processes are called ``jobs''.

<item> To see how many jobs there are, type <tt>jobs</tt>. Here the jobs are
identified by their job number, not by their PID.

<item> To stop a process running in foreground, press &lt;CTRL-C&gt; (it
won't always work).

<item> To suspend a process running in foreground, press &lt;CTRL-Z&gt;
(ditto).

<item> To send a suspended process into background, type <tt>bg
&lt;%job&gt;</tt> (it becomes a job).

<item> To bring a job to foreground, type <tt>fg &lt;%job&gt;</tt>. To bring
to foreground the last job sent to background, simply type <tt>fg</tt>.

<item> To kill a job, type <tt>kill &lt;%job&gt;</tt> where &lt;job&gt; may
be 1, 2, 3,...

</itemize>

Using these commands you can format a disk, zip a bunch of files, compile a
program, and unzip an archive all at the same time, and still have the
prompt at your disposal. Try this with Windows, just to see the difference
in performance (if it doesn't crash, of course).


<sect1> Running Programs on Remote Computers

<p>

To run a program on a remote machine whose name is
<tt>remote.machine.edu</tt>:

<tscreen><verb>
$ telnet remote.machine.edu
</verb></tscreen>

After logging in, start your favourite program. Needless to say, you must
have a shell account on the remote machine.

If you have X11, you can even run an X application on a remote computer,
displaying it on your X screen. Let <tt>remote.machine.edu</tt> be the
remote X computer and let <tt>local.linux.box</tt> be your Linux machine. To
run from <tt>local.linux.box</tt> an X program that resides on
<tt>remote.machine.edu</tt>, do the following:

<itemize>

<item> fire up X11, start an <tt>xterm</tt> or equivalent terminal emulator,
then type:

<tscreen><verb>
$ xhost +remote.machine.edu
$ telnet remote.machine.edu
</verb></tscreen>

<item> after logging in, type:

<tscreen><verb>
remote:$ DISPLAY=local.linux.box:0.0
remote:$ progname &
</verb></tscreen>

(instead of <tt>DISPLAY...</tt>, you may have to write: <tt>setenv DISPLAY
local.linux.box:0.0</tt>. It depends on the remote shell.)

</itemize>

Et voila! Now <tt>progname</tt> will start on <tt>remote.machine.edu</tt>
and will be displayed on your machine. Don't try this over the modem though,
for it's too slow to be usable. Moreover, this is a crude and insecure
method: please read the ``Remote X Apps mini-HOWTO'' at <url
url="http://www.linuxdoc.org/HOWTO/mini/Remote-X-Apps.html">.


<sect> Using Directories <label id="Directories">

<p>

<sect1> Directories: Preliminary Notions

<p>

We have seen the differences between files under DOS/Win and Linux. As for
directories, under DOS/Win the root directory is <tt>&bsol;</tt>, under Linux
it is <tt>/</tt>. Similarly, nested directories are separated by <tt/&bsol;/
under DOS/Win, by <tt>/</tt> under Linux. Example of file paths:

<tscreen><verb>
DOS:    C:\PAPERS\GEOLOGY\MID_EOC.TEX
Linux:  /home/guido/papers/geology/middle_eocene.tex
</verb></tscreen>

As usual, <tt>..</tt> is the parent directory and <tt>.</tt> is the current
directory. Remember that the system won't let you <tt>cd</tt>, <tt>rd</tt>,
or <tt>md</tt> everywhere you want. Each user has his or her stuff in a
directory called `home', given by the system administrator; for instance, on
my PC my home dir is <tt>/home/guido</tt>.


<sect1> Directories Permissions <label id="Directories Permissions">

<p>

Directories, too, have permissions. What we have seen in Section <ref
id="Permissions" name="Permissions and Ownership"> applies to directories as
well (user, group, and other). For a directory, <tt>rx</tt> means you can
<tt>cd</tt> to that directory, and <tt>w</tt> means that you can delete a
file in the directory (according to the file's permissions, of course), or
the directory itself.

For example, to prevent other users from snooping in
<tt>/home/guido/text</tt>:

<tscreen><verb>
$ chmod o-rwx /home/guido/text
</verb></tscreen>


<sect1> Directories: Translating Commands <label id="Directories: Trans">

<p>

<tscreen><verb>
DIR:            ls, find, du
CD:             cd, pwd
MD:             mkdir
RD:             rmdir
DELTREE:        rm -rf
MOVE:           mv
</verb></tscreen>

<sect2> Examples

<p>

<tscreen><verb>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO>DIR                            $ ls
C:\GUIDO>DIR FILE.TXT                   $ ls file.txt
C:\GUIDO>DIR *.H *.C                    $ ls *.h *.c
C:\GUIDO>DIR/P                          $ ls | more
C:\GUIDO>DIR/A                          $ ls -l
C:\GUIDO>DIR *.TMP /S                   $ find / -name "*.tmp"
C:\GUIDO>CD                             $ pwd
        n/a - see note                  $ cd
        ditto                           $ cd ~
        ditto                           $ cd ~/temp
C:\GUIDO>CD \OTHER                      $ cd /other
C:\GUIDO>CD ..\TEMP\TRASH               $ cd ../temp/trash
C:\GUIDO>MD NEWPROGS                    $ mkdir newprogs
C:\GUIDO>MOVE PROG ..                   $ mv prog ..
C:\GUIDO>MD \PROGS\TURBO                $ mkdir /progs/turbo
C:\GUIDO>DELTREE TEMP\TRASH             $ rm -rf temp/trash
C:\GUIDO>RD NEWPROGS                    $ rmdir newprogs
C:\GUIDO>RD \PROGS\TURBO                $ rmdir /progs/turbo
</verb></tscreen>

Notes: 

<itemize>

<item> when using <tt>rmdir</tt>, the directory to remove must be empty. To
delete a directory and all of its contents, use <tt>rm -rf</tt> (at your own
risk).

<item> the character `<tt>&tilde;</tt>' is a shortcut for the name of your
home directory. The commands <tt>cd</tt> or <tt>cd ~</tt> will take you to
your home directory from wherever you are; the command <tt>cd ~/tmp</tt>
will take you to <tt>/home/your_home/tmp</tt>.

<item> <tt>cd -</tt> ``undoes'' the last <tt>cd</tt>.

</itemize>


<sect> Floppies, Hard Disks, and the Like <label id="Floppies">

<p>

There are two ways to manage devices under Linux: the DOS way and the UNIX
way. Take your pick.


<sect1> Managing Devices the DOS Way

<p>

Most Linux distributions include the Mtools suite, a set of commands that
are perfectly equivalent to their DOS counterpart, but start with an `m':
i.e., <tt>mformat</tt>, <tt>mdir</tt>, <tt>mdel</tt>, <tt>mmd</tt>, and so
on. They can even preserve long file names, but not file permissions. If you
configure Mtools editing a file called <file>/etc/mtools.conf</file> (a
sample is provided in the distribution), you can also access the DOS/Win
partition, the CD--ROM, and the Zip drive. To format a fresh disk though,
the <tt>mformat</tt> command won't do. As root, you'll have to issue this
command beforehand: <tt>fdformat /dev/fd0H1440</tt>.

You can't access files on the floppy with a command like, say, <tt>less
a:file.txt</tt>! This is the disadvantage of the DOS way of accessing disks.


<sect1> Managing Devices the UNIX Way

<p>

UNIX has a different way to handle devices. There are no separate volumes
like A: or C:; a disk, be it a floppy or whatever, becomes part of the local
file system through an operation called ``mounting''. When you're done using
the disk, before extracting it you must ``unmount'' it.

Physically formatting a disk is one thing, making a file system on it is
another. The DOS command <tt>FORMAT A:</tt> does both things, but under
Linux there are separate commands. To format a floppy, see above; to create
a file system:

<tscreen><verb>
# mkfs -t ext2 -c /dev/fd0H1440
</verb></tscreen>

You can use <tt>dos</tt>, <tt>vfat</tt> (recommended) or other formats
instead of <tt>ext2</tt>. Once the disk is prepared, mount it with the
command

<tscreen><verb>
# mount -t ext2 /dev/fd0 /mnt
</verb></tscreen>

specifying the right file system if you don't use <tt>ext2</tt>. Now you can
address the files in the floppy using <tt>/mnt</tt> instead of A: or B:.
Examples:

<tscreen><verb>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO>DIR A:                         $ ls /mnt
C:\GUIDO>COPY A:*.*                     $ cp /mnt/* .
C:\GUIDO>COPY *.ZIP A:                  $ cp *.zip /mnt
C:\GUIDO>EDIT A:FILE.TXT                $ jstar /mnt/file.txt
C:\GUIDO>A:                             $ cd /mnt
A:> _                                   /mnt/$ _
</verb></tscreen>

When you've finished, before extracting the disk you <em>must</em> unmount
it with the command

<tscreen><verb>
# umount /mnt
</verb></tscreen>

Obviously, you have to <tt>fdformat</tt> and <tt>mkfs</tt> only unformatted
disks, not previously used ones. If you want to use the drive B:, refer to
<tt>fd1H1440</tt> and <tt>fd1</tt> instead of <tt>fd0H1440</tt> and
<tt>fd0</tt> in the examples above.

Needless to say, what applies to floppies also applies to other devices; for
instance, you may want to mount another hard disk or a CD--ROM drive. Here's
how to mount the CD--ROM:

<tscreen><verb>
# mount -t iso9660 /dev/cdrom /mnt
</verb></tscreen>

This was the ``official'' way to mount your disks, but there's a trick in
store. Since it's a bit of a nuisance having to be root to mount a floppy or
a CD--ROM, every user can be allowed to mount them this way:

<itemize>

<item> as root, do the following:

<tscreen><verb>
# mkdir /mnt/floppy ; mkdir /mnt/cdrom
# chmod 777 /mnt/floppy /mnt/cd*
# # make sure that the CD-ROM device is right
# chmod 666 /dev/hdb ; chmod 666 /dev/fd*
</verb></tscreen>

<item> add in <file>/etc/fstab</file> the following lines:

<tscreen><verb>
/dev/cdrom      /mnt/cdrom  iso9660 ro,user,noauto          0       0
/dev/fd0        /mnt/floppy vfat    user,noauto             0       0
</verb></tscreen>

</itemize>

Now, to mount a DOS floppy and a CD--ROM:

<tscreen><verb>
$ mount /mnt/floppy
$ mount /mnt/cdrom
</verb></tscreen>

<file>/mnt/floppy</file> and <file>/mnt/cdrom</file>
can now be accessed by every user. Remember that allowing everyone to mount
disks this way is a gaping security hole, if you care.

Two useful commands are <tt>df</tt>, which gives information on the mounted
file systems, and <tt>du dirname</tt> which reports the disk space consumed
by the directory.


<sect1> Backing Up <label id="Backing Up">

<p>

There are several packages to help you, but the very least you can do for a
multi-volume backup is (as root):

<tscreen><verb>
# tar -M -cvf /dev/fd0H1440 dir_to_backup/
</verb></tscreen>

Make sure to have a formatted floppy in the drive, and several more ready.
To restore your stuff, insert the first floppy in the drive and do:

<tscreen><verb>
# tar -M -xpvf /dev/fd0H1440
</verb></tscreen>


<sect> What About Windows?

<p>

The ``equivalent'' of Windows is the graphic system X Window System. Unlike
Windows or the Mac, X11 wasn't designed for ease of use or to look good, but
just to provide graphic facilities to UNIX workstations. These are the main
differences:

<itemize>

<item> while Windows looks and feels the same all over the world, X11 does
not: it's much more configurable. X11's overall look is given by a key
component called ``window manager'', of which you have a wide choice:
<tt>fvwm</tt>, basic but nice and memory efficient, <tt>fvwm2-95</tt>,
<tt>Afterstep</tt>, <tt>WindowMaker</tt>, <tt>Enlightenment</tt>, and many
more. The w.m. is usually invoked from <tt>.xinitrc</tt>;

<item> your w.m. can be configured so as a window acts as under, er,
Windows: you click on it and it comes to foreground. Another possibility is
that it comes to foreground when the mouse moves over it (``focus''). Also,
the placement of windows on the screen can be automatic or interactive: if a
strange frame appears instead of your program, left click where you want it
to appear;

<item> most features can be tailored editing one or more configuration
files. Read the docs of your w.m.: the configuration file can be
<tt>.fvwmrc</tt>, <tt>.fvwm2rc95</tt>, <tt>.steprc</tt>, etc. A sample
configuration file is typically found in
<file>/etc/X11/window-manager-name/system.window-manager-name</file>;

<item> X11 applications are written using special libraries (``widget
sets''); as several are available, applications look different. The most
basic ones are those that use the Athena widgets (2--D look; <tt>xdvi</tt>,
<tt>xman</tt>, <tt>xcalc</tt>); others use Motif (<tt>netscape</tt>), others
still use Tcl/Tk, Qt, Gtk, XForms, and what have you. Nearly all of these
libraries provide roughly the same look and feel as Windows;

<item> the feel, unfortunately, can be incoherent. For instance, if you
select a line of text using the mouse and press &lt;BACKSPACE&gt;, you'd
expect the line to disappear, right? This won't work with Athena--based
apps, but it does with other widget sets;

<item> how scrollbars and resizing work depends on the w.m. and the widget
set. Tip: if you find that the scrollbars don't behave as you would expect,
try using the central button or the two buttons together to move them;

<item> applications don't have an icon by default, but they can have many.
Most w.m. feature a menu you recall by clicking on the desktop (``root
window''); needless to say, the menu can be tailored. To change the root
window appearance, use <tt>xsetroot</tt> or <tt>xloadimage</tt>;

<item> the clipboard can only contain text, and behaves strange. Once you've
selected text, it's already copied to the clipboard: move elsewhere and
press the central button to paste it. There's an application,
<tt>xclipboard</tt>, that provides for multiple clipboard buffers;

<item> drag and drop is an option, and is only available if you use X11
applications and/or w.m. that support it.

</itemize>

This said, good news for you. There are projects that aim at making X11 look
and behave as coherently as Windows. Gnome, <url
url="http://www.gnome.org">, and KDE, <url url="http://www.kde.org">, are
simply awesome. Most likely your distribution uses either or both. You won't
regret your Windows desktop anymore!


<sect> Tailoring the System

<p>

<sect1> System Initialisation Files <label id="System Initialisation">

<p>

Two important files under DOS are <tt>AUTOEXEC.BAT</tt> and
<tt>CONFIG.SYS</tt>, which are used at boot time to initialise the system,
set some environment variables like PATH and FILES, and possibly launch a
program or batch file. Additionally, Windows has the infamous registry---one
of the worst ideas ever conceived in computer science.

Under Linux there are lots of initialisation files, some of which you had
better not tamper with until you know exactly what you are doing; they
reside in the <file>/etc</file> tree. All configuration can be done editing
plain text files. If all you need is setting the PATH and other environment
variables, or you want to change the login messages or automatically launch
a program on login, have a look at the following files:

<tscreen><verb>
FILES                                   NOTES

/etc/issue                              sets pre-login message
/etc/motd                               sets post-login message
/etc/profile                            sets $PATH and other variables, etc.
/etc/bashrc                             sets aliases and functions, etc.
/home/your_home/.bashrc                 sets your aliases + functions
/home/your_home/.bash_profile   or
/home/your_home/.profile                sets environment + starts your progs
</verb></tscreen>

If the latter file exists (note that it is a hidden file), it will be read
after the login, and the commands therein will be executed.

Example---look at this <tt>.bash_profile</tt>:

<code>
# I am a comment
echo Environment:
printenv | less   # equivalent of command SET under DOS
alias d='ls -l'   # easy to understand what an alias is
alias up='cd ..'
echo "I remind you that the path is "$PATH
echo "Today is `date`"  # use the output of the command 'date'
echo "Have a good day, "$LOGNAME
# The following is a "shell function"
ctgz() # List the contents of a .tar.gz archive.
{
  for file in $*
  do
    gzip -dc ${file} | tar tf -
  done
}         
# end of .profile
</code>

<tt>&dollar;PATH</tt> and <tt>&dollar;LOGNAME</tt>, you guessed right, are
environment variables. There are many others to play with; for instance, RMP
for apps like <tt>less</tt> or <tt>bash</tt>.

Putting this line in your <file>/etc/profile</file> will provide the rough
equivalent of <tt>PROMPT $P$G</tt>:

<tscreen><verb>
export PS1="\w\\$ "
</verb></tscreen>


<sect1> Program Initialisation Files

<p>

Under Linux, virtually everything can be tailored to your needs. Most
programs have one or more initialisation files you can fiddle with, often as
a <tt>.prognamerc</tt> in your home dir. The first ones you'll want to
modify are:

<itemize>

<item> <tt> .inputrc</tt>: used by <tt/bash</tt> to define key bindings;

<item> <tt> .xinitrc</tt>: used by <tt>startx</tt> to initialise X Window
System;

<item> <tt> .fvwmrc</tt>: used by the window manager <tt>fvwm</tt>. 

<item> <tt> .joerc, .jstarrc</tt>: used by the editor <tt>joe</tt>;

<item> <tt> .jedrc</tt>: used by the editor <tt>jed</tt>;

<item> <tt> .pinerc</tt>: used by the mail reader <tt>pine</tt>;

<item> <tt> .Xdefault</tt>: used by many X programs.

</itemize>

For all of these and the others you'll come across sooner or later, RMP.
Perhaps I could interest you in the Configuration HOWTO, <url
url="http://www.linuxdoc.org/HOWTO/Config-HOWTO.html">?


<sect> Networking: Concepts

<p>

Not only is ``Dialup Networking'' available under Linux, it's also more
stable and quicker. The name of the game is ``PPP'', the protocol employed
for connecting to the Internet using modems. All you need is a tool that
dials out and makes the connection.

To retrieve your mail from the ISP's server you need a tool called ``email
fetcher'' that uses the POP protocol; when the mail is fetched it will
appear as though it had been directly delivered to your Linux box. You'll
then use a MUA (Mail User Agent) like <tt>pine</tt>, <tt>mutt</tt>,
<tt>elm</tt> or many others to manage it.

While under Windows the dialer is automatically invoked when you launch an
Internet application, under Linux the path is the other way round: you dial
first, then launch the application. A thing called <tt>diald</tt> provides
the usual behaviour. Installing and configuring dialup networking used to be
one of the most difficult things to do under Linux, but not anymore: please
consult the Configuration HOWTO.

Finally, a word about ``Network neighborhood'': you can make your Linux
workstation appear as Windows NT/9x in a local network of Windows machines!
The magic word is Samba: not the lively Brazilian dance, but an
implementation of the SMB protocol for Linux. Go to <url
url="http://samba.anu.edu.au/samba">.


<sect> A Bit of Programming

<p>


<sect1> Shell Scripts: .BAT Files on Steroids <label id="Shell Scripts">

<p>

If you used .BAT files to create shortcuts of long command lines (I did a
lot), this goal can be attained by inserting appropriate alias lines (see
example above) in <tt>profile</tt> or <tt>.bash_profile</tt>. But if your
.BATs were more complicated, then you'll love the scripting language made
available by the shell: it's as powerful as good ol' QBasic, if not more. It
has variables, structures like while, for, case, if... then... else, and
lots of other features: it can be a good alternative to a ``real''
programming language.

To write a script---the equivalent of a .BAT file under DOS---all you have
to do is write a standard ASCII file containing the instructions, save it,
then make it executable with the command <tt>chmod +x &lt;scriptfile></tt>.
To execute it, type its name.

A word of warning. The system editor is called <tt>vi</tt>, and in my
experience most new users find it very difficult to use. I'm not going to
explain how to use it; please consult Matt Welsh's book or search for a
tutorial on the net. Suffice it here to say that:

<itemize>
<item> to insert some text, type <tt>i</tt> then your text;
<item> to delete characters, type &lt;ESC&gt; then <tt>x</tt>;
<item> to quit <tt>vi</tt> whithout saving, type &lt;ESC&gt; then <tt>:q!</tt>
<item> to save and quit, type &lt;ESC&gt; then <tt>:wq</tt>.
</itemize>

A good beginner editor is <tt>joe</tt>: invoking it by typing <tt>jstar</tt>
you'll get the same key bindings as the DOS/Win editor. <tt>jed</tt> in
WordStar or IDE mode is even better. Please consult Section <ref
id="Programs" name="Where to Find Applications"> to see where to get these
editors.

Writing scripts under <tt>bash</tt> is such a vast subject it would require
a book by itself, and I will not delve into the topic any further. I'll just
give you an example of shell script, from which you can extract some basic
rules:

<code>
#!/bin/sh
# sample.sh
# I am a comment
# don't change the first line, it must be there
echo "This system is: `uname -a`" # use the output of the command
echo "My name is $0" # built-in variables
echo "You gave me the following $# parameters: "$*
echo "The first parameter is: "$1
echo -n "What's your name? " ; read your_name
echo notice the difference: "hi $your_name" # quoting with "
echo notice the difference: 'hi $your_name' # quoting with '
DIRS=0 ; FILES=0
for file in `ls .` ; do
  if [ -d ${file} ] ; then # if file is a directory
    DIRS=`expr $DIRS + 1`  # DIRS = DIRS + 1
  elif [ -f ${file} ] ; then
    FILES=`expr $FILES + 1`
  fi
  case ${file} in
    *.gif|*jpg) echo "${file}: graphic file" ;;
    *.txt|*.tex) echo "${file}: text file" ;;
    *.c|*.f|*.for) echo "${file}: source file" ;;
    *) echo "${file}: generic file" ;;
  esac
done
echo "there are ${DIRS} directories and ${FILES} files"
ls | grep "ZxY--%%WKW"
if [ $? != 0 ] ; then # exit code of last command
  echo "ZxY--%%WKW not found"
fi
echo "enough... type 'man bash' if you want more info."
</code>


<sect1> C for Yourself

<p>

Under UNIX, the system language is C, love it or hate it. Scores of other
languages (Java, FORTRAN, Pascal, Lisp, Basic, Perl, awk...) are also
available.

Taken for granted that you know C, here are a couple of guidelines for those
of you who have been spoilt by Turbo C++ or one of its DOS kin. Linux's C
compiler is called <tt>gcc</tt> and lacks all the bells and whistles that
usually accompany its DOS counterparts: no IDE, on-line help, integrated
debugger, etc. It's just a rough command-line compiler, very powerful and
efficient. To compile your standard <tt>hello.c</tt> you'll do:

<tscreen><verb>
$ gcc hello.c
</verb></tscreen>

which will create an executable file called <tt>a.out</tt>. To give the
executable a different name, do

<tscreen><verb>
$ gcc -o hola hello.c
</verb></tscreen>

To link a library against a program, add the switch -l&lt;libname&gt;. For
example, to link in the math library:

<tscreen><verb>
$ gcc -o mathprog mathprog.c -lm
</verb></tscreen>

(The <tt>-l&lt;libname&gt;</tt> switch forces <tt>gcc</tt> to link the
library <tt>/usr/lib/lib&lt;libname&gt;.so</tt>; so <tt>-lm</tt> links
<tt>/usr/lib/libm.so</tt>).

So far, so good. But when your prog is made of several source files, you'll
need to use the utility <tt>make</tt>. Let's suppose you have written an
expression parser: its source file is called <tt>parser.c</tt> and
&num;includes two header files, <tt>parser.h</tt> and <tt>xy.h</tt>. Then
you want to use the routines in <tt>parser.c</tt> in a program, say,
<tt>calc.c</tt>, which in turn &num;includes <tt>parser.h</tt>. What a mess!
What do you have to do to compile <tt>calc.c</tt>?

You'll have to write a so-called <tt>Makefile</tt>, which teaches the
compiler the dependencies between sources and objects files. In our example:

<code>
# This is Makefile, used to compile calc.c
# Press the <TAB> key where indicated!

calc: calc.o parser.o
<TAB>gcc -o calc calc.o parser.o -lm
# calc depends on two object files: calc.o and parser.o

calc.o: calc.c parser.h
<TAB>gcc -c calc.c
# calc.o depends on two source files

parser.o:  parser.c parser.h xy.h
<TAB>gcc -c parser.c
# parser.o depends on three source files

# end of Makefile.
</code>

Save this file as <tt>Makefile</tt> and type <tt>make</tt> to compile your
program; alternatively, save it as <tt>calc.mak</tt> and type <tt>make -f
calc.mak</tt>, and of course RMP. You can invoke some help about the C
functions, that are covered by man pages, section 3; for example,

<tscreen><verb>
$ man 3 printf
</verb></tscreen>

To debug your programs, use <tt>gdb</tt>. <tt>info gdb</tt> to learn how to
use it.

There are lots of libraries available; among the first you may want to use
are <tt>ncurses</tt> (textmode effects), and <tt>svgalib</tt> (console
graphics). Many editors can act as an IDE; <tt>emacs</tt> and <tt>jed</tt>,
for instance, also feature syntax highlighting, automatic indent, and so on.
Alternatively, get the package <tt>rhide</tt> from <url
url="ftp://metalab.unc.edu:/pub/Linux/devel/debuggers/">. It's a Borland IDE
clone, and chances are that you'll like it.


<sect1> X11 Programming

<p>

If you feel brave enough to tackle X11 programming (it's not that
difficult), there are several libraries that make writing X11 programs a
breeze. The main sites to visit are those of GTK+, <url
url="http://www.gtk.org">, and Qt, <url url="http://www.troll.no">. Gtk+ is
a C-based widget set originally written for the graphic package The GIMP
(<url url="http://www.gimp.org">), and is used by the Gnome environment.
Kdeveloper is based on C++-based Qt, used by KDE. Most likely, you'll use
one of these.

Some of the best tools for visual programming are Kdevelop for Qt, <url
url="http://www.kdevelop.org">, and Glade for GTK+, <url
url="http://glade.pn.org">. This page has more information: <url
url="http://www.free-soft.org/guitool/">.


<sect2> Multi-Platform Programming

<p>

Wouldn't it be nice if you could write code that compiled seamlessly under
Linux <em>and</em> Windows using <tt>gcc</tt>? As of this writing, there are
some widget sets that allow for more-or-less stable multi-platform
programming. As far as stability and completeness are concerned though, I
would say that the choice is narrowed down to only one: FLTK, the Fast Light
Tool Kit <url url="http://www.fltk.org">. It's amazingly small, quick, and
stable. It also has a semi-visual builder called Fluid.


<sect> The Remaining 1&percnt;

<p>

Much more than 1&percnt;, actually...


<sect1> Running DOS/Windows Apps

<p>

Yes, you can to some extent run DOS and Windows applications under Linux!
There are two emulators that are quite good: Dosemu (<url
url="http://www.dosemu.org">) and Wine (<url url="http://www.winehq.com">).
The latter is getting better release after release, and the list of runnable
applications is getting larger. It even runs Word and Excel!


<sect1> Using tar and gzip

<p>

Under UNIX there are some widely used applications to archive and compress
files. <tt>tar</tt> is used to make archives---it's like <tt>PKZIP</tt> or
<tt>Winzip</tt>but it doesn't compress, it only archives. To make a new
archive:

<tscreen><verb>
$ tar cvf <archive_name.tar> <file> [file...]
</verb></tscreen>

To extract files from an archive:

<tscreen><verb>
$ tar xvf <archive_name.tar> [file...]
</verb></tscreen>

To list the contents of an archive:

<tscreen><verb>
$ tar tf <archive_name.tar> | less
</verb></tscreen>

You can compress files using <tt>compress</tt>, which is obsolete and
shouldn't be used any more, or <tt>gzip</tt>:

<tscreen><verb>
$ compress <file>
$ gzip <file>
</verb></tscreen>

that creates a compressed file with extension <tt>.Z</tt>
(<tt>compress</tt>) or <tt>.gz</tt> (<tt>gzip</tt>). These programs can
compress only one file at a time. To decompress:

<tscreen><verb>
$ compress -d <file.Z>
$ gzip -d <file.gz>
</verb></tscreen>

RMP.

There are also the <tt>unarj</tt>, <tt>zip</tt> and <tt>unzip</tt> (PK??ZIP
compatible) utilities. Files with extension <tt>.tar.gz</tt> or
<tt>.tgz</tt> (archived with <tt>tar</tt>, then compressed with
<tt>gzip</tt>) are as common in the UNIX world as .ZIP files are under DOS.
Here's how to list the contents of a <tt> .tar.gz</tt> archive:

<tscreen><verb>
$ tar ztf <file.tar.gz> | less
</verb></tscreen>


<sect1> Installing Applications <label id="Install">

<p>

First of all: installing packages is root's work. Most Linux applications
are distributed as a <tt>.tar.gz</tt> archive, which typically will contain
a directory aptly named containing files and/or subdirectories. A good rule
is to install these packages from <tt>/usr/local</tt> with the command

<tscreen><verb>
# tar zxf <archive.tar.gz>
</verb></tscreen>

reading then the README or INSTALL file. In most cases, the application is
distributed in source, which you'll have to compile; often, typing
<tt>make</tt> then <tt>make install</tt> will suffice. If the archive
contains a <tt>configure</tt> script, run it first. Obviously, you'll need
the <tt>gcc</tt> or <tt>g++</tt> compiler.

Other archives have to be unpacked from <file>/</file>; this is the case
with Slackware's <tt>.tgz</tt> archives. Other archives contain the files
but not a subdirectory - careful not to mess things up! Always list the
contents of the archive before installing it.

Debian and Red Hat have their own archive format; respectively,
<tt>.deb</tt> and <tt>.rpm</tt>. The latter is widely used by many
distributions; to install an <tt>rpm</tt> package, type

<tscreen><verb>
# rpm -i package.rpm
</verb></tscreen>


<sect1> Tips You Can't Do Without

<p>

<bf>Backscrolling</bf>: pressing &lt;SHIFT + PAG UP&gt; (the grey key)
allows you to backscroll a few pages, depending on how much video memory you
have.

<bf>Resetting the screen</bf>: if you happen to <tt>more</tt> or
<tt>cat</tt> a binary file, your screen may end up full of garbage. To fix
it, blind type <tt>reset</tt> or this sequence of characters: <tt>echo
CTRL-V ESC c RETURN</tt>.

<bf>Pasting text</bf>: in console, see below; in X, click and drag to select
the text in an <tt>xterm</tt> window, then click the middle button (or the
two buttons together if you have a two-button mouse) to paste. There is also
<tt>xclipboard</tt> (alas, only for text); don't get confused by its very
slow response.

<bf>Using the mouse</bf>: if you installed <tt>gpm</tt>, a mouse driver for
the console, you can click and drag to select text, then right click to
paste the selected text. It works across different VCs.

<bf>Messages from the kernel</bf>: have a look at <tt>/var/adm/messages</tt>
or <tt>/var/log/messages</tt> as root to see what the kernel has to tell
you, including bootup messages. The command <tt>dmesg</tt> is also handy.


<sect1> Where to Find Applications <label id="Programs">

<p>

If you're wondering whether you can replace your old and trusted DOS/Win
application with a Linux one, I suggest that you browse the main Linux
software repository: <url url="ftp://metalab.unc.edu/pub/Linux">. Other good
starting places are the ``Linux Applications and Utilities Page'' <url
url="http://www.xnet.com/~blatura/linapps.shtml">, the ``official'' Linux
page <url url="http://www.linux.org">, and <url url="http://freshmeat.net">.


<sect1> A Few Things You Couldn't Do

<p>

Linux can do an awful lot of things that were cumbersome, difficult or
impossible do to with DOS/Windows. Here's a short list that may whet your
appetite:

<itemize>

<item> <tt>at</tt> allows you to run programs at a specified time;

<item> <tt>awk</tt> is a simple yet powerful language to manipulate data
files (and not only). For example, being <tt>data.dat</tt> your multi field
data file,

<tscreen><verb>
$ awk '$2 ~ "abc" {print $1, "\t", $4}' data.dat
</verb></tscreen>

prints out fields 1 and 4 of every line in <tt>data.dat</tt> whose second
field contains ``abc''.

<item> <tt>cron</tt> is useful to perform tasks periodically, at specified
date and time. Type <tt>man 5 crontab</tt>.

<item> <tt>file &lt;filename&gt;</tt> tells you what <tt>filename</tt> is
(ASCII text, executable, archive, etc.);

<item> <tt>find</tt> (see also Section <ref id="Directories: Trans"
name="Directories: Translating Commands">) is one of the most powerful and
useful commands. It's used to find files that match several characteristics
and perform actions on them. General use of <tt>find</tt> is:

<tscreen><verb>
$ find <directory> <expression>
</verb></tscreen>

where &lt;expression&gt; includes search criteria and actions. Examples:

<tscreen><verb>
$ find . -type l -exec ls -l {} \;
</verb></tscreen>

finds all the files that are symbolic links and shows what they point to.

<tscreen><verb>
$ find / -name "*.old" -ok rm {} \;
</verb></tscreen>

finds all the files matching the pattern and deletes them, asking for your
permission first.

<tscreen><verb>
$ find . -perm +111
</verb></tscreen>

finds all the files whose permissions match 111 (executable).

<tscreen><verb>
$ find . -user root
</verb></tscreen>

finds all the files that belong to root. Lots of possibilities here---RMP.

<item> <tt>grep</tt> finds text patterns in files. For example,

<tscreen><verb>
$ grep -l "geology" *.tex
</verb></tscreen>

lists the files *.tex that contain the word ``geology''. The variant
<tt>zgrep</tt> works on gzipped files. RMP;

<item> <bf>regular expressions</bf> are a complex but darn powerful way of
performing search operations on text. For example,
<tt>^a[^a-m]X{4,}txt$</tt> matches a line that starts with `a', followed by
any character except those in the interval a-m, followed by 4 or more `X',
and ends in `txt'. You use regular expressions with advanced editors,
<tt>less</tt>, and many other applications. <tt>man grep</tt> for an
introduction.

<item> <tt>script &lt;script_file&gt;</tt> dumps the screen contents on
<tt>script_file</tt> until you issue the command <tt>exit</tt>. Useful for
debugging;

<item> <tt>sudo</tt> allows users to perform some of root's tasks (e.g.
formatting and mounting disks; RMP);

<item> <tt>uname -a</tt> gives you info about your system;

<item> <tt>zcat</tt> and <tt>zless</tt> are useful for browsing and piping
gzipped files without decompressing them. For example:

<tscreen><verb>
$ zless textfile.gz
$ zcat textfile.gz | lpr
</verb></tscreen>

<item> The following commands often come in handy: <tt>bc, cal, chsh, cmp,
cut, fmt, head, hexdump, nl, passwd, printf, sort, split, strings, tac,
tail, tee, touch, uniq, w, wall, wc, whereis, write, xargs, znew.</tt> RMP.

</itemize>


<sect1> Practicing UNIX under DOS/Win

<p>

Believe it or not, there are fine tools that provide a UNIX-like environment
under DOS/Windows! One is the Djgpp suite (<url
url="http://www.delorie.com/djgpp/">) for DOS, while Cygwin (<url
url="http://www.cygnus.com/cygwin">) is a more complex port for Win32. Both
include the same GNU development tools and utilities as Linux; you won't get
the same stability and performance, though.

If you'd like to have a taste of Linux, try out Djgpp. Download and install
the following files (as of this writing, the latest version is 2.02):
<tt>djdev202.zip, bnu281b.zip, bsh1147b.zip, fil316b.zip, find41b.zip,
grep22b.zip, gwk303b.zip, lss332b.zip, shl112b.zip.</tt>. Installation
instructions are provided, and you can find assistance on <url
url="news:comp.os.msdos.djgpp">.

In particular, using <tt>bash</tt> under DOS/Win is a whiff of fresh air. To
configure it properly, edit the supplied file <tt>BOOT.BAT</tt> to reflect
your installation, then put these files in your home directory (in the
Windows partition) instead of those provided:

<tscreen><verb>
# this is _bashrc

LS_OPTIONS="-F -s --color=yes"
alias cp='cp -i'
alias d='ls -l'
alias l=less
alias ls="ls $LS_OPTIONS"
alias mv='mv -i'
alias rm='rm -i'
alias u='cd ..'
</verb></tscreen>

<tscreen><verb>
# this is _bprof
if [ -f ~/_bashrc ]; then
  . ~/_bashrc
fi
PS1='\w\$ '
PS2='> '
CDPATH="$CDPATH:~"
# stuff for less(1)
LESS="-M-Q"                     # long prompt, silent
LESSEDIT="%E ?lt+%lt. %f"       # edit top line
VISUAL="jed"                    # editor
LESSCHARSET=latin1              # visualise accented letters
export PS1 PS2 CDPATH LS_OPTIONS LESS LESSEDIT LESSOPEN VISUAL LESSCHARSET
</verb></tscreen>


<sect1> Common Extensions and Related Programs

<p>

You may come across scores of file extensions. Excluding the more 
exotic ones (i.e. fonts, etc.), here's a list of who's what:

<itemize>

<item> <tt>1 ... 8</tt>: man pages. Read them with
<tt>groff -Tascii -man &lt;file.1&gt;</tt>.

<item> <tt>arj</tt>: archive made with <tt>arj</tt>.

<item> <tt>dvi</tt>: output file produced by TeX (see below). <tt>xdvi</tt>
to visualise it; <tt>dvips</tt> to turn it into a PostScript <tt>.ps</tt>
file.

<item> <tt>gz</tt>: archive made with <tt>gzip</tt>.

<item> <tt>info</tt>: info file (sort of alternative to man pages). Get
<tt>info</tt>.

<item> <tt>lsm</tt>: Linux Software Map file. It's a plain ASCII file
containing the description of a package.

<item> <tt>ps</tt>: PostScript file. To visualise or print it get
<tt>gs</tt> and, optionally, <tt>ghostview</tt> or <tt>gv</tt>.

<item> <tt>rpm</tt>: Red Hat package. You can install it on any system using
the package manager <tt>rpm</tt>.

<item> <tt>taz, tar.Z</tt>: archive made with <tt>tar</tt> and compressed
with <tt>compress</tt>.

<item> <tt>tgz, tar.gz</tt>: archive made with <tt>tar</tt> and compressed
with <tt>gzip</tt>.

<item> <tt>tex</tt>: text file to submit to TeX, a powerful typesetting
system. Get the package <tt>tex</tt>, available in many distributions.

<item> <tt>texi</tt>: texinfo file, can produce both TeX and info files (cp.
<tt>info</tt>). Get <tt>texinfo</tt>.

<item> <tt>xbm, xpm, xwd</tt>: graphic file.

<item> <tt>Z</tt>: archive made with <tt>compress</tt>.

</itemize>


<sect1> Converting Files

<p>

If you need to exchange text files between DOS/Win and Linux, be aware of
the ``end of line'' problem. Under DOS, each line of text ends with CR/LF
(that is, ASCII 13 + ASCII 10), with LF under Linux. If you edit a DOS text
file under Linux, each line will likely end with a strange--looking `M'
character; a Linux text file under DOS will appear as a kilometric single
line with no paragraphs. There are a couple of tools, <tt>dos2unix</tt> and
<tt>unix2dos</tt>, to convert the files.

If your text--only files contain accented characters, make sure they are
made under Windows (with Notepad) and not under plain DOS; otherwise, all
accented characters will be screwed up.


<sect1> Free Office Suites

<p>

Yes, you can have for free what would otherwise cost a lot of money!

StarOffice (<url url="http://www.sun.com/staroffice">.) is currently the
only choice, though Koffice is down the pipeline (<url
url="http://www.koffice.org">). StarOffice is big and slow, but very good
anyway: it offers a lot of functionality not found in Microsoft Office. It
can also read and write Word and Excel files, although the conversion isn't
always perfect.

Another good package is Corel WordPerfect, a free edition of which is
available for download. Need I say more? Go fetch it: <url
url="http://www.corel.com">.


<sect> The End, for Now <label id="The End">

<p>

Congratulations! You have now grasped a little bit of UNIX and are ready to
start working. Remember that your knowledge of the system is still limited,
and that you are expected to do more practice with Linux to use it
comfortably. But if all you had to do was get a bunch of applications and
start working with them, what I included here is enough.

I'm sure you'll enjoy using Linux and will keep learning more about
it---everybody does. I bet, too, that you'll never go back to DOS/Win! I
hope I made myself understood and did a good service to my 3 or 4 readers.


<sect1> Copyright

<p>

Copyright (c) by Guido Gonzato, <tt>ggonza at tin.it</tt>. This document may
be distributed only subject to the terms and conditions set forth in the LDP
License at <url url="http://www.linuxdoc.org/COPYRIGHT.html">, except that
this document must not be distributed in modified form without the author's
consent.

If you have questions, please refer to the Linux Documentation Project home
page, <url url="http://www.linuxdoc.org">


<sect1> Disclaimer

<p>

This document is provided ``as is''. I put great effort into writing it as
accurately as I could, but you use the information contained in it at your
own risk. In no event shall I be liable for any damages resulting from the
use of this work.

Many thanks to Matt Welsh, the author of ``Linux Installation and Getting
Started'', to Ian Jackson, the author of ``Linux frequently asked questions
with answers'', to Giuseppe Zanetti, the author of the book ``Linux'', to
all the folks who emailed me suggestions, and especially to Linus Torvalds
and GNU who gave us Linux.

Feedback is welcome. For any requests, suggestions, flames, etc., feel free
to contact me.

Enjoy Linux and life,

Guido   <tt>=8-)</tt>

</article>
