<!doctype linuxdoc system>

<!-- LyX 1.1 created this file. For more info see http://www.lyx.org/ -->
<article>
<title>
Wireless Howto
</title>
<author>
Roberto Arcomano berto@fatamorgana.com
</author>
<date>
v1.6 - July 31, 2002
</date>
<abstract>
Wireless is a new technology in networking cards, with high speed rate
 (up to 11 Mbps). This document explains how to setup Wireless in Linux, compatibility
 problems, something about geographic requirements and more. Latest release
 of this document can be found at <url url="http://www.fatamorgana.com/bertolinux" name="http://www.fatamorgana.com/bertolinux">
</abstract>
<toc>
<sect>
Introduction 
<sect1>
Introduction 
<p>
This document explains something about Wireless networking, how to setup
 it, problems with it. Unliked wired network, Wireless requires some additional
 trick to work well. You should know something about antennas, pointing it,
 roaming info and so on. Feedback are welcome. You can found more interesting
 help at <url url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux" name="Jean Tourrilhes Wireless Howto">
</p>
<p>
For any suggestion and feedback write to my <url url="mailto:berto@fatamorgana.com" name="email address">
</p>
<sect1>
Copyright 
<p>
Copyright (C) 2000,2001 Roberto Arcomano.
</p>
<p>
This document is free; you can redistribute it and/or modify it under the
 terms of the GNU General Public License as published by the Free Software Foundation;
 either version 2 of the License, or (at your option) any later version. 
</p>
<p>
This document is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 You can get a copy of the GNU GPL <url url="http://www.gnu.org/copyleft/gpl.html" name="here">
</p>
<sect1>
Translations
<p>
If you want to translate this document you are free, you only have to:
 
</p>
<p>
<enum>
 <item>
Check that another version of it doesn't already exist at your local LDP
 <item>
Maintain all 'Introduction' section (including 'Introduction', 'Copyright',
 'Translations', 'Credits').
</enum>
</p><p>
Warning! You don't have to translate TXT or HTML file, you have to modify
 LYX file, so that it is possible to convert it all other formats (TXT, HTML,
 RIFF, etc.): to do that you can use "LyX" application you download from <url url="http://www.lyx.org" name="http://www.lyx.org">.
</p>
<p>
No need to ask me to translate! You just have to let me know (if you want)
 about your translation.
</p>
<p>
Thank you for your translation!
</p>
<sect1>
Credits
<p>
Thanks to <url url="http://www.fatamorgana.com" name="Fatamorgana Computers"> for hardware equipment and experimental opportunity.
</p>
<p>
Thanks to <url url="http://www.linuxdoc.org" name="Linux Documentation Project"> for publishing and uploading my document in a very quickly fashion.
</p>
<sect>
Background Knowledge 
<sect1>
What about Wireless?
<p>
Wireless is a new technology that can help you to connect computers at
 distance. It works with Wireless cards with a TX/RX inside at 2.4 GHz while
 the software interface is Ethernet-like, with an hardware address different
 for each card in the world. Typical transmit power is 10-20 mW till 100mW (see
 standard IEEE 802.11 and FCC/CEPT licenses).
</p>
<sect1>
What's the max distance between radio cards? 
<p>
The most important thing in Wireless communications is the line of sight
 clear: you MUST SEE (with eyes or with a binocular) the antenna from the other
 end or you can have (at most) a little tree between them. 
</p>
<p>
The distance depends on the antenna and (eventually amplifier) used: 2-300
 meters with a omnidirectional antenna; 1 km with a directive one; 2-3 km with
 a omnidirectional amplified (200mW); some km with parabolic antenna. 50-60
 km with parabolic or directive antenna amplified (some Watts). 
</p>
<p>
Be aware that it is not always legal to amplifier Wireless cards, cause
 you could violate FCC/CEPT (and also your country relative) specifics.
</p>
<sect1>
What's the difference between wired and Wireless network? 
<p>
Wired networks are very simple to setup (at least at low level). Wireless
 networks are very difficult to setup, to manage, to debug... Typical problem
 with wired networks like hardware install, software install, debug and so on
 become very critical with Wireless: 
</p>
<p>
<enum>
 <item>
You have to choose the right Wireless card: there are many cards from many
 vendor with many requirement and specs. If you want to create a little LAN/WAN
 you have to buy IEEE 802.11 compliant Wireless cards with an Access Point.
 
 <item>
Many cards are PCMCIA, so you have to install pcmcia Linux source first.
 
 <item>
You have to test it with 2 running systems, first at very short distance,
 then you can get far. 
 <item>
You should test it at any weather (typically rain). 
 <item>
Finally be happy for setting up. 
</enum>
</p><p>
If you installed a repeater (Linux box that has many Wireless and wired
 cards) you may have problem editing its configuration at distance!
</p>
<sect1>
What I need to know to setup a Wireless network? 
<p>
There are a number of requirement to setup a Wireless network; 
</p>
<p>
<verb>
software requirement: 
</verb>
<p>
<enum>
 <item>
Generic network knowledge like IP address, netmask, routing... covered
 by generic Linux NET3-4-HOWTO; *
 <item>
Specific network knowledge like proxy arp, bridging, proc fs, contained
 in Proxy-ARP-Subnet, Bridge Mini-Howto and in Linux Kernel Source (2.2.x or
 2.4.x) under Documentation/networking/ ip-sysctl.txt) *
 <item>
Wireless network knowledge like access mode (ADHOC, INFRASTRUCTURE and
 ACCESS POINT), channel concept, outdoor and indoor defines and so on that you
 can find in any document concerning Wireless: IEEE standard 802.11, CEPT, etc.
 
</enum>
<p>
<verb>
non software requirement: 
</verb>
<p>
<enum>
 <item>
Minimal experience in antennas, physical mounting, pointing
 <item>
Pc hardware installation with particular attention to not produce interference
 between different Wireless Cards (if required). 
</enum>
</p><p>
finally a great luck!
</p>
<p>
* All Howtos needed by this document can be retrieved from <url url="http://www.linuxdoc.org" name="http://www.linuxdoc.org">
</p>
<sect1>
Why should I setup a Wireless network and what I expect from it? 
<p>
Why? Because you're not satisfied of wired network! 
</p>
<p>
With Wireless cards you can go across garden, parks, houses, (but you MUST
 SEE the other end!). 
</p>
<p>
High Level Protocol used in Wireless Cards are the same used in Ethernet
 cards: TCP/IP over Wireless Ethernet-like but make attention to Windows Sharing
 Application, cause if you use Linux to forward, you are warned that a ip forwarder
 doesn't let pass through broadcast messages (see more on NetBIOS protocol):
 in this case you should use a WINS server to support Network Browsing (see
 Samba doc). 
</p>
<p>
Wireless let you create a little LAN/WAN with a central point of access
 (maybe with Internet Access!) and give access to anyone by air! 
</p>
<p>
Imagine a country all cabled by radio machines. 
</p>
<p>
Imagine a network that can connect all country people together, sharing
 files, audio applications, video applications at high bandwidth (like cable
 network). 
</p>
<p>
All that can be done (and it's already done in some country) using Wireless
 cards with Wireless Access Point and Wireless Linux Boxes that can operate
 as repeater (at IP level such as router or, if you want, at data-link level,
 with bridge driver, see more at <url url="http://openrock.net/bridge" name="Bridge Http Link"> or <url url="ftp://openrock.net/bridge" name="Bridge Ftp Link">
</p>
<sect1>
What Wireless cards are covered by this howto? 
<p>
In this howto I start with a generic configuration (to introduce Wireless
 networking), then I describe an example for each card I knew directly, with
 some trick you can use to improve its performance. 
</p>
<p>
<verb>
Wireless Card list: 
</verb>
<p>
<enum>
 <item>
Proxim Symphony -<htmlurl url="http://www.proxim.com" name="http://www.proxim.com">
 <item>
Webgear AviatorPRO 2.4 (pcmcia support needed) - <htmlurl url="http://www.webgear.com" name="http://www.webgear.com">
 <item>
Lucent Wavelan I, II, Orinoco - <htmlurl url="http://www.lucent.com" name="http://www.lucent.com"> and <url url="http://www.orinocowireless.com" name="http://www.orinocowireless.com">
 <item>
Cabletron - <htmlurl url="http://www.cabletron.com" name="http://www.cabletron.com">
 <item>
YDI am930_isa - <htmlurl url="http://www.ydi.com" name="http://www.ydi.com">
 <item>
Siemens Radio Modem (Dect) - <htmlurl url="http://www.siemens.com" name="http://www.siemens.com">
 <item>
RadioLan (5 GHZ) - <htmlurl url="http://www.radiolan.com" name="http://www.radiolan.com"> 
</enum>
</p><p>
For a very more exhaustive list see <htmlurl url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux" name="Jean Tourrilhes Wireless Howto">. 
</p>
<p>
Siemens Radio Modem is not a really 802.11 Wireless card, they are modems
 that you can attach to serial and they act as modem (at 1800 MHz, so DECT technology).
 Appendix B describe their use. 
</p>
<p>
RadioLan cards work at 5.4GHz in a Windows 9x environment and with a RadioLan
 Access Point that bridges between Wired and Wireless networks (there are no
 Linux driver as I know).  
</p>
<sect1>
How much do they cost? 
<p>
Wireless cards listed above are very low expansive: they start from very
 few hundred of dollars up to some thousand of dollars for Access Point that
 have 2 Wireless card (Lucent, for example) that can act as a bridge. 
</p>
<sect>
Technical info about Wireless 
<p>
Here I report some technical info to understand basic Wireless environment.
 
</p>
<sect1>
Physical Layer 
<p>
At first layer ISO/OSI we can have 3 kind of spec: 
</p>
<p>
<enum>
 <item>
FHSS, Frequency Hopping Spread Spectrum 
 <item>
DSSS, Direct Sequence Spread Spectrum 
 <item>
Infrared connections, not covered by this howto
</enum>
</p><sect1>
Configurations 
<p>
2 types of configurations: 
</p>
<p>
<enum>
 <item>
AdHoc mode (also called Independent mode), where you have independent networks
 with a BSS (Basic Service Set) each one. Each station has the same BSS. 
 <item>
Infrastructure mode, where a number of networks (with a BSS each one) can
 communicate each other by means of an Access Point (one for each BSS) to create
 a ESS (Extended Service Set). Also there is a roaming function letting a station
 &quot;attach&quot; to the nearer Access Point. 
</enum>
</p><p>
Adhoc is the simpler method (and the also the less scalable) and let many
 hosts communicate each other directly. The restrictive requirement is that
 all one are to be visible directly to reach a complete coverage of the network.
 (at least Ideally, because this problem could be solved at IP level! For more
 see Par 5.4).
</p>
<p>
<verb>
                                 Adhoc mode 

                               A - - - - - C
                                 &bsol;       /
                               |   &bsol;   /   |
                                     /&bsol;
                               |   /    &bsol;  |
                                 /       &bsol;
                               B - - - - - D
</verb>
</p><p>
In a Infrastructure environment you use the Access Point to which ALL other
 hosts must connect to share the network. 
</p>
<p>
<verb>
Infrastructure mode 
                                    ESS
 
          A - - - | - Access Point - -  Access Point - | - - - D
 
          B - - - |   BSS1                   BSS2      | - - - E
 
          C - - - |                                    | - - - F
</verb>
</p><p>
B and C could not see D,E and F, but they can communicate as well cause
 all one are using the same ESS. Important: A,B and C could also not see each
 other. 
</p>
<p>
In addition there are terms like indoor and outdoor to distinguish short
 area coverage from long area coverage. 
</p>
<sect1>
Compatibility 
<p>
Keep on mind that there are a number of Wireless cards in the world, but
 not every card can communicate with every other one. For talking together the
 cards have to use to: 
</p>
<p>
<enum>
 <item>
same configuration mode: all Adhoc or all Infrastructure 
 <item>
same physical layer: all DSSS or all FHSS 
 <item>
same protocol (for example Proxim has its particular proprietary protocol
 OpenAir that cannot talk with other FHSS cards). 
</enum>
</p><sect1>
Should I use Adhoc or Infrastructure? 
<p>
Access Point are very useful and killing problem but they are expansive.
 Ideally, for a more concentrated network you could use Infrastructure mode,
 while for few hosts you can choose Adhoc: why to spend much money for few hosts?
 
</p>
<p>
Anyway be aware that if you spend much money probably all works well while
 spending less you could have some trouble.  
</p>
<sect1>
A Linux Box cannot act as an AccessPoint? 
<p>
Good asking! 
</p>
<p>
Recently there is a kind of hardware that allows this feature: Prism2
</p>
<p>
You can find something at <url url="http://people.ssh.com/jkm/Prism2/" name="http://people.ssh.com/jkm/Prism2/">
</p>
<sect>
Toolbox required 
<sect1>
Hardware requirement 
<p>
You need a Linux Box (486 or, better, a Pentium 100+ with 16MB+ ram), the
 Wireless network card, an antenna (see par 2.2). You need the same on the other
 end (with Win9x or WinNT, if you prefer...) cause you have to simulate a communication!
</p>
<sect1>
Software requirement 
<p>
You need: 
</p>
<p>
<enum>
 <item>
recent stable kernel sources (2.2.x) 
 <item>
recent stable pcmcia sources (pcmcia-cs) if you bought a pcmcia card 
 <item>
Wireless network driver: if you don't have it you can download it from
 the vendor web site or the card manufacturer web site. If you don't find it
 you can search at <htmlurl url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux" name="Jean Tourrilhes Wireless Howto">. 
</enum>
</p><p>
If you don't find even here you probably have to wait or to convert a Windows
 driver to a Linux driver!! (good luck!).
</p>
<p>
After that, you have to recompile your kernel, recompile your pcmcia source
 (if need by the Wireless card), finally recompile your Wireless driver. That
 is the generic situation, maybe for some card you have to perform step 3 only
 or 1 and 3, it depends on specific driver. 
</p>
<sect>
Overview on Wireless network setup.
<sect1>
Fundamental steps 
<p>
Once you have got the needed material and you have compiled all the needed
 you should do the fundamental step in a Wireless configuration: 
</p>
<p>
<enum>
 <item>
Low level kernel config Let the Linux Kernel see your Wireless card (at
 low level, such as ioport, interrupts, dma...): you must see some kind of kernel
 message that advertise you that Wireless card has been right found and configured.
 
 <item>
Data-link level setting For each particular Wireless card there is an utility
 that can set typical Wireless data-link level value. For example in Proxim
 Symphony the utility is called &quot;rl2cfg&quot; while in pcmcia cards settings
 are in pcmcia config files. You have to set all your Wireless cards with coherence
 to make them talk together. 
 <item>
Ip setting Now you should be able to use ifconfig and route capabilities
 to change IP settings.
 <item>
Tricks for better performance and to a avoiding conflicts. Now your Wireless
 Network is basically working: in addition you have to adjust some particular
 setting like proxy-arp, icmp echo redirect, bridging, channel change and so
 on to optimize your network and avoiding strange and bandwidth killing conflicts
 
</enum>
</p><p>
N.B.: step 1, 2 and 3 correspond to level 1, 2 and 3 of standard ISO/OSI,
 while step 4 is an addendum to solve situation generated by netmask 255.255.255.255.
 In fact 32 bit netmask violates standard ISO/OSI cause the network force to
 use the same address for broadcast and ip machine and the network address doesn't
 exist. 
</p>
<p>
Someone could criticize this point of view, but if you use the standard
 ISO/OSI to configure Wireless network with you'll loss many ones configuring
 subnets; for each subnet usually you discard 2 IP number (Network and broadcast)
 and you cannot achieve the flexibility on IP assigning (geographically kind).
 You can find more on Appendix A about this. 
</p>
<p>
You could notice that step 2 is not present in Wired cards cause there's
 no particular settings to do there.
</p>
<sect1>
Low Level Kernel Config 
<p>
Always it's a problem for Pc administration: to let kernel (or in general)
 see your hardware. 
</p>
<p>
Wireless cards are more complex because many of them usually have a Pcmcia
 plug, so first of all you have to let your kernel see Pcmcia adapter card,
 then you can try to install specific hardware driver for your Wireless card.
 
</p>
<p>
<verb>
So, in Pcmcia config you have to: 
</verb>
<p>
<enum>
 <item>
install linux kernel source, from <htmlurl url="http://www.kernel.org" name="http://www.kernel.org"> to /usr/src/linux (see tar and gzip
 utilities) 
 <item>
install linux pcmcia source, from <htmlurl url="ftp://projects.sourceforge.net/pub/pcmcia-cs" name="ftp://projects.sourceforge.net/pub/pcmcia-cs"> to install to /usr/src/pcmcia (see tar
 and gzip utilities)
 <item>
config and recompile your kernel: read file README in your linux directory
 (/usr/src/linux)
 <item>
config and recompile your pcmcia source: under /usr/src/pcmcia use configure
 and make. Be sure your driver is here, else your have to install it following
 driver instructions (usually a tar zxvf driver.tgz under pcmcia dir is sufficient).
 After type &quot;make all&quot; to compile. At the end type &quot;make install&quot;.
 
 <item>
After typed install you'll find some useful config files under /etc/pcmcia
 .
</enum>
<p>
<verb>
In non pcmcia case: 
</verb>
<p>
<enum>
 <item>
If your driver is present (99&percnt; not) under linux sources, you have
 to install it in a directory, then to compile it. 
</enum>
</p><p>
Once you know module name you have to load it: in pcmcia config you only
 need to start pcmcia daemon (/etc/rc.d/init.d/pcmcia start for RedHat), for
 other &quot;modprobe module_name options&quot;. With options you'll give ioport,
 irq and data-link settings (see Par 5.3) to Wireless driver. Anyway your useful
 tools to know if hardware has correctly been seen by driver are: 
</p>
<p>
<enum>
 <item>
&quot;tail /var/log/messages&quot; that explains info about syslog 
 <item>
&quot;dmesg&quot; for more info. 
 <item>
/proc dir: ioports, devices, irq files and driver specific sub-directories.
</enum>
</p><sect1>
Data-link level setting 
<p>
<verb>
What is that? 
</verb>
</p><p>
Wired networks need only to connect each other and then you'll be able
 to set TCP/IP parameters. 
</p>
<p>
In opposite Wireless networks need data-link settings, such as: 
</p>
<p>
<enum>
 <item>
What kind of Wireless network I belong to? (Adhoc or Infrastructure) 
 <item>
What channel I have to use? 
 <item>
What subnet (BSSID) I belong to, what is my ESS ID? 
 <item>
Is my communication protected by such a encryption algorithm? Length key?
 
</enum>
</p><p>
As you see there are many settings you have to adjust, the reason come
 from the architecture of Wireless network: there could be someone, in near
 distance, that could see your packets, use your services only pointing his
 antenna on the right direction and setting up right TCP/IP parameters. 
</p>
<p>
In addition there could be many Wireless subnets that could generate interference
 each other. 
</p>
<p>
So here are: 
</p>
<p>
<enum>
 <item>
Options at load-time module: &quot;modprobe ray_cs essid='LINUX'&quot;
 for example or
 <item>
Utilities at run-time driver: &quot;rl2cfg eth1 master&quot;. 
</enum>
</p><sect1>
Ip setting 
<p>
This is the third problem you have to face. Here situation become problematic
 only when your network begin to evolve in a bigger one. 
</p>
<p>
<verb>
Remember Wireless IP Networking doesn't stress you if you don't stress it! 
</verb>
</p><sect2>
A simple configuration 
<p>
<verb>
                       All the hosts view each other
 
                               A - - - - - C
                                 &bsol;       /
                               |   &bsol;   /   |
                                     /&bsol;
                               |   /    &bsol;  |
                                 /       &bsol;
                               B - - - - - D

</verb>
</p><p>
A configuration like this is very simple and don't require nothing special
 (at Ip level): you only need to assign an IP address for each host and to assign
 a coherent global netmask.  
</p>
<sect2>
A more complex configuration 
<p>
<verb>

                       A doesn't see B directly
 
                                A &lt;- - - -
                              NO&bsol;        |
                            TALK&bsol;        C
                                &bsol;        |
                                B &lt;- - - -
 
</verb>
</p><p>
Here A and B can communicate only passing through C. 
</p>
<p>
If the network is in Infrastructure mode and C is the Access Point all
 is ok. In Adhoc mode you also can design a host to &quot;master&quot; capability
 (I know the term is not so formal!), a host that creates a BSS and to which
 any other host can join that BSS. 
</p>
<p>
Full connectivity now is reached at IP level: A and B talk to C using the
 same C interface, so if you try to ping from A to B you'll receive many ICMP
 REDIRECT packets from C, cause C is telling A that the destination is already
 in the network from which come the request. 
</p>
<p>
Solution: type a &quot;echo 0 &gt; /proc/sys/net/ipv4/conf/ethx/send_redirects&quot;
 (where ethx is the interface on C towards A and C) to null all that. 
</p>
<p>
Another problem: what netmask I assign to A and C? If you assign a netmask
 to A that include A and C nothing works because A don't use the gateway (C)
 but make the ARP request with unknown destination MAC address. 
</p>
<p>
You could think to use proxy arp, but without effect cause proxy arp reply
 to source only when the destination is in a different interface from the source:
 this is not the case!! 
</p>
<p>
So you have to set a very little netmask (Win9x let it be 255.255.255.254,
 WinNT at least 255.255.255.248), and you have to assure that hosts A and C
 don't have the same net address. 
</p>
<p>
<verb>
Examples: 
</verb>
<p>
<enum>
 <item>
IP(A) = x.y.z.2/31, IP(B) = x.y.z.3/31. This doesn't work cause A asks
 for B in its network (ARP request) and C doesn't answer cause, for it, A and
 B belong to the same interface (so, no proxy arp). 
 <item>
IP(A) = x.y.z.1/31, IP(B)= x.y.z.2/31. This works cause A ask to C (send
 requests to B with C MAC address) for B. 
</enum>
</p><p>
In general with a netmask 255.255.255.254 system works with 2 IP changing
 only for the final bit. 
</p>
<p>
All that is a TCP/IP forcing but is the only method to obtain an high level
 of flexibility. 
</p>
<p>
Note: If you use an Access Point (network in Infrastructure mode) you haven't
 redirect problem, cause all is solved at data-link level (almost every Access
 Point acts as a bridge...). But Access Point are expansive (about 1000 USD
 or more) and it is more economic to use a P133 32MB Ram to forward, even with
 2 or more cards.
</p>
<sect2>
Internet Access 
<p>
<verb>
                               A - - - - - C - - Internet
                                 &bsol;       /
                               |   &bsol;   /   |
                                     /&bsol;
                               |   /    &bsol;  |
                                 /       &bsol;
                               B - - - - - D
 
</verb>
</p><p>
There is a number of situation:
</p>
<p>
<enum>
 <item>
C is the only Public IP address. You only have to set private IP address
 (192.168.x.y for example) for the Wireless network enabling, on C, forwarding
 and masquering. A, B and D will have C as default GW. 
 <item>
You have a public netmask visible from Internet and C is your default GW
 to Internet for the network. You only need to enable forwarding on C, setting
 up default GW on A, B and D to point to C. 
 <item>
You have a public netmask visible from Internet and C is not the default
 GW to Internet. You have 2 possible solutions: Modify your default GW to let
 it point to C for your network. Symmetrically you have to let C point to default
 GW to go to Internet. You could, instead, enable proxy arp feature to C (echo
 1 &gt; /proc/sys/net/ipv4/conf/ethx/proxy_arp where ethx is the interface towards
 the default GW) and set your default GW on C to point to the default GW. Proxy
 arp is a TCP/IP forcing but works well.
</enum>
</p><sect2>
Mixed network: Wired and Wireless 
<p>
<verb>
                                Internet         
                                       &bsol;      
                                        &bsol;        E
                                         &bsol;     /
                                          &bsol;  /       Wireless
                               A - - - - - C - - F
                                 &bsol;       /   &bsol;
                               |   &bsol;   /   |   &bsol;
                        Wired        /&bsol;          G
                               |   /    &bsol;  |
                                 /       &bsol;
                               B - - - - - D
 
</verb>
</p><p>
Now C joins 2 networks: on the right Wireless and Wired on the left. 
</p>
<p>
More you have Internet Access, so in total you have 3 network cards in
 C. 
</p>
<p>
What IP Address I assign to hosts? You have 2 possible solutions: 
</p>
<p>
<enum>
 <item>
Split up network in 2 subnets: for example 192.168.1.0/24 and 192.168.2.0/24.
 This solution is quickly but is not scalable if you are using Internet IP addresses
 cause you have to drop too many IPs. 
 <item>
Enable Proxy Arp feature to C for all 2 interfaces. Network parameters
 (net address and netmask) are the same for Wireless and Wired, but with proxy-arp
 enabled I can choose which IPs are on Wired and which on Wireless. 
</enum>
<p>
<verb>
Now we examine solution 2
</verb>
</p><p>
For example: Consider you have Internet public subnet x.y.z.0/24.
</p>
<p>
<verb>
Interfaces are:
</verb>
<p>
<enum>
 <item>
ifconfig eth0 x.y.z.C netmask 255.255.255.255 (Wired) 
 <item>
ifconfig eth1 x.y.z.C netmask 255.255.255.255 (Wireless) 
 <item>
ifconfig eth2 x.y.z.C netmask 255.255.255.255 (to Internet) 
</enum>
<p>
<verb>
Static routes on eth2:
</verb>
<p>
<enum>
 <item>
route add IPGW dev eth2 
 <item>
route add default gw IPGW 
</enum>
</p><p>
This route stands for addressing all Internet requests to your Default
 GW: as you notice, first you have to tell Linux where is the router, then let
 default requesting through it.
</p>
<p>
<verb>
Static routes on eth0:
</verb>
<p>
<enum>
 <item>
route add x.y.z.A dev eth0 
 <item>
route add x.y.z.B dev eth0 
 <item>
route add x.y.z.D dev eth0 
</enum>
</p><p>
Hosts A,B and D on the Wired Network
</p>
<p>
<verb>
Static routes on eth1:
</verb>
<p>
<enum>
 <item>
route add x.y.z.E dev eth1 
 <item>
route add x.y.z.F dev eth1 
 <item>
route add x.y.z.G dev eth1 
</enum>
</p><p>
Hosts E,F and G on the Wireless Network
</p>
<p>
Note that flexibility is very high, but you have to manual set each host.
 
</p>
<sect>
Setup 
<p>
Here I report some examples (I hope useful!) on how to configure more diffuse
 and not expansive Wireless Cards. 
</p>
<sect1>
General setup info 
<p>
Wireless cards have interface similar to any Ethernet cards, so you have
 to add in /etc/conf.modules: 
</p>
<p>
<enum>
 <item>
&quot;alias ethx module&quot;, where ethx is the interface you want to
 assign to your wireless card and module is name of kernel module. 
 <item>
&quot;options module io=0xAAA irq=I ...&quot;, where 0xAAA is the io base
 address to assign the card, I is the IRQ and so on if there are other parameters.
 
</enum>
</p><p>
After this you'll be able to use ifconfig and route commands to configure
 your card at IP level. 
</p>
<sect1>
Proxim Symphony 
<p>
Network type: FHSS, Adhoc only and with proprietary protocol OpenAir. 
</p>
<p>
Web site:<htmlurl url="http://www.proxim.com" name="http://www.proxim.com"> where you need to download documentation and driver for Linux
 and Win9x. 
</p>
<p>
Drivers come with source code to compile: 
</p>
<p>
<enum>
 <item>
untar it in a empty directory 
 <item>
type make for help. 
 <item>
make modules; make modules_install to install the driver rlmod.o and the
 utility rl2cfg.  
 <item>
to run the driver (after modified /etc/conf.modules: see Par.6.1.) you
 only need to turn up the interface with ifconfig command. 
</enum>
</p><p>
Utility rl2cfg (for help type man rl2cfg once done c step) let you change
 typical data-link level settings: 
</p>
<p>
<enum>
 <item>
&quot;rl2cfg dev ethx sta&quot; to set it to station (Slave) 
 <item>
&quot;rl2cfg dev ethx msta&quot; to set it to master station (Master) 
 <item>
&quot;rl2cfg dev ethx alt&quot; to set it to automatically mode 
</enum>
</p><p>
This is all you have to know to get it properly working.
</p>
<sect1>
Webgear Aviator 2.4 and AviatorPro 
<p>
Network type: FHSS, Adhoc only for Aviator 2.4 and Infrastructure for AviatorPro.
</p>
<p>
These cards need more for working, because you have to compile Pcmcia source
 as they come with Pcmcia plug. 
</p>
<p>
Web site is <htmlurl url="http://www.webgear.com" name="http://www.webgear.com">. 
</p>
<p>
To configure:
</p>
<p>
<enum>
 <item>
You have to download source pcmcia and to expand it to /usr/src/pcmcia
 (see Par 5.2)  
 <item>
Download driver form <htmlurl url="http://www.webgear.com" name="http://www.webgear.com"> and type &quot;tar zxvf driver.tgz&quot; in /usr/src/pcmcia
 directory. 
 <item>
reconfig pcmcia (see Par 5.2) 
 <item>
Following instructions you have to append to file /etc/pcmcia/config.opts
 entry &quot;source ./ray_cs.opts&quot;.  
 <item>
Note that in /etc/pcmcia/ray_cs.opts there is a line like this: &quot;module
 &quot;ray_cs&quot; opts &quot;...&quot;. Here you have to modify some settings
 at data-link level present in "opts" .
</enum>
<p>
<verb>
Arguments: 
</verb>
<p>
<itemize>
 <item>
pc_debug=x , where x is the log level. 
 <item>
net_type=x, x=0 for AdHoc, x=1 for Infrastructure. 
 <item>
essid=x, x is the ESSID
</itemize>
</p><p>
Finally, to verify configuration with pc_debug &gt; 0, you will see data-link
 messages in your console like these: &quot;network started&quot; for a new
 Wireless network created and &quot;network joined&quot; for a new Wireless
 network joined to another one. 
</p>
<p>
Also File /proc/ray_cs can help you: flied BSSID report to which Subnet
 you belong to, if it is null you can receive data from no one cards. 
</p>
<sect1>
Lucent Wavelan I, II, Orinoco products and Cabletron 
<p>
Network type: DSSS, Adhoc and Infrastructure. 
</p>
<p>
Lucent products are very professional ones. 
</p>
<p>
Web site: <htmlurl url="http://www.lucent.com" name="http://www.lucent.com"> and <htmlurl url="http://www.orinoco.net" name="http://www.orinoco.net">. 
</p>
<p>
Setup is like WebGear-like: step 1,2,3 are similar 
</p>
<p>
Then you have to add to file /etc/pcmcia/config.opts: module &quot;wavelan_cs&quot;
 opts &quot; ...&quot; for Lucent Wavelan I module and &quot;wavelan2_cs&quot;
 opts &quot; ...&quot;, for Lucent Wavelan II or Orinoco. 
</p>
<p>
Under opts you will specify: 
</p>
<p>
<enum>
 <item>
port_type=x, where x indicates Adhoc(3) or Infrastructure(1) 
 <item>
channel=x, x=channel, option relevant for AdHoc mode only. 
 <item>
transmit_rate=x, to fix the speed rate: attention to this setting for compatibility
 with Cabletron cards. 
</enum>
</p><p>
Note: Ideally, it is possible in a Linux Box to have 2 Lucent Wavelanx
 cards, one in Adhoc mode and the other in Infrastructure mode. Only one of
 them could properly works because, when starting pcmcia service, all 2 cards
 are set with same opts value (so in Adhoc or Infrastructure mode). So we have
 to create a Linux module (or maybe a user mode program) that can change data_link
 parameters at run-time such as access mode and channel used in Adhoc mode!
 
</p>
<p>
The channel parameter is usually used to avoid interference with near other
 Wireless TX/RX. 
</p>
<p>
Lucent drivers could also be used for Cabletron cards <htmlurl url="http://www.cabletron.com" name="http://www.cabletron.com">
</p>
<sect1>
YDI 
<p>
Network type: DSSS, Adhoc and Infrastructure. 
</p>
<p>
YDI sells very professional cards with antennas, amplifiers and more. 
</p>
<p>
Web-site <htmlurl url="http://www.ydi.com" name="http://www.ydi.com"> 
</p>
<p>
<verb>
To install: 
</verb>
<p>
<enum>
 <item>
untar it in a empty directory.
 <item>
type make for compile. 
 <item>
make install to install the driver am930_isa and the wlanctl utility
</enum>
</p><p>
Once done you can choose if type manual commands using "wlanctl" data-link
 utility or run the "scripts/wlan" file or "scripts/rc.wlan" file to automatically
 config your network. 
</p>
<p>
In manual case these are major settings: 
</p>
<p>
<enum>
 <item>
&quot;wlanctl scan ...&quot; to search for BSSs already present. 
 <item>
&quot;wlanctl netlist&quot; show you what's found with &quot;wlanctl scan
 ...&quot;. 
 <item>
&quot;wlanctl bsscreate ... ssid&quot; to create a new network with ssid
 parameter. 
 <item>
&quot;wlanctl bssjoin bssid&quot; to join the network identified by bssid.
 
 <item>
&quot;wlanctl authen&quot; and &quot;wlanctl assoc&quot; for authentication
 services.
</enum>
</p><sect>
More about Wireless
<sect1>
A Wireless Linux distribution
<p>
The wireless distribution FlyingLinux started in October 1999 in the Telecommunication
 Systems Lab at Teleinformatics KTH with the objective of studying the possibilty
 of using MobileIPv4 and standard DHCP-based wireless access for student labs.
 
</p>
<p>
The result of that work was the FlyingLinux environment available for one
 hundred students and teachers during the 2G1303 project course that was held
 from March to May year 2000. 
</p>
<p>
FlyingLinux is the first linux distribution oriented to mobility services.
 We have taken care of the security issues including Kerberos support and OpenSSH.
 
</p>
<p>
FlyingLinux is part of the Open Source movement. We have included software
 that have been developed at KTH under the GPL licence. 
</p>
<p>
You can find the Wireless Linux distribution at this <url url="http://www.flyinglinux.net" name="Web Site">.
</p>
<p>
Mantainer: Alberto Escudero <url url="mailto:aep@it.kth.se" name="Email">, <url url="http://www.it.kth.se/~aep" name="Home Page">
</p>
<sect>
Useful links
<sect1>
Open software link
<p>
<itemize>
 <item>
<url url="http://www.linux-wlan.org/" name="Linux-wlan project">
 <item>
<url url="http://www.hpl.hp.com/personal/Jean_Tourrilhes/Linux" name="Jean Tourrilhes Wireless Howto">
</itemize>
</p><sect1>
Commercial link
<p>
<itemize>
 <item>
<url url="http://www.fatamorgana.com" name="Fatamorgana Computers">
 <item>
<url url="http://www.lucent.com" name="Lucent web site">
 <item>
<url url="http://www.ydi.com" name="YDI web site">
 <item>
<url url="http://www.siemens.com" name="Siemens web site">
</itemize>
</p><sect>
FAQ - Frequently asked questions 
<p>
Q1: What's the difference between BSSID and ESSID and when I need a ESSID?
 
</p>
<p>
A1: BSSID is 48 bit number used to identify the BSS short area, where all
 hosts talk each other (eventually with an Access Point) ESSID is a variable
 length string that can let communicate different BSS are to extend it to a
 Extended Service Set (ESS). There is one Access Point for each BSS and all
 they talk together only if you belong to the same ESSID. Really you need ESSID
 if you have a large network with at least 2 Access Points. 
</p>
<p>
Q2: What Access Point I have to buy? 
</p>
<p>
A2: The less expansive you find: what is important is that the Access Point
 and the cards you are using use the same Physical Layer Specific: all FHSS
 compatible or all DSSS compatible. Attention to Proxim RangeLan2 cards that
 cannot talk with other standard FHSS because they use the proprietary protocol
 OpenAir. 
</p>
<p>
Q3: What do I use the channel setting for? 
</p>
<p>
A3: When you have more network with different BSS (and with different vendors)
 you could have interference problem: changing channel on Access Points or in
 Adhoc mode hosts could help you avoiding this kind of problems. 
</p>
<p>
Q4: Why I cannot set channel on Infrastructure hosts? 
</p>
<p>
A4: Because the channel is decided by the Access Point. 
</p>
<sect>
Appendix A - Netmask 255.255.255.255, proxy arp and bridging 
<p>
Here we view some Linux advantages in Wireless Internetworking. 
</p>
<p>
Linux let you specify a netmask like 255.255.255.255 for an interface which
 can help you assign IP addresses in to any interface you want, for example
 one in eth0, another in eth1 and so on... 
</p>
<p>
This has not particularly side-effects. 
</p>
<p>
In addition you have proxy arp setting under /proc/sys/net/ipv4/conf/ethx/proxy_arp
 where ethx if your interface. 
</p>
<p>
If you &quot;echo 1 &gt; proxy_arp&quot; you enable proxy_arp for that
 interface while with &quot;echo 0 &gt; proxy_arp&quot; you disable it. 
</p>
<p>
What's proxy_arp? Quickly proxy arp help you when you want a router answer
 to an ARP request if the destination address is in another interface of the
 linux router. 
</p>
<p>
Example: 
</p>
<p>
<verb>
192.168.1.1 ---- 192.168.1.2 Linux router 192.168.2.2 ----192.168.2.1 
</verb>
</p><p>
To get this example working you should: 
</p>
<p>
<verb>
Without proxy-arp 
</verb>
<p>
<enum>
 <item>
In 192.168.1.1 host to set 192.168.1.2 as gateway 
 <item>
In 192.168.2.1 host to set 192.168.2.2 as gateway 
 <item>
pinging with success from any edge. 
</enum>
<p>
<verb>
With proxy-arp 
</verb>
<p>
<enum>
 <item>
In 192.168.1.1 host to set 192.168.1.2 as gateway 
 <item>
do not set gateway for 192.168.2.1 host but enable proxy_arp for right
 interface of the router. 
 <item>
pinging with success from any edge 
</enum>
</p><p>
Proxy-arp in 2. case let the linux router answer when you ping from 192.168.2.1
 host, saying that it has the 192.168.1.1 host so it can answer for it. After,
 when the source start sending ICMP packet, Linux router knows that it have
 to redirect it to the real host 192.168.1.1 
</p>
<p>
In Wireless network proxy arp can help you if you have many Linux boxes
 that acts as IP Forwarders and you wouldn't set to all hosts a number of static
 route. 
</p>
<p>
You also can experiment Linux bridging in Wireless network: 
</p>
<p>
<enum>
 <item>
install a recent stable kernel 
 <item>
download good bridge utils at <htmlurl url="http://openrock.net/bridge" name="http link"> or <htmlurl url="ftp://openrock.net/bridge" name="ftp link"> 
</enum>
</p><p>
Bridging should be more simple to manage. 
</p>
<sect>
Appendix B - Siemens DECT Radio Modem 
<p>
Web Site: <htmlurl url="http://www.siemens.com" name="http://www.siemens.com">
</p>
<p>
What's that? These 2 components are not real PC cards but are more like
 modems that you use as external device. 
</p>
<p>
<verb>
Host1-serial - RadioModem1 - - - - - RadioModem2 - serial-Host2 
</verb>
</p><p>
How can I connect it? 
</p>
<p>
If you see them in an abstract vision you can model them like this: 
</p>
<p>
<verb>
Host1-serial - - NULL MODEM CABLE - - serial-Host2 
</verb>
</p><p>
So you'd have a connection between 2 far serials with 2 possible configurations:
 
</p>
<p>
<enum>
 <item>
Linux with Windows, Linux has a daemon that answer to a ppp call while
 Windows has a Dial up connection under Remote Access. 
 <item>
Linux with Linux, where you can run (on all 2 hosts) a ppp connection,
 with IP addresses inverted. 
</enum>
</p><p>
For 1 you can use this simple script in Linux: 
</p>
<p>
&quot;/usr/sbin/pppd -detach lock idle 300 crtscts connect &quot;/usr/sbin/chat
 -v TIMEOUT 5 AT OK AT OK AT OK AT OK&quot; IPLINUX:IPWINDOWS /dev/ttySx 115200
 disconnect &quot;/usr/sbin/chat -v AT OK&quot; ms-dns IPDNS&quot; 
</p>
<p>
where: 
</p>
<p>
<itemize>
 <item>
/dev/ttySx is your serial port, 
 <item>
IPDNS is the IP address of your dns server, 
 <item>
IPLINUX is the Linux IP address as IPWINDOWS is the Windows IP address.
 
</itemize>
</p><p>
The above script is need for letting Windows believe there is a modem on
 the serial end! 
</p>
<p>
In Windows you need to create a Dial Up connection with crtscts enabled,
 speed at 115200 and with a stupid number to call (need by Remote Access but
 absolutely not used). 
</p>
<p>
With 2 Linux boxes you only have to run a very simple script like this
 at each Linux side: 
</p>
<p>
&quot;/usr/sbin/pppd passive local crtscts IPLINUX1:IPLINUX2 /dev/ttySx
 115200 noauth persist&quot; 
</p>
<p>
where you'll invert IPLINUX1 with IPLINUX2 at the other edge.
</p>
<p>
Note that you can do authentication even Linux-Windows than in Linux-Linux
 if you want.
</p>


</article>
