<!doctype linuxdoc system>

<article>

<title>Le Francophones-HOWTO : Linux &amp; la langue fran&ccedil;aise
<author>&Eacute;crit par Guylhem Aznar, &lt;<tt/guylhem(&agrave;)metalab.unc.edu/&gt;
<date>v3.2.2 ; Décembre 2001

<abstract>
Copyright &copy; 1997, 1998, 1999, Guylhem Aznar ; librement
distribuable selon les termes du GNU Free Documentation License,
<url url="http://www.fsf.org/licenses/fdl.html">.

Toutes les marques citées appartiennent à leurs propriétaires
respectifs.
</abstract>

<toc>

<sect>Présentation<p>

<sect1>Introduction<p>

Ce document a été rédigé pour aider à configurer un ordinateur doté du
système d'exploitation Linux pour des utilisateurs francophones.

Il y est expliqué par exemple comment configurer périphériques et
applications afin de prendre en compte les particularités et les
spécificités de notre langue...

Toutefois, ce document ne traite pas de l'installation du système
d'exploitation Linux ; il est implicitement supposé que vous ayez
correctement installé une distribution de Linux, RedHat, Debian ou
Suse, cette liste n'étant pas exhaustive, et que vous vous
apprêtiez maintenant à mieux la configurer ; veuillez donc vous
référer à d'autres HOWTOs pour l'installation.

Les adresses électroniques ont été volontairement supprimées ou
modifiées en remplaçant les « a enroulés » par des « (à) » afin d'éviter
les publipostages très gênants.

Si quelque terme employé vous semble un peu obscur, je vous invite à
vous reporter au lexique (« Vocabulaire : un petit lexique »),
expliquant certains mots tels 8 bits, AZERTY ou QWERTY, qui sont
employés tout au long de ce document.

<sect1>Fichiers utilisés dans ce HOWTO<p>

Tous les fichiers cités dans ce HOWTO, sont disponibles sous licence GPL
sur <htmlurl name="ma page" url="http://metalab.unc.edu/guylhem/">

Je vous recommande de télécharger tous ces fichiers pour les utiliser
selon les exemples proposés.

<sect1>Les Français ne sont pas les seuls francophones !<p>

<sect2>a) Différentes versions<p>

Pour chaque manipulation dépendant du pays concerné, un certain nombre
de versions peuvent être proposées :

<itemize>
<item>une canadienne normalisée (cn)
<item>une belge wallonne (be)
<item>une française (fr)
<item>une québécoise (qc)
<item>une suisse romande (sf)
<item>une états-unienne internationale (usx)
</itemize>

<sect2>b) Les états-uniens : raccourcis claviers<p>

La version états-unienne internationale permet à tous
les francophones utilisant un clavier « 7 bits » aussi nommé
« QWERTY » de bénéficier de l'étendue des caractères 8 bits.

Est disponible aussi une version pour ceux qui utilisent un
clavier « Happy Hacking ».

<sect2>c) Le Luxembourg : comme la France<p>

Le Grand Duché du Luxembourg utilisant les conventions françaises,
j'invite les lecteurs luxembourgeois à se reporter aux exemples
français.

<sect2>d) Le Canada : 3 claviers<p>

Il est classique de parler des claviers « canadien international »,
surtout destinés aux anglophones (qui leur préfèrent toutefois les claviers
QWERTY standard) et les claviers « canadien français », aux lettres
accentuées.

Mais, de nouveaux claviers dits « canadiens normalisés » ont fait leur
apparition récemment pour fusionner les modèles « canadien international
», non concerné par le cadre du Francophones HOWTO, et « canadien français ».

Ces nouveaux claviers répondent aux normes CAN/CSA Z243.200-92 et ISO
9995-7 ; ils sont prévus pour être utilisés dans n'importe quelle
langue, en remplaçant par exemple les intitulés des touches par des
pictogrammes : « Del », en anglais, qui se traduisait par « Suppr » en
français devient ainsi trois barres obliques fines orientées
sud-ouest/nord-est.

Plus d'explications sont disponibles sur le <htmlurl
name="site de l'Office de la Langue Française" url="
http://www.olf.gouv.qc.ca/technologies/technopages/claviernorm.html">.

Toutefois je n'ai pas pu réussir à me procurer un tel clavier ; mes
fichiers de configuration sont donc uniquement basés sur les
(<htmlurl name="illustrations"
url="http://www.olf.gouv.qc.ca/images/clavier.gif">) et les normes
théoriques, et non les normes pratiques.

Par exemple, si j'ai compris que la touche « Control » de droite est
utilisée comme une « AltGr » mais sert à obtenir encore d'autres
caractères, je n'ai aucune idée du comportement de ces touches lorsque
seule l'autre a une sérigraphie prévue...

Si on peut m'envoyer un tel clavier, et surtout son pilote, je promets
de mettre les fichiers de configuration à jour :-)

<sect1>Attention<p>

<sect2>a) ROOT<p>

Certaines manipulations recommandées par ce document ne peuvent
être effectuées que sous le compte privilégié « root » ; la plus grande
prudence est alors de rigueur car toute action inadéquate peut mettre en
péril le contenu des disques.

Sauvegarder les fichiers existants, par exemple en les copiant sous le
même nom suivi du préfixe .old, avant de les modifier ou remplacer.

<sect2>b) CHERCHER<p>

Le paquetage GNU nommé <sq>find</sq> offre un programme appelé
<tt/locate/, grâce auquel l'utilisateur peut retrouver le nom complet,
chemin de répertoires, d'un fichier dont il ne connaît que le nom.

Certaines distributions Linux fournissent cela en /usr/bin/locate.

En tant que root, lancer <tt>updatedb</tt> invoque un
<tt>find&nbsp;/</tt> sur les disques montés et place les noms de tous
les fichiers sous forme hash dans /usr/lib/locate/find.codes (ou
/var/lib/slocate/slocate.db pour slocate, utilisé dans les distributions
modernes.)

<tt/locate/ permet ensuite de localiser l'un d'eux :

<tscreen><verb>
	(guylhem@victis:guylhem)$ locate noms_des_fichiers_à_retrouver
</verb></tscreen>

<sect>Les problèmes<p>

<sect1>Présentation<p>

Le problème de tout utilisateur francophone après l'installation de
Linux est de lui faire comprendre qu'il utilise des normes différentes
des standards par défaut états-uniens..

Cela a des conséquences sur :

<itemize>
<item> la police de caractères donc les caractères spéciaux que l'on utilise,
accentués comme &Eacute; &Egrave; &Agrave; &Ccedil; ou bien ligaturés
comme &AElig; , voire « e dans l'o » qui vient d'apparaître sous Linux grâce à
la norme ISO-8859-15 aussi nommée latin-9
<item> la correspondance entre la sérigraphie des cabochons ou « touches » du clavier sur lesquelles vous appuyez, et les codes que Linux renvoie, celui-ci
supposant un clavier QWERTY états-unien par défaut
<item> le format de page pris en charge par les programmes que vous utilisez
pour imprimer, différent entre les &Eacute;tats-Unis; (14×8,5 pouces
pour du papier dit légal) et l'Europe (29,7×21 cm pour des feuilles a4)
<item> le format des dates et de l'heure, la position des jours et des
mois étant variable selon les régions de la francophonie
<item> le format de la monnaie, aussi variable selon les francophones
<item> la langue utilisée pour les messages d'erreur
</itemize>

<sect1>Solutions<p>

Tout est préconfiguré pour un états-unien : bien que ceux-ci ne
représentent pas la majorité de la population mondiale, ils ont été
précurseurs en informatique.

Il faut donc se faire reconnaître comme une « exception » par les
différents programmes, par des options ou des variables à exporter voire
dans les pires des cas une modification du code source suivie d'une
recompilation.

Heureusement, la philosophie GNU de Linux rend le système très ouvert
à des modifications de toutes sortes et comme vous allez le découvrir au
fil de ce document, et il est assez simple d'obtenir un résultat très
correct.

<sect1>Aider<p>

Pour le moment, le futur de l'internationalisation de Linux porte sur la
traduction des messages d'erreur, des programmes comme KDE ou GNOME,
des pages de manuel et de la documentation, alors si vous vous sentez
l'âme d'un traducteur, n'hésitez pas à contacter l'équipe de
traduction des HOWTOs ; pour cela, adressez-vous à &Eacute;ric Dumas
&lt;dumas(à)freenix.fr&gt; ou &lt;dumas(à)linux.eu.org&gt;.

<sect>Le vocabulaire : petit lexique<p>

Tout d'abord, un mot sur le vocabulaire employé :

<sect1>8 bits<p>

Des caractères sont dits « 8 bits » s'ils correspondent à des accents ou
à des signes spéciaux comme « § », non inclus dans le standard
<tt/ASCII/ « 7 bits ».

Ce standard, sans accents ni caractères spéciaux, correspond aux 128
(2^7) premiers caractères des 256 (2^8), de 0 à 255.

Pour des raisons historiques (place disponible, inutilité pour les états
uniens) seuls les 128 (2^7) premiers caractères ont été normalisés par
l'ASCII : par exemple le A qui est le 65e caractère de la table ASCII
s'écrit 0100 0001 en notation binaire.

Pour les caractères situés hors de la norme ASCII, différentes « normes
» ou « standards » incompatibles, comme l'Unicode, l'iso-8859, le latin,
le cp (...) fixent ces correspondances.

Par exemple, dans le standard ASCII étendu par l'iso-8859-1, le 224ème
caractère équivalent noté « eb » en hexadécimal correspond à « ë ».

<sect1>La police de caractères<p>

Une police de caractères est une correspondance entre des codes
informatiques et des caractères (alphanumériques...) affichables par
l'ordinateur.

La police de caractères est l'ensemble des représentations graphiques des
caractères d'un standard.

<sect1>Les polices de caractères<p>

Il existe plusieurs polices de caractères 8 bits pouvant répondre au
besoins des francophones.

Je vous recommande de lire à ce sujet l'excellent site de Roman Czyborra
qui a fait une thèse sur ce sujet et qui vous donnera une
<htmlurl name="explication fort détaillée"
url="http://czyborra.com/charsets/iso8859.html">

Pour résumer, il est nécessaire de choisir une police de caractères pour
que tous les caractères français soient disponibles.

Voici la liste des polices dites « ISO 8859 », mais attention, il existe
leurs équivalents en « code page » pour windows (comme cp1252).

<itemize>
<item> ISO 8859-1 : latin 1 : langues d'Europe de l'ouest, Afrikaans,
Swahili.

Le Swahili, n'utilise aucun caractère accentué (comme l'Anglais, le
Malais et l'Indonésien), donc n'importe quel version fait l'affaire.

Pour l'Afrikaans, je ne sais plus exactement quel était le choix initial
(c'est-à-dire où avait été rangé le 'n au départ), mais il ne me semble
pas que ce soit dans Latin 1.

Dans la pratique, bien sûr, les Afrikaaner utilisent Latin 1 ; la même
chose se passe pour un certain nombre des cas qui suivent.

<item> ISO 8859-2 : latin 2 : langues d'Europe centrale et orientale.

Dans les faits : Polonais, Tchèque, Slovaque, Slovène, Croate, Hongrois,
Roumain, probablement aussi le Sorbe ou Sorabe (Wende en allemand).

Officiellement, je crois que l'Albanais s'écrit aussi en Latin-2, mais
comme dans les faits c'est identique au Latin 1...
Il y a un problème pour le Roumain, car le Latin 2 contient formellement
les caractères avec une cédille, quand en roumain on utilise une virgule
souscrite.

<item> ISO 8859-3 : latin 3 : Espéranto et Maltais.

Initialement, c'était prévu pour les langues d'Europe du Sud, y compris
le Turc, les langues d'Espagne (donc Catalan, Basque), le Français.

Mais dans la pratique, c'est limité à ces deux langues.

<item> ISO 8859-4 : latin 4 : langues baltes (incomplet).

Pas utilisé dans la pratique, remplacé par Latin 7 (iso-8859-13), ou
plutôt en pratique la codepage 1257 Windows.

Pour l'Este ou Estonien, on peut aussi utiliser Latin 9.

<item> ISO 8859-9 : latin 5 (comme latin 1, moins l'Islandais, plus le
Turc).

Usage : le Turc et peut-être l'Azéri, mais il manque le schwa, un « e »
renversé.

Codage officiel aux Pays-Bas du fait des Turcs qui y habitent.

<item> ISO 8859-10 : latin 6 : langues nordiques, sauf le Lapon Skolt.

Pas utilisé dans la pratique : ne servirait que pour les langues sames
(ou lapones), mais il manque des caractères, et le public concerné est
de toute manière assez limité.

<item> ISO 8859-11 : Thai.

Pas encore officiellement adopté.

<item> ISO 8859-12 : Indien (n'existe pas encore).

Prévu pour le devanagari, pour écrire l'Hindi, la langue principale de
l'Inde, et aussi un grand nombre d'autres langues indiennes, dont le
Sanskrit.

<item> ISO 8859-13 : latin 7 : langues baltes.

Plus exactement : couvre les langues du pourtour de la mer Baltique,
donc aussi le Polonais, l'Allemand et les langues de scandinavie.

Mais dans la pratique il est réduit en utilisation aux langues baltes
et à l'Este ou Estonien.

<item> ISO 8859-14 : latin 8 : langues celtes.

Pour le Breton, le Gaélique et les dialectes parlées au Pays de Galles
et en Irlande.

<item> ISO 8859-15 : latin 9 : comme latin 1, en y comblant quelques
manques.

Pour le Français, le Finnois (en concurrence avec Latin 1) et l'Este ou
Estonien (en concurrence avec Latin 7).
</itemize>

De cette longue liste, il convient de ne retenir que :

<itemize>
<item>ISO 8859-1 latin 1 : police ouest-européenne utilisée par la
majorité des systèmes UNIX, elle permet de disposer de tous les
caractères Français sauf les « o e liés », l'euro et l'y tréma majuscule
<item>cp850 : équivalent sous DOS de cette police, mais incompatible :
il faut utiliser un outil de traduction de fichiers tel GNU recode.
<item>ISO 8859-15 latin 9 : police de l'union européenne, il s'agit
d'une version révisée de l'ISO 8859-1 latin 1 pour inclure tous les
caractères des pays européens ; ainsi on y retrouve les caractères
Français manquant, l'euro, et des caractères finlandais manquants.
<item>latin 0 : l'ISO 8859-15 latin 9 est souvent incorrectement
abrégée en latin0, qui correspondait au nom du projet, de par
son ambition à remplacer le latin 1 un jour. Je vous renvoie au
<htmlurl name="site de l'ISO"
url="http://www.iso.ch/catf/d29505.html"> et à la
<htmlurl name="documentation complète de ce standard"
url="http://www.indigo.ie/egt/standards/iso8859/8859-15-fr.pdf">
<item>cp1252 : équivalent sous Windows de cette police, aussi
incompatible, qui apporte les mêmes caractères manquants, du fait d'une
révision récente de cette norme.
<item>ISO 8859-9 latin 5 : police officielle en Turquie et en Hollande,
où les caractères Islandais peu utilisés ont été remplacés par les
caractères turcs.
<item>cp1254 : équivalent sous Windows de cette police, aussi
incompatible, qui apporte les caractères manquant au Français
précédemment cités et remplace les caractères Islandais peu utilisés par
les caractères turcs.
</itemize>

Les choix de polices de caractères sont souvent des questions ou la
raison se heurte aux habitudes.

Pour ma part, si vous hésitez, je vous recommande l'ISO 8859-15 latin 9,
pour diverses raisons :

<itemize>
<item>Il supporte l'intégralité des caractères utilisés en Français de
manière standard sur les UNIX, pour les échanges de fichiers entre
Solaris et Linux par exemple
<item>Il s'agit de la police 8 bits choisie par l'union européenne si
l'Unicode, évolution du 8 bits, n'est pas disponible
<item>Il permet d'écrire des textes avec l'intégralité des
caractères utilisés dans l'union
<item>Il est en train de devenir le nouveau standard dans la
messagerie électronique au sens large, supplantant progressivement l'ISO
8859-1 latin 1
</itemize>

Le Francophones HOWTO utilise donc le latin 9 dans tous les exemples, car il y
a de grandes chances que votre système ne soit pas encore compatible
latin 9... autant donc vous proposer des manipulations et des travaux
pratiques utiles :-)

Toutefois, si vous ne pouvez utiliser l'ISO 8859-15 latin 9 et
décidez d'en choisir une autre, je vous recommande d'éviter les cp
propres au monde DOS/Windows et de vous rabattre sur l'ISO
8859-1 latin 1 qui est encore un standard fort répandu : dans chaque
exemple je vous invite alors à remplacer les « latin9 » par des « latin1 »

<sect1>Table de clavier<p>

Une table de clavier est un fichier permettant de faire correspondre
l'empreinte physique des cabochons, « touches » du clavier, au résultat
obtenu sur l'écran de l'ordinateur.

Pour linux, ces fichiers sont dans /usr/lib/kbd/keytables/ ou
/usr/share/kbd/keytables/

Par exemple, les claviers français AZERTY ont une table de clavier
différente des claviers suisse romands QWERTZ, ou des claviers du reste
du monde, QWERTY.

Cela ne concerne que l'apparence du clavier, l'empreinte des cabochons,
donc disposition relative des caractères sur le clavier, et non son
électronique interne ; si votre clavier ne vous convient pas, il vous
suffit donc d'utiliser des autocollants pour le transformer en un autre
clavier francophone.

<sect1>« Home », « End », « Page_Up » et « Page_Down »<p>

Les touches « Home », « End », « Page_Up » et « Page_Down » dont les noms
varient selon les claviers sont les touches permettant respectivement
d'aller en début/fin de ligne et de monter/descendre d'une page.

Les codes affectes à ces touches sont respectivement 102 et 107 pour «
Home » et « End » en mode terminal.

Dans les pictogrammes des claviers ISO 9995-7, ces touches sont
représentés par des flèches aux traits appuyés.

Lorsqu'on presse une touche, le clavier émet un code, qui est
intercepté par la table de clavier.

La table de clavier, si elle reconnait le code, renvoie la chaine
associée à la touche, en l'occurence« "\e[4~ » pour « End ».

Lorsque bash ou un autre programme reçoit cette chaine, il ne la connait
pas !

Donc il faut lui dire, dans le .inputrc que "\e[4~" signifie "aller à la
fin de la ligne"

Donc pour que ces touches fonctionnent dans le shell bash, on ajoutera
donc dans le fichier .inputrc (dans votre ~/ ou dans /etc/inputrc) les
lignes:

<tscreen><verb>
set meta-flag on
set convert-meta off
set input-meta on
set output-meta on
set bell-style visible

"\e[1~":beginning-of-line
"\e[3~":delete-char
"\e[4~":end-of-line
"\e\C-h": backward-kill-word
"\e\e[3~": kill-word
</verb></tscreen>

Les premières lignes permettent d'afficher les caractères 8 bits, et de
remplacer le « bip » en cas d'erreur par un éclair blanc à l'écran.

<sect1>Touches mortes<p>

Les touches mortes sont des touches qui ne produisent pas de caractères
en elles-mêmes, mais qui modifient la façon dont la frappe suivante va
être interprétée, par exemple, le tréma ou l'accent circonflexe sont en
général des touches mortes.

Une touche morte est une touche qui doit donc être suivie d'un espace
pour obtenir l'accent seul, ou dans le cas où elle est suivie d'une
voyelle y positionne un accent, par exemple :

<tscreen><verb>
	« ^ » puis « e » donne « ê »
	« ^ » puis « espace » donne « ^ »
</verb></tscreen>

Les touches mortes sont :
<itemize>
<item> be et fr: l'accent aigu en AltGr de 1 pour les Français et en
AltGr de ù pour les Belges, l'accent grave en AltGr de 7 pour les
français &amp en AltGr de carré/cube pour les Belges, le tréma et
l'accent circonflexe tous deux à côté du P
<item> sf et usx: les accent aigus, graves, circonflexes, les
trémas et la tilde
<item> qc: les accent graves, circonflexes, les trémas et la cédille
</itemize>

<sect1>« BackSpace » et « Delete »<p>

En raison d'une erreur volontaire et historique sous Linux, pour
« émuler » le fonctionnement d'un clavier de console VT, ces 2 touches
sont fréquemments mélangées, au mieux fonctionnant à l'identique, au
pire ne fonctionnant pas du tout.

Commençons donc par bien les définir :

<itemize>
<item>BackSpace : touche placée en haut à droite du pavé principal, au
dessus d' « Entrée », au cabochon marqué d'une flèche vers la gauche.
<item>Delete : touche du pavé curseur au cabochon marqué « Suppr » ou
« Del », à gauche de « Fin » ; en ISO 9995-7 elle correspond à trois
barres obliques fines orientées sud-ouest/nord-est.
</itemize>

Le pavé numérique offre une touche au marquage identique et à effet
identique lorsque « Verr Num » ou « Num Lock » est désactivé.

Ces deux touches correspondent chacune à un de ces codes :

<itemize>
<item>BS : caractère ASCII 0x08, ou control-h.
<item>DEL : caractère ASCII 0x7F, ou control-?
<item>^D : caractère ASCII 0x04, ou control-d.
</itemize>

Ceci dans le but d'effacer à gauche du curseur avec BackSpace, à droite du
curseur avec Delete.

<sect1>« UTC » et « GMT »<p>

Chaque partie du monde a sa propre norme horaire, basée sur des
fuseaux.

La France se trouve en zone MET, « heure moyenne européenne » soit GMT+1 ;
la zone « MET DST » correspond à l'heure d'été activée soit GMT+2.

<itemize>
<item>GMT est l'heure solaire moyenne de Greenwich. L'heure est comptée à
partir de midi et est donc décalée de 12 h  par rapport au temps
universel. GMT est basée sur la rotation de la terre, ce n'est donc pas
un temps régulier. En effet, la vitesse de rotation de la Terre subit
des variations faibles mais assez chaotiques, en plus elle diminue sur
le long terme.

<item>UTC, « temps universel coordonné », est compté à partir de
minuit toujours par rapport au méridien zéro. Il est
basé sur des étalons atomiques, mais des secondes intercalaires
sont ajoutées occasionnellement pour faire en sorte qu'il ne
s'écarte jamais de plus de une seconde de l'heure solaire moyenne.
<htmlurl name="Le site de l'opdaf" url="http://opdaf1.obspm.fr/"> et
<htmlurl name="le lexique"
url="http://opdaf1.obspm.fr/www/lexique.html"> donnent plus de
renseignements.  </itemize>

C'est le temps UTC, défini à Paris, qui sert de référence aux
différentes heures légales.

L'acronyme « GMT » est employé 99% du temps pour
désigner UTC, mais c'est une erreur ou un abus de langage.

Enfin, à titre purement indicatif, il existe l'heure astronomique, aussi
comptée sur des étalons atomiques mais décalée de 4 minutes par jour de
l'heure terrestre car se basant sur la position de la terre dans
l'espace par rapport aux étoiles.

<sect>Réglage du clavier sous Linux<p>

<sect1>Introduction<p>

Il existe deux programmes pour configurer votre clavier : un pour la console :
<tt/loadkeys/ et un pour XFree : <tt/xkbd/.

Pour installer un clavier français sous Linux, tapez selon votre clavier
une des lignes suivantes :

<tscreen><verb>
	loadkeys tables-clavier/fr/fr-latin9.map
	loadkeys tables-clavier/qc/qc-latin1.map
	loadkeys tables-clavier/cn/cn-latin1.map
	loadkeys tables-clavier/be/be-latin9.map
	loadkeys tables-clavier/sf/sf-latin1.map
	loadkeys tables-clavier/usx/usx-latin1.map
	loadkeys tables-clavier/usx/usx-happy-hacking-latin9.map
</verb></tscreen>

<sect1>Attention au stty !<p>

Avec les tables latin 9 recommandées dans ce HOWTO, pour linux-console
aussi bien que pour X window, <tt/N'UTILISEZ PLUS/ :

<tscreen><verb>
	stty erase ^H
</verb></tscreen>

ou :

<tscreen><verb>
	stty erase ^?
</verb></tscreen>

« stty erase » ne sert en effet qu'à établir une correspondance
entre le code que renvoie une touche et la fonction <tt/erase/ pour
effacer le caractère.

Les tables ici fournies fonctionnent correctement et ne nécessitent donc
pas de <tt/stty erase/ qui risquerait surtout de perturber leur bon
fonctionnement !

Supprimez-donc ces lignes de vos fichiers d'initialisation de l'interpréteur de
commandes « shell », comme .bashrc, .bash_profile ou .tcshrc .

<sect1>Faire de ces modifications les défauts au démarrage<p>

D'habitude, loadkeys est exécuté par des scripts au
démarrage ; par exemple dans <tt>/etc/rc.d/init.d/keytable</tt> ou
<tt>/etc/rc.d/rc.local</tt>, <tt>init.d/keytable</tt> ou <tt>rc.keymap</tt>.

La commande :

<tscreen><verb>
	find /etc/rc.d -type f | xargs grep loadkeys
</verb></tscreen>

vous fournira le nom exact du fichier lançant loadkeys ; il vous
suffit alors de l'éditer pour que vos modifications soient
désormais prise en en compte à chaque démarrage.

Les distributions RedHat et Debian constituent des exceptions : la table
de clavier par défaut étant définie dans
<tt>/etc/sysconfig/keyboard</tt> pour la RedHat et
<tt>/etc/kbd/config</tt> pour les Debian.

Remplacer donc dans le fichier propre à votre distribution la table de
clavier en question par la bonne table comme fr-latin9.map (selon votre
modèle de clavier)

Vous devrez mettre une copie de la table que vous utilisez dans
le répertoire où votre distribution va chercher les tables de clavier ;
en général /usr/lib/kbd/keymaps/i386/azerty/ pour une RedHat et
/usr/share/kbd/keymaps/i386/azerty/ pour une Debian.

Allez donc sur télechargez <htmlurl name="l'archive"
url="http://metalab.unc.edu/guylhem/francophones-howto.tgz">,
enregistrez-la dans votre répertoire ~/, puis détarrez-la avec la
commande:

<tscreen><verb>
	tar -xzvf francophones-howto.tgz
</verb></tscreen>

Cela crée un répertoire ~/french : placez-vous dans ce répertoire
puis tapez :

<tscreen><verb>
	cp tables-clavier/linux-console/fr-latin9.map /usr/lib/kbd/keytables/i386/azerty/
</verb></tscreen>

Pour afficher les caractères latin9, vous devrez exécuter les
instructions de la section « polices de caractère ».

<sect1>Polices de caractère<p>

Si vous utilisez console-tools-1998.08.11.tar.gz, vous pourrez remplacer
« setfont » par « consolechars » : ces programmes servent à charger une
police sous linux console.

<tscreen><verb>
        setfont /usr/lib/kbd/consolefonts/xxxE-NN.psf.gz
</verb></tscreen>

Je vous conseille pour des raisons développées plus bas :

<tscreen><verb>
        setfont /usr/lib/kbd/consolefonts/lat9-16u.psf.gz
</verb></tscreen>

Je ne vous conseille pas les fichiers « lat1 », qui ne supportent pas
l'euro ni les autres caractères français.

Vous trouverez aussi des fichiers « .uni » qui ne sont utiles que pour
créer des polices ou pour ceux qui utilisent l'unicode : ils fixent des
correspondances entre les « dessins » des caractères dans la police et
les codes des dits caractères, un même dessin pouvant correspondre à
plusieurs codes dans l'example de d'unicode.

Pour les polices toutes faites, vous pouvez forcer cette correspondace
avec l'option « -u fichier.uni ».

Si vous tenez à les installer, copiez de la même manière tous les
fichiers commençant par « lat9 » et se terminant par « .uni » dans le
répertoire /usr/lib/kbd/consoletrans avec la commande:

<tscreen><verb>
    cp lat9*.uni /usr/lib/kbd/consoletrans
</verb></tscreen>

D'habitude, setfont est exécuté par des scripts au démarrage ; par
exemple dans <tt>/etc/rc.d/init.d/keytable</tt> ou
<tt>/etc/rc.d/rc.local</tt>, <tt>init.d/keytable</tt> ou
<tt>rc.keymap</tt>.

La commande :

<tscreen><verb>
        find /etc/rc.d -type f | xargs grep setfont
</verb></tscreen>

vous fournira sur le nom exact du fichier lançant setfont ; il vous
suffit alors de l'éditer pour que vos modifications soient
désormais prise en en compte à chaque démarrage...

Les distributions RedHat et Debian constituent des exceptions : la
police par défaut étant définie dans <tt>/etc/sysconfig/i18n</tt>
pour la RedHat et <tt>/etc/kbd/config</tt> pour les Debian.

Dans <tt>/etc/sysconfig/i18n</tt> rajouter une ligne de la forme :

<tscreen><verb>
        SYSFONT=xxxE-NN.psf
</verb></tscreen>

<itemize>
<item> xxx représente le type de police ; il doit s'agir d'une lat
pour les francophones ce qui signifie ISO 8859 ou latin.
Sans cela il n'y a plus de caractères « étendus » comme les voyelles
accentués, symboles de ponctuation comme paragraphe...
<item> E représente l'encodage latin, par exemple 1 pour latin1, 0 ou 9
pour latin9
<item> NNN représente la taille individuelle de chaque caractère ; 08
est presque illisible mais 16 est un peu gros... &Agrave; régler selon
les go&ucirc;ts de chacun.
</itemize>

Je vous conseille la police lat9-16u.psf ou son équivalent lat0-16.psf
installée par défaut sur la plupart des distributions, très souvent
compressée donc avec le suffixe « .gz » .

[ rajouter une explication sur comment installer la police ]

La section « une police, des polices » vous donnera plus de détails sur
les polices disponibles.

<sect1>Vieilles versions<p>

Si lors du chargement de la table de clavier vous rencontrez un message
d'erreur similaire au suivant :

<tscreen><verb>
	(guylhem@victis:guylhem)$ loadkeys fr-latin9.map
	Loading /usr/lib/kbd/keytables/fr-latin9.map
	unknown keysym 'dead_cedilla'
	/usr/lib/kbd/keytables/fr-latin9.map:67: parse error
	syntax error in map file
	key bindings not changed
</verb></tscreen>

Cela signifie que votre version de kbd dont le programme loadkeys
dépend est trop vieille : il faut vous procurer une version plus
récente du programme.

Il existait et existe encore des versions des tables de clavier pour ceux ne
voulant ni touches mortes ni accents, mais celles-ci tombent actuellement en
désuétude puisque la grande majorité des programmes prennent désormais
en charge ces fameuses touches mortes et les caractères accentués.

De plus, les tables fournies avec ce HOWTO permettent de se servir des
touches mortes ou de s'en passer si un programme les refuse, les deux
cas ayant été prévus :

<sect1>Améliorations spécifiques au clavier français latin9<p>

Ça y est, vous pouvez taper du texte latin 9 sous Linux en mode console !

Seules 2 touches ont été modifiées :

<sect2>a) carré/cube<p>
Elle sert maintenant à oe/OE liés ; en AltGr on y trouve les guillemets
français.

Le carré & le cube restent respectivement accessibles en AltGr (ù) et Alt
Gr(*), les guillemets étant aussi directement accessibles avec AltGr (w)
et AltGr (x), selon la norme ISO 9995 part 3 appliquée à la norme AZERTY
française.

En résumé :
<itemize>
<item> AltGr (oe) : «
<item> AltGr + Shift (oe) : »
<item> AltGr (w) : «
<item> AltGr (x) : »
<item> AltGr (m) : ¹
<item> AltGr (ù) : ²
<item> AltGr (*) : ³
</itemize>

<sect2>b) dollar / livre / symbole monétaire international<p>

Étant donné que le symbole monétaire international n'est plus disponible
dans la norme d'encodage ISO 8859-15, il a été remplacé par la division
centésimale de l'euro : le cent, disponible donc en AltGr ($).

Dans les précédentes versions, le dollar & la livre, des monnaies
étrangères, avaient été déplacés pour laisser la place à l'euro et au
cent, notre monnaie.

De telles modifications étaient permises par les recommandations
officielles de l'EURO WORKSHOP mais allaient à l'encontre de la norme
AZERTY : si la position AltGr (e) est déjà occupée sur un clavier, la
position de l'euro est laissée au libre choix des programmeurs.

AltGr (e) sert à faire « ê » depuis 1992 sous Linux, mais devant les
protestations légitimes d'utilisateurs disposant d'un clavier où l'euro
est sérigraphié en AltGr (e), j'ai du déplacer le ê en AltGr + Shift
($).

Désolé d'avoir rompu la « tradition » linuxienne pour conserver la
compatibilité à la norme AZERTY & aux recommandations officielles de
l'EURO WORKSHOP !

En résumé :

<itemize>
<item> AltGr (e) : euro
<item> AltGr ($) : cent
<item> AltGr + Shift ($) : ê
</itemize>

<sect1>Pour les autres claviers latin9<p>

L'euro & les cents ont été rajoutés respectivement en AltGr (e) & en
AltGr (c).

La touche AltGr a donc été rajoutée ; pour utiliser ces
fonctions avec toute table de clavier, il suffit de charger
other-latin9.map après votre table nationale.

La plupart des améliorations du clavier français ont été transposées aux
claviers nationaux par des auteurs externes.

Toutefois, je ne possède pas chaque modèle de clavier et ne peut
expliquer en détail toutes ces modifications ; des sections spécifiques
seront donc rajoutées par la suite par d'autres auteurs.

<sect1>Dans tous les cas<p>

« Home », « End », « Delete » et « BackSpace » ont été corrigées & les
touches « Windows » ont été correctement définies, pour passer d'une
console virtuelle à l'autre.

Des « Composes », séquences à préfixer par la touche compose ( «
ImprÉcran » ou « Print Screen » par défaut) ont été rajoutées, mais cela
reste transparent pour l'utilisateur.

Par exemple:
<itemize>
<item> COMPOSE ^ suivi d'une des lettres (s,S,z,Z) sert à obtenir les lettres finlandaises rajoutées
<item> COMPOSE " suivi d'une des lettres (y,Y) sert à obtenir les y trémas franco-néerlandais rajoutés
<item> COMPOSE - suivi d'une des lettres (e,c,l,y) sert à obtenir l'euro, le cent, la livre, le yen
</itemize>

<sect>XFree<p>

<sect1>Introduction<p>

Il y a quelques années, « xmodmap » servait à changer les tables de
clavier sous XFree, un fichier de configuration d'ordinaire nommé
/usr/X11/lib/X11/xinit/.Xmodmap étant pris en charge grâce à votre
<tt/.xinitrc/ ou <tt>/etc/X11/xinit/xinitrc</tt>

Pour convertir une table console correcte, on utilisait « mk_modmap » livré avec
l'archive kbd et généralement installé en /usr/lib/kbd/keytables

Les utilisateurs désirant personnaliser leur table xmodmap employaient le
programme « xkeycaps ».

Puis XFree 2.1 et les version ultérieures ont reconnu la disposition des
touches du clavier gérée par « loadkeys », rendant théoriquement
xmodmap inutile.

Mais la gestion de la touche « COMPOSE » assurée par XFree 3.1 laissait
un peu à désirer, la table héritée de « loadkeys » ne servant guère.

Il fallait donc continuer à employer xmodmap, l'utilitaire logiciel standard
permettant d'obliger le serveur X à associer les événements souris/clavier à
des caractères.

Sous XFree version 3.2 et postérieures, « xkb » rendit xmodmap définitivement
obsolète.

Mais ne voilà-t-il pas les rumeurs qui voulaient que les prochaines versions
de XFree ne supporte plus les touches mortes se sont confirmées !!!

Dans la distribution X11 du X Consortium, donc XFree86, qui en est
directement issu, il n'existe plus de mécanisme général de gestion des
touches mortes, ou des solutions approximatives obligeant à supprimer
aussi xkb ou modifier des bibliothèques de programmes !

<sect1>Mal programmer<p>

À chaque programme de bien gérer les touches mortes au lieu de faire
confiance à X pour cette tâche.

En réalité, il n'est pas compliqué de gérer des touches mortes, il suffit
d'utiliser la bonne fonction, XmbLookupString() dans les programmes
Motif, au lieu de XLookupString().

<sect1>Le clavier en pratique<p>

Quelle histoire compliquée !

De ce fait, elles ne fonctionnent que pour les clients X
« internationalisés », c'est-à-dire qui gèrent eux-mêmes les problèmes
liés aux méthodes d'entrée de données des différentes langues
nationales.

Ceci est très gênant lorsqu'on veut pouvoir saisir du texte
comportant des lettres accentuées, alors que le client utilisé
n'est pas internationalisé !

<sect2>a) Solution utilisant xmodmap<p>

Taper :

<tscreen><verb>
	cp fr-latin9.xmod /usr/X11R6/lib/X11/xinit/Xmodmap
	cp fr-latin9.xmod ~/.Xmodmap
</verb></tscreen>

<sect2>b) Solution utilisant xkb (recommandée)<p>

Taper :

<tscreen><verb>
	cp fr-latin9 /usr/X11R6/lib/X11/xkb/symbols
</verb></tscreen>

Puis éditer votre <tt/XF86Config/ pour y rajouter dans la section « Keyboard
» les lignes xkb idoines :

<tscreen><verb>
Section "Keyboard"
Protocol        "Standard"
AutoRepeat      500 30
LeftAlt         Meta
RightAlt        ModeShift               # Important pour Alt-gr, mais dans les
                                        # versions récentes de XFree, AltGr et
                                        # RightAlt sont synonymes.

ScrollLock      Compose                 # Pour faire des caractères spéciaux.
                                        # Utiliser sinon une des 3 touches des
                                        # nouveaux claviers 105 touches...

RightCtl        Control                 # Garder la touche normale

XkbKeycodes     "xfree86"
XkbRules        "xfree86"
XkbTypes        "default"
XkbCompat       "default"
XkbSymbols      "fr-latin9(pc105)"
XkbGeometry     "pc(pc105)"
XkbModel        "pc105"

EndSection
</verb></tscreen>

Pour cette partie Xkb, certains préfèrent :
<tscreen><verb>
	XkbKeymap       "xfree86(fr-latin9)"
	XkbKeycodes     "xfree86"
	XkbSymbols      "en_US(pc101)+fr-latin9"
	XkbGeometry     "pc(pc101)"
</verb></tscreen>

Bien sur, remplacer « fr » par « cn », « be », « ch » ou « usx » selon
votre clavier...

<sect2>c) Solution du compose<p>

Une autre méthode pour obtenir des caractères 8 bits :

Dans <tt>/usr/X11R6/lib/X11/locale/iso8859-1/Compose</tt> se trouve une
table de « correspondance » entre deux caractères et un résultat ; les
deux caractères sont «mélangés» lors de l'appui sur la touche Compose :
par exemple;
<tscreen><verb>
	COMPOSE suivi de « e » puis « ^ »
</verb></tscreen>

a toutes les chances de vous donner ê, y compris dans l'ordre opposé («
^ » puis « e »)

Mais pour utiliser la touche Compose, vous devez l'affecter à une touche !

Le paramétrage préconisé, réglé dans XF86Config, la fait correspondre à
la touche « Arrêt Défil » inutile sous X, par la commande :

<tscreen><verb>
	ScrollLock       Compose
</verb></tscreen>

dans la section Keyboard.

Attention, sous Linux en mode console, cette touche est utile (pour
bloquer temporairement la console virtuelle) et c'est « Impr Écran » ou
« Print Screen » qui, ne servant à rien, est affectée à « Compose ».

<sect2>d) Solution modifiant la libX11<p>

Thomas Quinot &lt;Thomas.Quinot(à)cuivre.fdn.fr&gt; vous propose donc sa
<tt>libX11</tt> modifiée, qui gère les touches mortes de
manière transparente pour tous les clients.

Elle permet également de traiter les séquences composées
inconnues comme des paires de caractères, par exemple :

<tscreen><verb>
	~ + / = ~/
</verb></tscreen>

Pour l'utiliser :
<itemize>
<item>Récupérez libX11-XF3.3.1.tar.gz ;
<item>Extrayez le fichier <tt>libX11.so.6.1</tt> ;
<item>Placez-le dans <tt>/usr/X11R6/lib/</tt> ;
<item>Exécutez <tt>ldconfig</tt> ;
<item>Désactivez l'extension XKB en utilisant l'option
<tt>XkbDisable</tt> dans la section <tt>Keyboard</tt> de votre
<tt>XF86Config</tt>.
</itemize>

<sect2>e) Est-ce nécessaire ?<p>

Personnellement, je vous recommande de ne pas toucher à la libX11,
d'oublier xmodmap et de l'alternative xkb + fichiers latin9 en
attendant un autre changement de la politique du X Consortium envers
les touches mortes (ou en rajoutant les options d'internationalisation
au code source de vos programmes.)

Actuellement, si vous n'avez pas de répertoire
<tt>/usr/X11R6/lib/X11/xkb/symbols/</tt> cela signifie que vous
n'utilisez pas xkb : procurez-vous donc une version plus récente de X
window !

Sans xkb, XFree se rabattra par défaut sur votre configuration de
clavier pour Linux avec loadkeys.

Toutefois, la translation n'est pas parfaite et je vous recommanderais
plutôt d'éviter cette option, aussi bien que l'ancien gestionnaire de
clavier <tt/Xmodmap/.

Il se peut aussi que sans aucune commande pour xkb, XFree vous considère
comme utilisateur d'un clavier 7 bits !

Il convient donc d'utiliser une table adaptée avec xkb.

<sect1>« latin9 » ou « latin1 » ?<p>

Je vous conseille de choisir les tables <tt/latin9/ que je maintiens à
jour, plus récentes que les versions <tt/latin1/, permettant d'utiliser
de multiples améliorations, détaillées dans la section clavier sous
linux-console, pour disposer du plus de confort possible
et plus adaptées car maintenu par des francophones.

Les nombreuses améliorations dont elles bénéficient permettent de
pallier au déficiences de nombreux programmes.

Par exemple, certains programmes en Motif comme Netscape (tm) ne savent
pas encore gérer les touches mortes ... donc impossible de taper par
exemple des ê ou des î sur les claviers des Belges et Français, puisque
la touche morte « accent circonflexe » est le seul moyen d'obtenir ces
caractères !

« fr-latin9 » répond à ce problème en proposant une solution de
remplacement : AltGr (voyelle) permet d'obtenir la voyelle avec un
accent grave, AltGr+Shift (voyelle) permet d'obtenir la voyelle avec un
tréma !

<sect1>Table de correspondances<p>

<itemize>
<item> AltGr (voyelle) : voyelle accent grave
<item> AltGr + Shift (voyelle) : voyelle tréma
<item> AltGr (touche au dessous de la voyelle) : voyelle majuscule accent grave
<item> AltGr + Shift (touche au dessous de la voyelle) : voyelle majuscule
tréma
<item> AltGr + Shift (minuscule accentuée) : majuscule accentuée
</itemize>

Par exemple :

<itemize>
<item> AltGr (a) : â
<item> AltGr (q) : Â
<item> AltGr + Shift (ù) : Ù
</itemize>

L'astuce marche aussi pour le c cédille :

<itemize>
<item> AltGr + Shift (ç) : Ç
</itemize>

Donc même dans les pires conditions, si aucune touche morte ne
fonctionne, on peut quand même accéder à toutes les
voyelles accentuées, majuscules et minuscules !

Vous y trouverez en plus les guillemets français (« »), les symboles
employés en physique (&szlig;, &aring;, delta, phi ...), des signes
de monnaies (yen, cent) ou de copyright (<tt/tm/, &copy;) ainsi que des
lettres d'autres langues (&Oslash;, &AElig; ...).

Tous ces signes s'obtiennent grâce à AltGr (lettre), par exemple
AltGr (b) donne &szlig;, AltGr (r) donne <tt/tm/, AltGr (y) donne yen...

Pour vous rapeller simplement de tout celà, tapez par exemple :

<tscreen><verb>
        more /usr/lib/kbd/keytables/i386/azerty/fr-latin9.map
</verb></tscreen>

Pour ce qui est du choix entre latin1 et latin9... à vous de voir !

Un conseil : essayez l'un puis l'autre si vous avez le temps.

<sect1>Les polices ISO 8859-15 latin 9 sous X<p>

Il est bien d'avoir une table de clavier compatible latin 9, mais sans
police adaptée jamais vous ne verrez les caractères rajoutés dans cette
norme.

Il faut donc utiliser l'utilitaire de conversion « bdftopcf » qui en
quelque sorte permet de compiler les polices de caractères fournies.

Placez-vous dans le répertoire de l'archive que vous avez récupéré puis
sous root, taper par exemple pour Xlat9-10x20.bdf ou un autre bdf :

<tscreen><verb>
	bdftopcf Xlat9-10x20.bdf > Xlat9-10x20-lat9.pcf
	gzip Xlat9-10x20-lat9.pcf
	mv Xlat9-10x20-lat9.pcf.gz /usr/X11R6/lib/X11/fonts/misc
	mkfontdir /usr/X11R6/lib/X11/fonts/misc
</verb></tscreen>

Celà crée un fichier « Xlat9-10x20-lat9.pcf » qu'il faut compresser avec
gzip, on obtient alors le fichier « Xlat9-10x20-lat9.pcf.gz » qui doit
être mis dans le répertoire adéquat, pour lequel l'index des polices de
caractères sera mis à jour.

Alors, ajoutez la table de composition latin9 aux compositions par
défaut de X, spécifiques à l'iso 8859-1 :

<tscreen><verb>
	cat XCompose-lat9 >> /usr/X11R6/lib/X11/locale/iso8859-1/Compose
</verb></tscreen>

Nous faisons un cat vers l'ISO 8859-1, car X ne reconnaît pas l'ISO
8859-15 latin9.

De là, redémarrer X ou taper sous son compte d'utilisateur normal :

<tscreen><verb>
	xset +fp /usr/X11R6/lib/X11/fonts/misc
</verb></tscreen>

Si vous utilisez xmodmap, lancez :

<tscreen><verb>
	xmodmap ~/.Xmodmap
</verb></tscreen>

Pour choisir les polices latin9, lancer xfontsel et chercher les
encodages iso8859-15.

Ou plus simplement, taper :

<tscreen><verb>
	grep Xlat9-10x20.pcf /usr/X11R6/lib/X11/fonts/misc/*
</verb></tscreen>

Puis utiliser le second paramètre comme nom de police, par exemple avec
rxvt, xiterm, aterm ou wterm:

<tscreen><verb>
	aterm -fn -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-15
</verb></tscreen>

Cela lance un terminal X utilisant une des polices latin9.

<sect>Réglage du clavier pour les applications en mode texte<p>

<sect1>Tout d'abord<p>

Le huitième bit doit survivre à l'entrée du noyau,
assurez-vous-en donc avec :

<tscreen><verb>
	stty cs8 -istrip -parenb
</verb></tscreen>

Ensuite, il convient de s'assurer que l'application est apte à supporter
les caractères 8 bits : par exemple, ispell n'est pas compilé
pour des caractères 8 bits par défaut : il faut le recompiler
sans l'option :

<tscreen><verb>
	-NO8BIT
</verb></tscreen>

<sect1>Une police, des polices...<p>

Avant d'aborder cette section, je vous conseille de lire l'introduction
sur les polices pour appréhender un peu mieux le vocabulaire de base et
les différentes normes de polices.

<sect2>a) Historique des polices<p>

De l'ASCII à l'Unicode, en passant par l'ISO 8859, le latin et le cp, on
peut résumer l'histoire des polices en grandes étapes :

Au début était l'ASCII, qui codait ses caractères sur 7 bits.

Prévu pour des états-uniens, il était impossible d'incorporer des
caractères accentués à la norme déjà présente de 127 caractères.

Ainsi vint le 8 bits qui étendit le nombre de caractères à 255 et les
normes ISO 8859, latin et cp, pour les plus connues, qui vinrent pallier
à cette déficience du fait des 128 positions supplémentaires disponibles
en encodant les caractères sur 8 bits.

Mais plusieurs de ces normes étaient nécessaire du fait de
l'impossibilité de faire tenir les caractères de toutes les langues du
monde sur 8 bits.

La norme ISO 8859-1 latin 1, la plus utilisée, se destine par exemple au
langues d'Europe de l'ouest, du nord, d'Amérique, la norme ISO 8859-2
latin 2 est prévue pour l'Europe de l'est...

L'Unicode est l'un de ces standard, destiné à terme à remplacer les
différentes évolutions de l'ASCII ; comme le passage du 7 bits au 8 bits
il correspond à une extension de la place disponible, tout en reprenant
l'ancienne partie comme ASCII et ISO 8859-1 latin 1 pour rester
compatible avec la majorité du parc installé.

L'Unicode offre l'avantage de proposer les caractères nécessaires à
toutes les langues du monde, mais reste encore peu utilisé ou
implémenté.

En effet, il est impossible de l'utiliser en pratique sous
linux-console, la mémoire exigüe de la carte vidéo ne permettant pas de
stocker tous les caractères de l'Unicode, et sous X la gestion actuelle
des polices rendrait son utilisation trop inconfortable.

Attendons un peu que les polices « True Type » se répandent sous X, grâce
à des outils comme freetype, xfstt (...) et le très attendu XFree 4 qui
devrait les supporter en natif.

Actuellement, la nouvelle norme européenne ISO 8859-15 latin 9 est
censée permettre la transition vers l'Unicode en apportant à l'ancien
ISO 8859-1 latin 1 les caractères qu'il manquait actuellement.

Toutefois elle est partiellement incompatible avec l'Unicode puisque
l'ISO 8859-1 latin 1 avait été choisi comme base pour l'Unicode, mais
que cette police veut compléter les failles de l'ISO 8859-1 latin 1 en y
rajoutant des caractères déjà présents dans l'Unicode...

Quelle complexité pour de simple lettres !

<sect2>b) ISO 8859-15 latin 9<p>

De nous jours, il vaut mieux installer par défaut la nouvelle norme ISO
8859-15 latin 9, destinée à remplacer l'ensemble des polices européennes
par une seule.

Son but est voisin de l'Unicode, mais elle a l'avantage d'être plus légère que
celui-ci et d'être applicable tout de suite.

Elle apporte notamment des caractères qui manquaient beaucoup pour les
Français et les Finlandais :

<itemize>
<item> « e dans l'o » en majuscule et minuscule pour les Français, par
exemple pour les mots oeuf, coeur, boeuf, oeil ...
<item> « s chapeau inversé » en majuscule et minuscule pour les Finlandais
<item> « z chapeau inversé » en majuscule et minuscule pour les Finlandais
<item> « l'EURO » pour tous les pays européens
</itemize>

Cette nouvelle norme, ISO 8859-15 latin 9 aussi connue sous le nom générique
latin0, reste cependant encore très peu répandue par rapport à la norme
actuelle ISO 8859-1 latin 1.

<sect2>c) Utiliser les polices ISO 8859-15 latin 9<p>

Vous n'avez besoin que d'une seule police !

Or il en existe plusieurs types répondant différemment à la même norme
iso-8859-15 latin9 « latin0 » sous linux :
<itemize>
<item> par tradition l'opposition latN/latNu selon l'inclusion ou non d'une
table de correspondance Unicode.
<item> en réalité les différences vont bien plus loin, de l'ordre dans
lequel sont les caractères de la police, ce qui joue sur l'aspect des
applications semi graphique, les correspondances avec des caractères
latin1 ± latin9 ± Unicode ce qui a un rôle dans la compatibilité croisée
ou exclusive, par exemple purement Unicode...
</itemize>

J'ai donc complété par 2 types de ma création pour répondre au mieux aux
différents besoins.

<tscreen><verb>
      | Encodage dans | Inclusion d'une | Compatibilité | Compatibilité
      |  l'ordre iso  |  table Unicode  |   exclusive   |    croisée
--------------------------------------------------------------------------
lat9  |     oui       |      non        |     non       |   lat1 + lat9
--------------------------------------------------------------------------
lat9u |     non       |      oui        |     non       |   lat1 + lat9
--------------------------------------------------------------------------
lat9v |     oui       |      oui        |   Unicode     |       non
--------------------------------------------------------------------------
lat9w |     oui       |      oui        |     non       |lat1+lat9+Unicode
--------------------------------------------------------------------------
</verb></tscreen>

Voici plus d'explications :

<itemize>
<item> les lat9 tout court ne contiennent pas de table de correspondance
Unicode, ce qui fait que tous les symboles monétaires internationaux
apparaîtront comme des euro, ce qui peut poser des problèmes pour les
fichiers issus d'un ordinateur sous windows ; le cp1252 ou le latin1 sont
« incompatibles » avec le latin9, mais ce dernier a l'avantage de fonctionner
tout de suite sous linux.

Dans les versions récentes du noyau, selon le <htmlurl name="site de
Yann Dirson"
url="http://www.multimania.com/ydirson/en/lct/lct/lct-6.html">, il
semble donc que toutes les polices devraient contenir une table de
correspondance Unicode...

<item> des lat9u encodées dans un ordre non standard, mais identique à
celui des polices latXu de kbd, par rapport aux polices précédentes, en
amenant les mêmes problèmes avec le cp1252 et le latin1 mais en incluant
une table de correspondance Unicode, ce qui permet d'avoir de jolis
caractères semi graphiques sous Yast, mc, ou d'autres programmes basés
sur ncurses ou dialog.

<item> des lat9v encodées dans l'ordre officiel iso comme les
lat9 mais avec une table Unicode complète : là aucun symbole monétaire
international ne sera remplacé par l'euro !
Ces polices sont utiles pour éviter les problèmes d'export, grâce à
l'Unicode *pur*, avec une table de clavier Unicode adaptée : tous les
caractères latin9 sont remplacés par des caractères Unicodes et affichés
ainsi, ce qui a le mérite d'être compatible avec le latin9, l'Unicode,
d'être élégant techniquement mais inutilisable « normalement » sous
linux-console. Presque aucun système n'est entièrement prêt pour
l'Unicode !
</itemize>

Donc n'utilisez les polices lat9, lat9u ou lat9v que si vous savez ce
que vous faites, je vous recommande pour ma part le meilleur compromis :
les polices lat9w qui permettent de passer au latin9 immédiatement, en
posant quelques problèmes pour les caractères latin1 qui seront
remplacés par leurs équivalents latin9, mais sans rendre l'Unicode
obligatoire comme les lat9U, sans emmêler les caractères graphiques
comme les lat9, et en permettant aussi d'afficher les caractères
spécifiques au latin9 en Unicode *pur*, à l'exception des caractères
spécifiques au latin1 donc...

Je vous rassure, vous n'êtes pas obligés de comprendre tout ce qui suit
pour « passer à l'euro », si effectivement vous ne savez toujours pas de
quelle police vous avez besoin, un conseil : utiliser les lat9w.

Pour utiliser la police lat9-16.psf ou un autre lat9 .psf, vous devez
pallier l'absence d'une table Unicode en en chargeant une.

<tscreen><verb>
                loadunimap fonts/linux-console/lat9.uni
                setfont fonts/linux-console/lat9-16.psf
</verb></tscreen>

Pour utiliser la police lat9w-16.psf ou une autre lat9u, lat9v ou
lat9w :

<tscreen><verb>
                setfont /fonts/linux-console/lat9w-16.psf
</verb></tscreen>

<sect2>d) Unicode<p>

Une alternative est l'Unicode, mais les programmes l'utilisant sont encore trop
peu nombreux pour qu'elle soit valable.

Citons quand même yuedit et le projet « 9 » (9term, 9wm... rien à voir
avec l'opérateur télécom français du même nom) qui utilisent l'Unicode
sous X, avec plus ou moins de succès.

En revanche, sous linux-console, tout programme peut utiliser l'Unicode.

Mais, hélas!, aussi grande que soit la mémoire des cartes vidéos actuelles,
elle ne peut charger l'intégralité des caractères d'une police Unicode.

Il existe donc des « jeux de caractères » limités mais bien utiles pour les
langues baltiques, asiatiques, est-africaines...

<sect2>e) Utiliser les possibilités Unicode<p>

Essayez par exemple ce fichier <tt/unicode-lance/ pour passer en mode Unicode:

<tscreen><verb>
#!/bin/sh
echo -e '\033%8'
kbd_mode -u
loadkeys fr-unicode.map
setfont lat9u-16.psf
</verb></tscreen>

et ce fichier <tt/latin-retourne/ pour revenir en mode latin normal:

<tscreen><verb>
#!/bin/sh
echo -e '\033%@'
kbd_mode -a
loadkeys fr-latin9.map
setfont lat9w-16.psf
</verb></tscreen>

Essayez par exemple de lire le fichier <tt/unicode.txt/, encodé en
Unicode, une fois <tt/unicode-lance/ activé.

Vous ne verrez sinon qu'un texte mal encodé, sans caractères 8 bits,
comme cet exemple :

<tscreen><verb>
Ceci est un essai de texte en UNICODE !

On constate que les bÃ©tas (Ã~_) et autres lettres 8 bits ne sortent pas bien
si l'on regarde ce fichier en mode latin !
Les accents Ã©Ã¨Ã| Ã¹ non plus d'ailleurs...
Enfin, heureusement que l'on ne marche pas sur des Å~RUFS, enfin, Å~Sufs !
Ã~Ga marche moyennement disons !
</verb></tscreen>

<sect1>Les locales, messages en Français<p>

Linux en 'version française' existe... mais ne semble pas facile
à obtenir.

La librairie locale(7) [cf aussi perllocale, setlocale, getlocale]
utilisée par la librairie C se sert de variables d'environnement pour
définir les préférences linguistiques et nationales.

Pablo Saratxaga répondait ainsi à Pascal Rigaux en prenant l'exemple de sort :

<tscreen><verb>
 PR> J'ai découvert aujourd'hui la variable d'environnement LANG. C'est assez
 PR> surprenant de se retrouver avec de l'aide en français (même si elle n'est pas
 PR> toujours aussi précise que la version anglaise) quand on fait ls --help.

C'est agréable n'est-ce pas ?

 PR> Par contre je ne comprend pas pourquoi un programme comme sort(1) n'utilise pas
 PR> cette information pour obtenir un tri acceptable pour les accents (du genre ne
 PR> pas mettre « être » après « zen »). Il devrait au moins proposer une option de
 PR> ce genre.

Il faudrait regarder les sources de sort...
La fonction à utiliser est strcoll() :

				  ****

STRCOLL(3)         Manuel du programmeur Linux         STRCOLL(3)


NOM
       strcoll - Comparaison de deux chaînes suivant la localisa-
       tion en cours.

SYNOPSIS
       #include &lt;string.h&gt;

       int strcoll (const char *s1, const char *s2);

DESCRIPTION
       La fonction strcoll() compare les deux chaînes s1  et  s2.
       Elle renvoie un entier inférieur, égal ou supérieur a zéro
       si  s1 est respectivement inférieure, égale, ou supérieure
       a  s2.   La  comparaison est effectuée en se basant sur la
       localisation en cours pour la catégorie LC_COLLATE.  (Voir
       setlocale(3)).

				  ****

qui est donc l'équivalent de strcmp() mais qui tiens compte des locales.
Il faudra s'écrire un strcasecoll() aussi pour bien faire, en utilisant
toupper()/tolower() qui d'après la page de manuel supporte les locales.

Qui s'y colle ? Ça devrait être assez simple à réaliser sur un système GNU
en tout cas.
</verb></tscreen>

Il existe différente variables à exporter, avec chacune une fonction
spécifique ; le format standardisé est:

<tscreen><verb>
	langue[_PAYS[.CHARSET]][@variante]
</verb></tscreen>

Les crochets dénotent l'optionalité, par exemple: 'fr', 'fr_BE',
'fr_CH.ISO-8859-15', no@bokmaal, no@nynorsk,...

Les fonctions de la libc, celle de GNU en tout cas, iront chercher dans
« l'ordre décroissant » si on peut dire; par exemple si on spécifie
'fr_CH.ISO-8859-15' elles chercheront d'abord avec cette valeur, puis
avec 'fr_CH' puis avec 'fr'.

<itemize>
<item> LC_COLLATE  définit les équivalences de caractères pour les comparaisons
(&aelig; peut être équivalent à ae), pour les ligatures et pour les césures.
<item> LC_CTYPE    définit les caractères affichables
<item> LC_MONETARY définit le format et le symbole de la monnaie utilisée
<item> LC_NUMERIC  définit le format numérique : regroupement, marqueur
décimal...
<item> LC_MESSAGES définit la langue des messages
<item> LC_TIME     définit le format de la date, les noms des jours et
des mois
<item> LC_ALL      valeur par défaut des variables précédentes : si une
LC_ n'est pas définie, LC_ALL est prise en compte, sinon la libc se
rabat sur LANG.
<item> LANG        différent des variables précédentes, contient
le code langue au format iso : fr,en,de...
<item> LANGUAGE    liste des locales par ordre de préférence séparées
par deux points (fr:es:dk:en), c'est une particularité GNU, fort
utile si un document n'existe que dans une langue comme certaines pages
de manuel
</itemize>

Les valeurs utilisables pour les francophones sont:

<itemize>
<item> fr français générique
<item> fr_FR français de France
<item> fr_BE français de Belgique
<item> fr_CH français de Suisse
<item> fr_LU français du Luxembourg
<item> fr_CA français du Canada
</itemize>

Par exemple, si vous être un Français de France, il suffit d'indiquer
sous bash :

<tscreen><verb>
	export LANGUAGE=fr_FR
</verb></tscreen>

Exemple :

<tscreen><verb>
	bash# export LANGUAGE=es_ES
	bash# ls fichier_n_existant_pas
	ls: fichier_n_existant_pas: No existe el fichero o el directorio
	bash# export LANGUAGE=de_DE
	bash# ls fichier_n_existant_pas
	ls: fichier_n_existant_pas: Datei oder Verzeichnis nicht gefunden
	bash# export LANGUAGE=en_US
	bash# ls fichier_n_existant_pas
	ls: fichier_n_existant_pas: No such file or directory
	bash# export LANGUAGE=fr_FR
	bash# ls fichier_n_existant_pas
	ls: fichier_n_existant_pas: Aucun fichier ou répertoire de ce type
</verb></tscreen>

Toutefois, avec le passage à l'euro, ces locales ne sont plus adaptées.

Je vous conseille donc d'utiliser dans les pays de l'union passant à
l'euro le suffixe « @euro » :

<tscreen><verb>
   export LC_ALL="fr_FR@euro"
</verb></tscreen>

Pour cela, installer les nouveaux fichiers sources de locales dans
<tt>/usr/share/i18n/</tt> en lançant :

<tscreen><verb>
   cp charmaps/ISO-8859-15 /usr/share/i18n/charmaps/ISO-8859-15
   cp locales/* /usr/share/i18n/locales/
</verb></tscreen>

Alors, régénérer les locales « binaires » de <tt>/usr/share/locales</tt>, par exemple :

<tscreen><verb>
   localedef -i fr_FR@euro -f ISO-8859-15 fr_FR@euro
</verb></tscreen>

fr_FR@euro inclus les caractères latin 9, c'est utile pour l'utilisation
de LC_COLLATE et LC_CTYPE en fait, et la nouvelle monnaie unique.

Pour le moment, le Franc Français (FRF) est toujours la monnaie
officielle en France par exemple, mais lorsque ce sera l'euro, il
suffira de remplacer la locale fr_FR par fr_FR@euro.

<tscreen><verb>
   cd /usr/lib/locales
   rm -fr fr_FR
   mv fr_FR@euro fr_FR
</verb></tscreen>

La solution « @euro » est supportée par les autres UNIX comme Solaris.

Pour les shell scripts, il peut être utile de rajouter « LC_TIME=C » pour
empêcher la date d'être localisé, embêtant pour les grep et autres qui
cherchent « Mon » « Tue »... et non « Lun », « Mar »...

Les données correspondantes aux préférences se trouvent généralement
dans <tt>/usr/share/locale</tt>. S'ils manquent, vous pouvez récupérer
leur <htmlurl name="source" url="ftp://dkuug.dk/i18n/WG15-collection">

Concernant les autres fichiers abordés dans cet article, vous les
trouverez avec les autres fichiers de cet HOWTO sur
<htmlurl name="ma page"
url="http://metalab.unc.edu/guylhem/francophones-howto.tgz">.

<sect1>Son linux en français<p>

Pour se faire <tt/SON/ linux en français il faut en pratique disposer des
sources de la libc et d'un minimum de compétences en langage C ; ces
manipulations sont inutiles pour l'utilisateur standard de Linux qui
se contentera d'utiliser les locales de la section précédente.

Mais voici donc, pour la bonne bouche, quelques renseignements collectés...

Laurent Chemla nous pilote :

<tscreen><verb>
Si j'ai suivi, il y a deux trucs qui font la même chose, d'où embrouille, les
locales et un truc appelé nls.

Les locales, sous Linux, ça va par défaut dans /usr/lib/locale,
et ça contient de quoi préciser entre autres le format des
nombres (LC_NUMERIC), les retours des fonctions ctype (isalpha etc) (LC_CTYPE),
le format des sommes d'argent (LC_MONETARY), le format des dates (LC_TIME) et
encore d'autres détails. Sur certains Unix, il y a aussi LC_MESSAGES,
qui contient les messages de l'OS dans la langue choisie par la variable
d'environnement LC_MESSAGES. Pas sous Linux.  Sous Linux, c'est nls qui fait
ça, et de fait, nls gère un fichier qui est dans /etc/locale/.
(NDG : De nos jours, ils se trouvent plutôt dans /usr/lib/locale)
D'où l'embrouille. Ils auraient mis ça dans /usr/lib/nls, comme
tout le monde, ça aurait évite la confusion. Mais bon.

Donc, si l'on veut se tenir à jour d'nls, il suffit d'aller dans les
sources de libc/nls, faire « make french » et copier libc.dat dans
/etc/locale/C/libc.dat et toc, tous les messages sont en français. Y compris
ceux des programmes qui n'utilisent pas setlocale(): c'est perror() qui fait le
boulot (du moins je suppose).

Si l'on veut en plus que les programmes qui utilisent setlocale() utilisent nos
règles françaises, là il faut aller dans les sources de
libc/locale et dans chacun des sous-répertoires jeter un oeil sur le
fichier exemple, le modifier pour le français (c'est des tout petits
fichiers), et faire « make », avant de copier le résultat dans
/usr/lib/local/fr/ et de faire un « export LC_ALL=fr ».
</verb></tscreen>

Autre astuce pour ménager les vieux logiciels :

<tscreen><verb>
cd /usr/lib
ln -sf /usr/share/locale .
</verb></tscreen>

Ne pas oublier de télécharger sur le <htmlurl name="site du lip6"
url="ftp://ftp.lip6.fr"> :

<itemize>
<item> Les pages de manuel en français, archive man-fr-*, adaptées par C.
Blaess. Il suffit d'extraire le contenu de l'archive dans le répertoire
/usr/man/fr.

<item> Une intéressante documentation technique : locale.fr, par P. D'Cruze,
adaptée par É. Dumas
</itemize>

Pour en apprendre davantage lire la page de manuel de « locale » : bibliothèque
de pages de manuel 5 ou 7 :

<tscreen><verb>
	bash# man 5 locale
	bash# man 7 locale
</verb></tscreen>

<sect1>Les variables<p>

Ces variables doivent être exportées à chaque login :
mettez les donc dans <tt/.bashrc/ et <tt/.bash_login/, <tt/.tcshrc/ ou
/etc/profile :

<tscreen><verb>
# pour tcsh, utiliser setenv au lieu de export, par exemple «setenv LANG fr»

# Les locales
LC_CTYPE=ISO-8859-1
LANGUAGE=fr
LC_MESSAGES=fr
LC_ALL=fr
LANG=fr
LESSCHARSET=latin1
export LC_CTYPE LANGUAGE LC_MESSAGES LC_ALL LANG LESSCHARSET

# Les raccourcis : sans ll ou d, impossible de voir les fichiers comprenant des
# caractères 8 bits ...
alias q="cd .."
alias ll="ls --color=auto -a -N -l"
alias d="ls --color=auto -a -N"
alias indent="indent -kr"
alias netscape="export LC_ALL=en_EN ; netscape $* ; LC_ALL=fr_FR"

# Au cas où Del/BackSpace ne fonctionne pas, essayez l'un des deux :
#stty erase ^?
#stty erase ^H
</verb></tscreen>

N'oubliez pas : tous les fichiers ici cités dont le nom commence par
« . » doivent se trouver dans votre répertoire maison ~/

<sect1>Les caractères 8 bits dans les programmes utilisant readline tels bash ou ncftp...<p>

Readline est une librairie de saisie de caractères avec historique et
complétion ; elle est utilisée par de nombreux programmes comme bash, ncftp,
gnuplot...

Par défaut, le 8e bit sert à coder la touche Meta.

Elle est utilisée pour coder certaines commandes mais la touche « Escape »
ou « Échap » peut la remplacer.

Si vous souhaitez voir et saisir des accents avec les applications
compilées avec readline, comme bash pour les versions supérieures à
1.13, ajoutez ceci dans votre fichier $INPUTRC, par défaut
<tt>~/.inputrc</tt>) :

<tscreen><verb>
# Permettre de rentrer & recevoir des caractères accentués
set meta-flag on
set convert-meta off
set input-meta on
set output-meta on

# Pas de bip audible mais visible
# set bell-style visible

# Pour faire marcher Home, End, Delete, Esc + Delete & Esc + BackSpace
"\e[1&tilde;":beginning-of-line
"\e[3&tilde;":delete-char
"\e[4&tilde":end-of-line
"\e\C-h": backward-kill-word
"\e\e[3&tilde;": kill-word
</verb></tscreen>

Cela vous permettra d'effacer des caractères vers l'avant avec
« Delete » et vers l'arrière avec « BackSpace », ceci n'étant pas
prévu sur les tables de clavier par défaut « mimant » le
comportement d'un clavier de console VT100 .

Les deux dernières options vous permettront d'utiliser « Home » et « End »
pour aller au début et à la fin de la ligne en cours
d'édition.

Pour pouvoir employer une touche il suffit d'obtenir son code et
l'associer à une fonction grâce à ce fichier ; pour obtenir le code
d'une touche invoquer cat puis appuyer sur la touche : son code
apparaît.

Le code physique :

<tscreen><verb>
	^[
</verb></tscreen>

correspond à la séquence d'échappement.

Par exemple, si le code de « Home » est « ^[[7~ » il suffit d'ajouter
une ligne :

<tscreen><verb>
	"\e[7~": beginning-of-line
</verb></tscreen>

au <tt/.inputrc/.

Plus de documentation est disponible sur la page de manuel de bash, section
<tt/READLINE/.

On peut aussi, grâce à la variable d'environnement <tt/INPUTRC/, utiliser un
fichier commun à tous les utilisateurs.

Enfin, je vous recommande d'utiliser ce fichier <tt/.bashrc/ à placer
dans votre répertoire maison :

<tscreen><verb>
# ~/.bashrc : exécuté par bash(1) pour les shells lancés après le login.

# Le path
PATH="/usr/sbin:/usr/bin:/sbin:/bin:/usr/X11R6/bin:/usr/local/bin"

# Le prompt
PS1="(\u@\h:\W)$ "

# L'utilisateur
ENV=$HOME/.bashrc
USERNAME="votre nom"

# Les locales
_CTYPE=ISO-8859-1
LANGUAGE=fr
LC_MESSAGES=fr
LC_ALL=fr
LANG=fr
LESSCHARSET=latin1
export LC_CTYPE LANGUAGE LC_MESSAGES LC_ALL LANG LESSCHARSET

# Les raccourcis
alias q="cd .."
alias ll="ls --color=auto -a -N -l"
alias d="ls --color=auto -a -N"
alias indent="indent -kr"
alias elm-box="elm -f ~/Mail/Inbox"
alias netscape="export LC_ALL=en_EN ; netscape $* ; LC_ALL=fr_FR"

# Au cas où Del/BackSpace ne fonctionne pas, essayez l'un des deux :
#stty erase 
#stty erase ^H

# Refuser le talk & le write
#mesg n

# Permettre les coredumps
#ulimit -c nombre_max_de_Ko

#Fixer le masque de création de fichiers
#umask 022
</verb></tscreen>

Le fichier .bash_profile ou .bash_login, exécuté par bash(1) lors des
logins, y est strictement identique mais peut, si vous le voulez,
présenter des différences pour afficher par exemple une citation en
laçant le programme « fortune ».

<sect1>zsh<p>
Celui-ci devrait se contenter d'un <tt/stty pass8/.

Si cela ne suffisait pas, rajouter dans le <tt/.zshrc/ ou dans
<tt>/etc/zshrc</tt>:

<tscreen><verb>
	bindkey "\e[2~"  yank
	bindkey "\e[3~"  delete-char
	bindkey "\e[1~"  beginning-of-line
	bindkey "\e[4~"  end-of-line
	bindkey "\e[5~"  up-line-or-history
	bindkey "\e[6~"  down-line-or-history
</verb></tscreen>


<sect1>tcsh<p>

Pour tcsh, placer, dans le fichier <tt>/etc/csh.login</tt> ou dans les
fichiers <tt/.tcshrc/ des utilisateurs concernés, les variables
indiquées plus haut en remplaçant export par setenv:

<tscreen><verb>
	setenv LC_CTYPE=ISO-8859-1
	setenv LANGUAGE=fr
	setenv LC_MESSAGES=fr
	setenv LC_ALL=fr
	setenv LANG=fr
	setenv LESSCHARSET=latin1
</verb></tscreen>

<sect1>Pour tous les shells<p>

Remplacer 'iso_8859_1' par 'iso-8859-1' si cela ne fonctionne pas, voire
french.iso88591.fr_FR ou fr_BR, fr_CA, fr_CH, fr_LU...

&Agrave; propos de LANG, il vaut mieux éviter fr_FR et lui préférer fr
car certains programmes ne passent pas vraiment par la resolution de
locales mais lisent LANG directement...

Si nls est installé, les routines correspondantes sont utilisées, sinon
tcsh agit en iso_8859_1, quelle que soit les valeurs données à LANG et
LC_CTYPE : cf. la section NATIVE LANGUAGE SYSTEM de tcsh(1).

Selon le Danish-HOWTO, utiliser :

<tscreen><verb>
	(guylhem@victis:tcsh)# setenv LC_CTYPE ISO-8859-1
	(guylhem@victis:tcsh)# stty pass8
</verb></tscreen>

<sect1>L'heure<p>

Rien n'est plus facile que de laisser à Linux le soin de passer de
l'heure d'été à l'heure d'hiver et
réciproquement...

a) D'abord, quelle heure est-il :-) ?

Après avoir regardé sur la pendule la plus proche de vous, tapez :

<tt>
clock
</tt>

puis

<tt>
date
</tt>

La première heure est celle du bios, la seconde celle calculée
par Linux à partir de <tt>/etc/zoneconfig</tt>.

Pour peu que vous ayez installé timezone, votre machine peut jongler
aisément entre les différents fuseaux horaires... ce que les DOS
ou Windows ne permettent pas !

b) L'heure du choix !

De là, deux possibilitées : soit vous décidez de laisser
l'heure système à l'heure locale, peu pratique, excepté si
vous hébergez aussi sur votre disque dur ces systèmes
d'exploitation peu évolué, ne sachant même pas exploiter
les fuseaux horaires, soit vous passez à l'heure de Greenwich, Linux se
chargeant de l'adapter à votre fuseau horaire.

Dans ce cas, les grands voyages à l'étranger avec un portable
tout neuf équipé de Linux se feront en toute simplicité :
le dernier paragraphe vous expliquera comment changer de fuseau horaire
facilement...

c) Le réglage

Pour procéder, regardez d'abord si l'heure système
retournée par clock est l'heure locale ou l'heure de Greenwich.

Vous avez bien regardé une pendule comme je vous le conseille plus haut,
n'est-ce pas ?

Si clock vous retourne l'heure locale, il va falloir jongler un peu avec les
fuseaux horaires, sinon passez directement à l'étape
« réglage du fuseau ».

<itemize>
<item> Pour les français, belges wallons et suisses romands :
</itemize>

Vous êtes normalement dans une zone horaire MET (Medium European Time,
soit GMT+1).

La zone « MET DST » correspond elle à l'heure d'été active
(GMT + 2).

Selon les décisions futures de la cour européenne, l'heure
d'été « daylight savings » risque d'être abandonné...
ce qui compliquera cette explication !

<itemize>
<item> Pour les canadiens français :
</itemize>

Vous êtes dans une zone horaire GMT-4 si vous habitez autour de
Montréal .

Pour les autres provinces, consulter un dictionnaire !

Premièrement, effacez le fichier /etc/localtime ou
/usr/lib/zoneinfo/localtime (l'emplacement varie selon les distributions ; si
vous avez les deux fichiers, effacez /etc/localtime : l'autre fichier doit
certainement être un lien vers /etc/localtime).

Dès lors, clock et date doivent vous retourner la même heure...

<itemize>
<item> Pour les canadiens français : utilisez GMT+4
</itemize>

<itemize>
<item> Pour les français, belges wallons et suisses romands :
</itemize>

Si vous lisez ce document en été, le décalage de l'heure
locale par rapport à l'heure de Greenwich est de deux heures, on va donc
mettre temporairement le fuseau en GMT-2, soit vous lisez ce document en hiver
et il convient de remplacer tous les « 2 » par des « 1 » dans les exemples
suivants...

GMT-2 ?!!? Alors que le fuseau est GMT+2 ?

Ceci va vous retourner l'heure de Greenwich dont on a besoin pour régler
le système : tapez :

<tt>
ln -sf /usr/lib/zoneinfo/Etc/GMT-2 /etc/zoneconfig
</tt>

<tt>
clock
</tt>

<tt>
date
</tt>

L'heure calculée correspond donc à l'heure de Greenwich, l'heure
système à l'heure locale... soit l'inverse de ce que l'on veut.

Un simple :
<tt>
clock -w
</tt>

Va alors mettre l'heure du système en heure de Greenwich, utilisant pour
cela l'heure locale inversée volontairement avec l'heure
système.

d) Régler le fuseau horaire :

Tapez alors :
<tt>
ln -sf /usr/lib/zoneinfo/Europe/Votre-ville /etc/zoneconfig
</tt>

Et voilà ! Le système est à l'heure de Greenwich, la
conversion vers le fuseau horaire local et l'heure d'été se
faisant automatiquement.

Si vous habitez hors Europe, procédez de même en remplaçant
les « -2 » par « X », X représentant l'opposé de votre
décalage horaire (par exemple -4 au Québec, donc X=+4...)

e) Modifier le fuseau horaire :

Si vous partez à l'étranger, il est alors simple de modifier
l'heure locale de votre portable : par exemple si vous partez pour Moscou :

<tt>
ln -sf /usr/lib/zoneinfo/Europe/Moscow /etc/zoneconfig
</tt>

Très simple et très utile : plus besoin de se souvenir du
décalage horaire (plus ou moins X heures) puisque Linux se charge
désormais de tout !

<sect1>vi<p>

Normalement, aucune modification n'est nécessaire à part l'utilisation de
loadkeys (détaillée plus haut).

Ce fichier <tt/.vimrc/ pourrait toutefois vous être utile si vous utilisez
<tt/vim/ au lieu d'<tt/elvis/ :

<tscreen><verb>
" Les guillemets anglais « " » signifient « mis en commentaire »

" Éviter un avertissement « version incorrecte » :
version 4.0

" Utiliser les défauts de vim, bien mieux
set nocompatible

" Autoriser le « BackSpace » sur tout :
set bs=2

" Police à utiliser sous X11 :
"set guifont=-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-1

" Fixer la césure automatique de la ligne à N caractères :
set tw=72

" Faire apparaître les tabulations et les espaces
set list

" Changer les défauts pour voir les espaces inutiles et les tabulations
set listchars=tab:»·,trail:·
hi nontext ctermfg=red
hi nontext ctermbg=blue

" Indentation (pour les programmeurs) :
" set cindent

" Réglages souris :
"set mouse=a

" Ligne
set nowrapscan

" Montrer les correspondances :
set showmatch

" Montrer le mode
set showmode

" Indentation intelligente (pour les programmeurs) :
" set uc=0

" Faire fonctionner BackSpace :
set t_kD=^?

" Doit se trouver après
map ^H X

" Faire fonctionner Delete  :
map \e[3~ x

" Cacher la souris lorsqu'on tape :
set mousehide

" Faire voir les correspondances lors de recherches :
" set hlsearch

" Colorer à l'intérieur des commentaires en C :
let c_comment_strings=1

" Couleur pour xiterm, rxvt, nxterm, color-xterm :
if has("terminfo")
    set t_Co=8
    set t_Sf=\e[3%p1%dm
    set t_Sb=\e[4%p1%dm
 else
    set t_Co=8
    set t_Sf=\e[3%dm
    set t_Sb=\e[4%dm
endif

" Coloration syntaxique :
if ett_Co > 1
   syntax on
endif

" Autoriser l'édition de fichiers gzippés

augroup gzip
  " Supprimer toutes les autocommandes
  au!
  autocmd BufReadPre,FileReadPre        *.gz set bin
  autocmd BufReadPost,FileReadPost      *.gz '[,']!gunzip
  autocmd BufReadPost,FileReadPost      *.gz set nobin
  autocmd BufReadPost,FileReadPost      *.gz execute ":doautocmd BufReadPost " .  expand("%:r")

  autocmd BufWritePost,FileWritePost    *.gz !mv <afile> <afile>:r
  autocmd BufWritePost,FileWritePost    *.gz !gzip <afile>:r

  autocmd FileAppendPre                 *.gz !gunzip <afile>
  autocmd FileAppendPre                 *.gz !mv <afile>:r <afile>
  autocmd FileAppendPost                *.gz !mv <afile> <afile>:r
  autocmd FileAppendPost                *.gz !gzip <afile>:r
augroup END

augroup bzip
  au!
  autocmd BufReadPre,FileReadPre        *.bz2 set bin
  autocmd BufReadPost,FileReadPost      *.bz2 '[,']!bunzip2
  autocmd BufReadPost,FileReadPost      *.bz2 set nobin
  autocmd BufReadPost,FileReadPost      *.bz2 execute ":doautocmd BufReadPost " .  expand("%:r") 
  autocmd BufWritePost,FileWritePost    *.bz2 !mv <afile> <afile>:r
  autocmd BufWritePost,FileWritePost    *.bz2 !bzip2 <afile>:r

  autocmd FileAppendPre                 *.bz2 !bunzip2 <afile>
  autocmd FileAppendPre                 *.bz2 !mv <afile>:r <afile>
  autocmd FileAppendPost                *.bz2 !mv <afile> <afile>:r
  autocmd FileAppendPost                *.bz2 !bzip2 <afile>:r
augroup END

augroup cprog
  au!
  autocmd BufRead *       set formatoptions=tcql nocindent comments&
  autocmd BufRead *.c,*.h set formatoptions=croql cindent comments=sr:/*,mb:*,el:*/,://
augroup END

</verb></tscreen>

<sect1>Emacs<p>

Voici un fichier de configuration de base pour employer les accents.

<tscreen><verb>
  ;;
  ;; Fichier .emacs: initialisation d'emacs
  ;; Tiré du Guide du Rootard
  ;;

  (display-time)                     ;; Pour avoir l'heure dans la barre d'état
  (setq display-time-24hr-format t)  ;; Format 24 heures

  ;; Nouveaux modes
  (autoload 'c++-mode   "cplus-md" "C++ Editing Mode" t)
  (autoload 'perl-mode   "perl-mode" "Perl Editing Mode" t)
  (autoload 'c-mode "c-mode" "C Editing Mode" t)
  ; mieux vaudrait utiliser le "cc-mode"

  (autoload 'jargon-mode "jargon" "Jargon Mode" t)

  ;; Auto-Mode Settings : positionne le mode selon l'extension
  (setq auto-mode-alist
  (append '(("\.c$"  . c-mode)    ;; utilise le mode C++ même pour C
  ("\.h$"  . c-mode)
  ("\.C$"  . c++-mode)
  ("\.H$"  . c++-mode)
  ("\.cc$" . c++-mode)
  ("\.C$"  . c++-mode)
  ("\.pl$" . perl-mode)           ;; Perl
  ("/tmp/snd\.[0-9]*" . text-mode);; Text (pour le courriel)
  ("[Rr][Ee][0-9]*" . text-mode)
  ("\.ada$"  . ada-mode)          ;; Ada
  ("\.spec$"  . ada-mode)
  ("\.body$"  . ada-mode)
  ("makefile$" . makefile-mode)  ;; Makefile
  ("Makefile$" . makefile-mode)
  ("Imakefile$" . makefile-mode))
  auto-mode-alist))

  ; Remappages variés à mettre ici
  (global-set-key "\eg" 'goto-line)       ;; ESC G = Aller à une ligne

  (put 'eval-expression 'disabled nil)

  ;; Accents...
  (standard-display-european 1)
  (load-library "iso-syntax")
  (set-input-mode (car (current-input-mode))
                (nth 1 (current-input-mode))
                0)

  ;; Sous X-Window, texte en couleurs (C/C++/Shell/Makefile,etc)
  (cond (window-system
  (setq hilit-mode-enable-list  '(not text-mode)
  hilit-background-mode   'light
  hilit-inhibit-hooks     nil
  hilit-inhibit-rebinding nil)
  (require 'hilit19)
  ))
  (if (not (equal window-system ""))
  (global-set-key "\C-?" 'delete-char))
  ))
</verb></tscreen>

Le Keyboard-HOWTO conseille quand à lui :

<tscreen><verb>
          (standard-display-european t)
          (set-input-mode nil nil 1)
          (require 'iso-syntax)
          (load-library "iso-insert.el")
          (define-key global-map [?\C-.] 8859-1-map)
</verb></tscreen>

Utilisez une version au moins égale à 19.27, modifiez le fichier global
(commun à tous les utilisateurs)
<tt>/usr/lib/emacs/site-lisp/site-start.el</tt> ou le <tt>./emacs</tt>
de chaque utilisateur concerné pour y ajouter :

<tscreen><verb>
	(standard-display-european t)
	(set-input-mode (car (current-input-mode))
	  (nth 1 (current-input-mode))
	  0)
	(global-set-key [delete]   'delete-char)
	(global-set-key [home]     'beginning-of-line)
	(global-set-key [end]      'end-of-line)
	(global-set-key [prior]    'scroll-down)
	(global-set-key [next]     'scroll-up)
	(global-set-key [C-right]  'forward-word)
	(global-set-key [C-left]   'backward-word)
	(global-set-key [C-prior]  'beginning-of-buffer)
	(global-set-key [C-next]   'end-of-buffer)
	(global-set-key "\033[A"  'previous-line)
	(global-set-key "\033[B"  'next-line)
	(global-set-key "\033[C"  'forward-char)
	(global-set-key "\033[D"  'backward-char)
	(global-set-key "\033[H"  'beginning-of-line)
	(global-set-key "\033[Y"  'end-of-line)
	(global-set-key "\033[1~" 'beginning-of-line)
	(global-set-key "\033[2~" 'overwrite-mode)
	;; le delete-char peut correspondre à \004 ou à \033[3~
	(global-set-key "\033[3~" 'delete-char)
	(global-set-key "\033[4~" 'end-of-line)
	(global-set-key "\033[5~" 'scroll-down)
	(global-set-key "\033[6~" 'scroll-up)
</verb></tscreen>

Pour les autres versions :

<itemize>

<item> 19.19 :

<tscreen><verb>
	(standard-display-european 1)
	(set-input-mode (car (current-input-mode))
          (nth 1 (current-input-mode))
          0)
</verb></tscreen>

Lire à ce propos le fichier emacs.info.

<item> 19.22 :

<tscreen><verb>
	(load-library "iso-transl")
	(standard-display-european t)
</verb></tscreen>

<item> Autres :

<tscreen><verb>
	(standard-display-european 1)
	(load-library "iso-transl")
</verb></tscreen>
</itemize>

XEmacs les accepte lui par défaut sans broncher mais peut des fois
rencontrer des problèmes avec les BackSpaces dans le mini-buffer en
console.

Ajouter dans le <tt/.emacs/ :
<tscreen><verb>
(if (eq window-system 'x)
    (global-set-key (read-kbd-macro "DEL") 'delete-char)
  (or (global-set-key "^[[3~" 'delete-char))
)
</verb></tscreen>

Le mode ispell d'emacs a un certain nombre de dictionnaires prédéfinis
qui ne sont pas forcement ceux qui sont en place sur le système.

Si vous constatez des problèmes, vous devez redéfinir la liste
ispell-dictionary-alist des dictionnaires.

Cette liste contient :
<itemize>
<item> le nom du dictionnaire
<item> la liste des caractères composant un mot
<item> la lise opposée des caractères ne composant pas un mot
<item> les caractères de liaison à l'intérieur des mots ("-", "'"...)
<item> vrai ou faux si ces caractères peuvent être présents en plusieurs
exemplaire dans le mot
<item> une liste d'arguments pour ispell
<item> le mode d'ispell (tex, nroff..)
</itemize>

Par exemple, dans le fichier <tt/.emacs/ :

<tscreen><verb>
(setq ispell-dictionary-alist
 '((nil  ; francais.aff
  "[A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü]" "[^A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü]"
  "[---']" nil ("-n") "~nroff")
 ("english"  ; rosbif
  "[A-Za-z]" "[^A-Za-z]" "[---']" nil ("-B") nil)
 ("american" ; yankee
  "[A-Za-z]" "[^A-Za-z]" "[---']" nil nil nil)
 ("francais" ; français
  "[A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü]" "[^A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü]"
  "[---']" nil ("-n") "~nroff")
 ("francais-TeX" ; français
  "[A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü\\]" "[^A-Za-zÀÂÇ-ËÎÏÔÙÛÜàâç-ëîïôùûü\\]"
  "[---'^`\"]" t nil "~tex")
 ("espanol" ; espa~nol.aff
  "[A-Za-záéíóúüñÁÉÍÓÚÜÑ]" "[^A-Za-záéíóúüñÁÉÍÓÚÜÑ]"
  "[---'^`\"]" t nil "~nroff")
 ("dansk" ; danois et norvégien
  "[A-Za-zåÅøØæÆéÉèÈ]" "[^A-Za-zåÅøØæÆéÉèÈ]"
  "[---'^`\"]" t nil "~nroff")
 ))
</verb></tscreen>

Le dictionnaire "francais-TeX" est un lien symbolique sur "francais"
qui permet d'ajouter une entrée pour les accents à la TeX (ex: \'e).

Si vous utilisez X11, vous voudrez peut-être reconstruire les menus et
il vous faudra recharger une partie de lisp/loaddefs.el dans votre
<tt/.emacs/ :

<tscreen><verb>
(setq ispell-menu-map nil)

  (if ispell-menu-map-needed
  (let ((dicts (reverse (cons (cons "default" nil) ispell-dictionary-alist)))
    name)
    ;; Can put in defvar when external defines are removed.
    (setq ispell-menu-map (make-sparse-keymap "Spell"))
    (while dicts
  (setq name (car (car dicts))
    dicts (cdr dicts))
  (if (stringp name)
  (define-key ispell-menu-map (vector (intern name))
    (cons (concat "Select " (capitalize name))
  (list 'lambda () '(interactive)
    (list 'ispell-change-dictionary name))))))))

  (if ispell-menu-map-needed
  (progn
    ;; Define commands in opposite order you want them to appear in menu.
    (define-key ispell-menu-map [ispell-change-dictionary]
  '("Change Dictionary" . ispell-change-dictionary))
    (define-key ispell-menu-map [ispell-kill-ispell]
  '("Kill Process" . ispell-kill-ispell))
    (define-key ispell-menu-map [ispell-pdict-save]
  '("Save Dictionary" . (lambda () (interactive) (ispell-pdict-save t))))
    (define-key ispell-menu-map [ispell-complete-word]
  '("Complete Word" . ispell-complete-word))
    (define-key ispell-menu-map [ispell-complete-word-interior-frag]
  '("Complete Word Frag" . ispell-complete-word-interior-frag))
    (define-key ispell-menu-map [ispell-continue]
  '("Continue Check" . ispell-continue))
    (define-key ispell-menu-map [ispell-region]
  '("Check Region" . ispell-region))
    (define-key ispell-menu-map [ispell-word]
  '("Check Word" . ispell-word))
    (define-key ispell-menu-map [ispell-buffer]
  '("Check Buffer" . ispell-buffer))
    (define-key ispell-menu-map [ispell-message]
  '("Check Message" . ispell-message))
    (define-key ispell-menu-map [ispell-help]
  '("Help" . (lambda () (interactive) (describe-function 'ispell-help))))
    (put 'ispell-region 'menu-enable 'mark-active)))

  (fset 'ispell-menu-map (symbol-value 'ispell-menu-map))
</verb></tscreen>

<sect1>less<p>

<tt>/etc/profile</tt> ou les fichiers de démarrage du shell (comme
<tt/.bashrc/ et <tt/.bash_profile/ dans votre répertoire maison)
doivent contenir :

<tscreen><verb>
export LESSCHARSET=latin1
</verb></tscreen>

Comme fichier <tt/.lessrc/ je vous recommande :

<tscreen><verb>
\e[B    forw-line
\e[A    back-line
\e[6~   forw-scroll
\e[5~   back-scroll
\e[1~   goto-line
\e[4~   goto-end
\e[C    next-file
\e[D    prev-file
\eOA    back-line
\eOB    forw-line
</verb></tscreen>

Pour rentrer un Esc (parfois nommé Échap) taper « \e » ou, sous
vi, mettez vous en mode insertion avec i puis tapez « ctrl+v » et enfin « Esc ».

Ce fichier permet d'utiliser les touches « Home », « End », « Page_Up » & « Page_Down ».

Pour s'en servir, taper :

<tscreen><verb>
lesskey -o .less .lessrc
</verb></tscreen>

N'oubliez pas de mettre le fichier .less dans votre répertoire maison :
il permet d'employer les touches fléchées, « Page_Up », « Page_Down »,
« Home » et « End ».

Ne pas négliger la page de manuel de less car il peut être intéressant de
changer la valeur de sa variable d'environnement de configuration ("LESS").

J'utilise : '-C -M -i -x2'

<sect1>ls<p>

Utilisez les options :

<tscreen><verb>
-N --color=auto
</verb></tscreen>

ou, plus simplement, définissez dans les fichiers de démarrage de
votre shell les alias suivants permettant de voir les fichiers dont le nom
comprend des caractères 8 bits :

<tscreen><verb>
alias ll="ls --color=auto -N -l -a"
alias d="ls --color=auto -N"
</verb></tscreen>

Un simple <tt>d</tt> remplacera le classique <tt>ls</tt>, en y ajoutant la
couleur, alors que <tt>ll</tt> vous offrira une liste complète de tous
les fichiers présents dans le répertoire, avec leurs attributs,
leurs tailles...

--color=auto est préférable car --color=yes fera avoir des codes escape
lorsqu'on redirige vers un fichier ou un programme où si le terminal ne
supporte pas la couleur.

<sect1>flex<p>

Donnez l'option :

<tscreen><verb>
-8
</verb></tscreen>

si l'analyseur généré doit accepter les entrées 8-bits
(bien sûr qu'il doit le faire !).

<sect1>elm<p>

Rajoutez ces trois lignes dans votre <tt>.elm/elmrc</tt> :

<tscreen><verb>
  charset = iso-8859-1
  displaycharset = iso-8859-1
  textencoding = 8bit 
</verb></tscreen>

<sect1>col<p>

Assurez-vous :

  1) qu'il a été corrigé et fasse un

<tscreen><verb>
setlocale(LC_CTYPE,"");
</verb></tscreen>

  2) de définir

<tscreen><verb>
LC_CTYPE=ISO-8859-1
</verb></tscreen>

dans l'environment.

<sect1>rlogin<p>

Utilisez l'option :

<tscreen><verb>
-8
</verb></tscreen>

<sect1>joe<p>

Utiliser <htmlurl name="joe 2.8"
url="ftp://metalab.unc.edu:/pub/Linux/apps/editors/joe-2.8.tar.gz"> ou
plus récent qui devraient fonctionner après édition du fichier de
configuration : placer l'option -asis dans <tt>/usr/lib/joerc</tt> en
première colonne.

<sect1>TeX et LaTeX<p>

Le plus simple consiste à employer GuTemberg, une distribution de LaTeX
avec tous les défauts réglés pour des francophones par des
francophones !

Mais si vous préférez une version <tt>standard</tt> non modifiée, il suffit
d'ajouter au début de chaque fichier :

<itemize>
<item>
Pour LaTeX:

<tscreen><verb>
\documentstyle[isolatin]{article}
</verb></tscreen>

<item>
Pour LaTeX2e:

<tscreen><verb>
\documentclass[12pt,a4paper]{letter}
\usepackage{isolatin1}
\usepackage[french]{babel}
\usepackage{t1enc}
</verb></tscreen>

ou alors :

<tscreen><verb>
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
</verb></tscreen>
</itemize>

Au cas où votre distribution soit trop vieille pour l'inclure,
<tt>isolatin.sty</tt> est disponible <htmlurl name="séparément"
url="ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit">

Pour gs et xdvi, il faut utiliser des options spéciales (sur ma machine,
ce sont des alias). En effet, ils sont souvent configurés pour un papier
états-unien dit « légal », de taille proche, mais non exactement égale,
à celle du standard « A4 ».

Ces options sont les suivantes :

<tt>
  gs -sPAPERSIZE=a4
  xdvi -paper a4
  ghostview -a4
</tt>

Pour que dvips convertisse les documents dans un format papier a4, il faut
spécifier dans le fichier config.ps (le chemin varie en  fonction des versions
de LaTeX) : /usr/lib/texmf/dvips/config.ps ou <tt>.dvipsrc</tt>

<tt>
  @ a4 210mm 297mm
  @+ ! %%DocumentPaperSizes: a4
  @+ %%PaperSize: a4
  @+ %%BeginPaperSize: a4
  @+ a4
</tt>

Sinon ajoutez à votre <tt>.Xresources</tt> :

<tscreen><verb>
XDvi.paper:             a4
Ghostview.pageMedia:    A4
</verb></tscreen>

<sect1>Manuel<p>

Tout d'abord, il faut vous procurer les pages de manuel Linux traduites en
<htmlurl name="français"
url="ftp://ftp.lip6.fr/pub/linux">

Si vous utilisez une distribution RedHat ou Debian, celles-ci sont
présentes sur le cédérom : il suffit de les
sélectionner lors de l'installation.

De là, deux possibilités :

<itemize>
<item> soit vous ne voulez que des manuels en Français, auquel cas il
faut faire un :

<tscreen><verb>
export MANPATH=/usr/man/fr_FR
</verb></tscreen>

NB: fr_FR se remplace par fr_BE, fr_CA, fr_CH ou fr_LU selon le pays concerné.

<item> soit vous préférez par défaut des manuels en
Français et si la page n'existe pas, vous vous rabattez vers l'Anglais,
il suffira alors de taper :

<tscreen><verb>
export LANG=fr
</verb></tscreen>
</itemize>

<tt>man</tt> ira chercher dans le « MANPATH » des pages en « LANG » par
défaut et se rabattra sinon sur des pages en anglais.

Si vous désirez installer la page de manuel expliquant la norme ISO
8859-15 latin 9, il faut installer le fichier iso_8859_15.7.gz :

<tscreen><verb>
cp standard/iso_8859_15.7.gz /usr/local/man/man7/
</verb></tscreen>

<sect1>Correcteur orthographique ispell<p>

Vous pouvez vous le procurer sur le <htmlurl name="site original d'Hydro Québec"
url="ftp://ftp.ireq-robot.hydro.qc.ca:/pub/ispell/francais-IREQ-1.3.tar.gz">
ou sur le <htmlurl name="mirroir du lip6"
url="ftp://ftp.lip6.fr/pub/ispell/francais">

Un fichier LISEZMOI explique pas à pas et en Français
l'installation.

<sect1>Les claviers 105 touches<p>

Aussi appelés « claviers Microsoft (tm) », ils ont trois touches de plus
que les claviers normaux.

Comment s'en servir ?

En mode console, éditer <tt>french.map</tt> et décommenter les lignes
en parlant !

De même pour <tt>french</tt> (pour Xwindow).

<sect1>PGP<p> 

Attention, dans certains pays totalitaires, l'utilisation de logiciels
de cryptographie est considérée comme usage d'armes de guerre, ce qui
est punissable par la loi !

Sautez donc ce paragraphe si votre législation locale ne permet pas
d'utiliser des logiciels de cryptographie.

Premièrement, il faut se procurer pgp-international (à cause de
problèmes de patentes et de législation sur l'export d'armes de
guerre, il existe pgp-us et pgp-international, ce dernire étant
doté d'un algorithme encore plus puissant) sur le
<htmlurl name="site norvégien de PGP" url="ftp://ftp.ifi.uio.no/pub/pgp/">

Ensuite, mettre dans votre répertoire maison, dans un sous
répertoire .pgp les fichiers :

<tscreen><verb>
config.txt
language.idx
pgpdoc1.txt
pgpdoc2.txt
language.txt
fr.hlp
en.hlp
pgp.hlp 
</verb></tscreen>

Enfin, éditer le fichier <tt>.pgp/config.txt</tt> pour y rajouter :

<tscreen><verb>
Language = fr
CharSet = latin1
</verb></tscreen>

Lisez ensuite <tt>.pgp/fr.hlp</tt> pour apprendre à vous servir de pgp !

<sect1>Impression en mode ascii<p>

Pour l'impression de texte simple, beaucoup d'imprimantes attendent des lettres
en codage IBM (cp850) comme sous MS DOS.

Si le fichier est codé en latin1, on doit utiliser « recode latin1:ibmpc »
(à placer dans les filtres lpr de /etc/ par exemple), sous peine de voir
imprimer des « alpha » à la place de « à », et autres choses du même genre.

Il existe d'autres utilisation au programme <tt/recode/ : « ibmpc:lat1 » ou
« lat1:ibmpc » (de ou vers MS-DOS) ou « applemac » pour Macintosh (tm).
   
<sect1>Unicode/latin/cp... je n'ai pas compris ce dernier paragraphe !<p>

Voici donc plus d'explications grâce à Pablo Sartxaga (srtxg à
chanae.alphanet.ch) dans un message explicant la différence Unicode/latin/cp :

<tscreen><verb>
 DB>   quand on lance « setfont » sans argument
 DB>   il semble qu'on obtienne le même effet que setfont -u none

Normal et logique.

 DB>   --> en un mot la table de conversion « Unicode » est désactivée
 DB>       ce qui transforme le « e accent aigü (dec 130) » en « théta (dec 233) »

Non. Il ne transforme rien du tout, il affiche tout simplement sans 
*aucune* transformation au contraire, à toi de t'assurer que la police
que tu charges possèdes les glyphes à la bonne place par rapport au codage
de caractères que tu utilises (iso-8859-1).

Autrement dit si ta police n'est pas iso-8859-1 tu dois dire à setfont de
faire des mappings; en particulier s ic'est une police qui utilise l'encodage
DOS cp437 tu fais « setfont -u cp437 nomdelapolice ». Moi par exemple j'aime
beaucoup la police « t.fnt » de la Slackware, et j'ai donc quelque part
dans /etc/rc.d/* une ligne « setfont -u cp437 t.fnt »

Ou alors tu modifies la police (il y a un logiciel qui fait cela avec
interface svgalib, et un autre nommé « chedit » qui permet de créer des
images an ascii-art, un fichier par caractère (256 fichiers donc), il te
suffit alors de jongler avec les fichiers pour les changer de place et
régénerer la police).  Note cependant que le codage cp437 n'inclut pas
tous les caractères de iso-8859-1, notamment manquent quasi toutes les
majuscules accentuées, et les lettres ãõ nécessaires en portugais. Tu
peux toujours modifier la police pour créer ces caractères manquants.

 DB>   sur ma Slackware 3.2, à aucun moment setfont n'apparaît dans les scripts
 DB>   de démarrage ni dans les ~/profiles et autres ~/.bashrc

Donc c'est la police dans la ROM de la carte video qui est utilisée.

 DB>   et pourtant cette
 DB>   conversion est effectuée correctement puisque j'ai les accents à l'écran.

Je suppose que le kernel présuppose (à juste titre) que la police en ROM vidéo
est au codage cp437.

 DB>        une fois que je lance « setfont -u none » je perds donc les accents.

Normal, car dès lors que tu charges une police tu est supposé savoir ce que
tu veux (au contraire de la police en ROM où tu n'as pas le choix).

Autrefois (du temps des 1.2.* et avant) le défaut de setfont était cp437
(et il n'utilisait pas encore des tables Unicode, mais on pouvait
changer par \e(B et \e(K entre codage cp437 et iso (on peut toujours 
d'ailleurs)), mais maintenant le défaut est « straight to font », pas de
conversion.

 DB>            j'en conclue que Linux utilise la police résidente par défaut de
 DB>            la carte EGA/VGA

 DB>        [Q] --> comment retrouver cette police ?

Il y a un programme nommé « restoretextmode » qui est assez populaire
auprès des possesseurs de certaines cartes graphiques chez qui le
passage X11 -> console bousille les polices; il permet de faire un dump
sur un fichier; il faudrait donc que tu le lances avant de modifier la
police avec setfont. Le paquetage s'appelle quelque chose comme
SVGATextMode ou quelque chose d'approchant.

 DB>     [Q] --> quelle table appeler pour la remapper et ravoir les accents ?

setfont -u cp437 policedos

Ou sinon, si tu ne veux pas lancer setfont et tu veux donc garder la
police de la carte graphique; essaye un « echo -e \033(B » (l'ennuyant
c'est que tu dois le faire dans chaque console)

 DB>                 (en général setfont -u def.uni (par exemple) renvoie une
 DB>                  erreur : PIO_UNIMAPCLR: Invalid argument et je reste
 DB>                  en caracteres « graphiques »)

Ah ? Chez moi ça marche; quels kernel et kbd as-tu ?

Sinon je te conseille « cp437 » plutôt que « def », ils font _presque_ la même
chose, mais « cp437 » est visuellement plus agréable car il remplace les
caractères non présents dans la police par les lettres non accentuées si c'est
des lettres, C pour © et R pour ® et par un carré blanc pour le reste, ce qui
permet de garder le formatage et la lecture agréables; « def » lui ne mets
totu simplement rien pour les caractères manquants, si bien que tu te
trouves avec des trous, ce qui est l'horreur si tu édites un texte par
exemple avec vi, puisque le curseur est affiché plusieurs caractères
à gauche à cause des caractères de largeur nulle :) 

Essaye aussi la police « t.fnt », elle est assez jolie, toute en rondeurs, je la
trouve réposante, et quand je dois utiliser un PC avec les polices style 
courier par défaut je trouve ça très agressif je me demande comment ils
peuvent travailler avec :)
</verb></tscreen>

Lire aussi les articles de news : « FAQ - les accents français et Usenet»  de F.
Yergeau dans les groupes fr.usenet.reponses et fr.usenet.8bits » ISO
8859-1 National Character Set FAQ» de mike (à) vlsivie.tuwien.ac.at dans
comp.answers .

<sect1>ncurses<p>

Rappelons que ncurses est un librairie C qui permet de manipuler facilement
l'affichage en mode console texte : fenêtrage, lignes de saisie, édition de
formulaires, couleurs, caractères « ALT » ascii semi-graphique ibm, comme sous
dos...

<sect2>Introduction<p>

La version standard de curses utilise le huitième bit pour la vidéo
inversée (voir le flag _STANDOUT défini dans /usr/include/curses.h).
Cependant, ncurses semble fonctionner en 8-bits et affiche le
iso-latin-8859-1 correctement.

<sect2>Les accents<p>

Remarque: les distributions de Linux sont livrées en général avec la
version 1.9.9e de ncurses, or il se trouve que la librairie form de
cette version est BUGGÉE (problèmes de rafraîchissement des fenêtres).

Ne pas utiliser la 1.9.9e donc si on veut travailler avec « form » : ce bug est
d'ailleurs clairement énoncé sur le site de ncurses, et je m'étonne que
ce soit justement cette version qui soit encore livrée sur la plupart
des distributions (RedHat 4.2, 5.0, 5.1, Slackware 3.2, Debian 1.9) en
tout cas.

Symptôme : la fonction  wgetch() de ncurses renvoie les codes suivants :

<itemize>
<item> je tape 'é' et wgetch retourne  « meta-i »    code 233 (decimal)
<item>  "  "   'è' "    "        "     « meta-h »    code 234 (decimal)
<item> etc
</itemize>

C'est normal avec les polices iso-8859-1 !

Il faut installer les « locales » ou mettre à jour sa version de
ncurses.

<sect1>Perl<p>

Si tout d'un coup après une mise à jour il raconte :

<tscreen><verb>
(guylhem@victis:guylhem)$ perl
perl: warning: Setting locale failed for the categories:
        LC_CTYPE LC_COLLATE
perl: warning: Please check that your locale settings:
        LC_ALL = "fr_FR",
        LC_CTYPE = "ISO-8859-1",
        LC_COLLATE = (unset),
        LANG = "fr"
    are supported and installed on your system.
perl: warning: Falling back to the "C" locale.
(guylhem@victis:guylhem)$
</verb></tscreen>

En libc6 le format des fichiers binaires de définition des locales a
(encore) changé : il faut les régénérer à partir des sources <htmlurl
name="sources WG15collection.tar.gz"
url="ftp://ftp.lip6.fr:/pub/linux/GCC"> par exemple et des programmes «
locale » et « localedef » qui sont fournis dans les sources de la libc.

Sinon on peut également se passer des locales :

<tscreen><verb>
     unset LANG
     unset LC_CTYPE
     unset LC_COLLATE
     export LC_ALL=fr_FR.ISO-8859-1
</verb></tscreen>

<sect1>Installer les locales<p>

Les « locales » sont des fichiers qui vont modifier le comportement de
certains programmes pour qu'ils s'adaptent aux « spécificités culturelles du
pays ».

Cela sert à résoudre les erreurs rapportées par perl ou une mauvaise
gestion des accents par ncurses.

<itemize>
<item> récupérer pour la libc5 la collection de
<htmlurl name="locales POSIX"
url="ftp://ftp.lip6.fr/pub/linux/GCC/WG15-collection.linux.tar.gz">
<item> ou pour la libc6, elle est dans l'ajout
<htmlurl name="« glibc-localedata »"
url="ftp://ftp.lip6.fr/pub/gnu/glibc-localedata-2.0.6.tar.gz">
<item> copier dans le répertoire /usr/share/locale les fichiers fr_FR et en_DK
(qui est inclus dans fr_FR)
<item> créer le répertoire /usr/share/i18n/charmap et copier le fichier
ISO_8859-1:1987
<item> faire man localedef et lancer la commande :

<tscreen><verb>
          localedef -f ISO_8859-1:1987 -i fr_FR fr
</verb></tscreen>

Ceci créera l'entrée fr dans /usr/share/locale soit :

<tscreen><verb>
        /usr/share/locale/fr
</verb></tscreen>

Ce répertoire devrait maintenant contenir les fichiers :

<tscreen><verb>
         LC_COLLATE
         LC_CTYPE
         LC_MESSAGES
         LC_MONETARY
         LC_NUMERIC
         LC_TIME
</verb></tscreen>

<item> lire le fichier « locale.fr » que l'on peut trouver sur le serveur
ftp.lip6.fr (chercher sous doc, linux...) et dont la traduction française a été
faite par &Eacute;ric DUMAS (hélas ce doc ne traite principalement que de
LC_MESSAGES. À quand la suite Éric ? ;-) )

<item> compléter éventuellement l'initialisation des variables du shell comme
décrit dans la section sur bash ou tcsh
<item> dans un programme, utilisez la fonction  setlocale() (man setlocale.3)
pour fixer les paramètres locaux CAR le noyau linux initialise toujours cette
fonction avec l'argument une locale « C » (POSIX) donc sans accents !

<tscreen><verb>
          setlocale(LC_CTYPE,"fr_FR");
</verb></tscreen>

<item> Ça y est ! Les accents sont disponibles dans ncurses.
</itemize>

<sect2>Midnight Commander (mc)<p>

En changeant de police, il peut arriver que les lignes de cadre soient
remplacées par divers caractères.

2 possibilitées :
<itemize>
<item> La police chargée ne dispose pas de caractères dits « semi
graphiques », qui permettent de dessiner des cadres
<item> Il y a discordance entre la police et sa table de mappage
</itemize>

Pour le premier cas, la seule solution est de changer de police, mais
dans le second cas, il suffit en général de charger la table avec
loadunimap par exemple :

<tscreen><verb>
          loadunimap lat1u.uni
          loadunimap lat5u.uni
          loadunimap lat9u.uni
</verb></tscreen>

<sect1>Kernel<p>

Pour mettre un support pour le clavier français directement dans le
kernel, ce qui est pratique pour les systèmes embarqués ou ne démarrant que sur
disquettes, afin de gagner le maximum de place :

<tscreen><verb>
/usr/bin/loadkeys loadkeys --mktable votre-table-de-clavier.map > /usr/src/linux/drivers/char/defkeymap.c
</verb></tscreen>

<sect1>Lilo<p>

Depuis la version 20, on peut spécifier un clavier (français, par
exemple) au démarrage de LILO.

Bien sur, cela ne fait qu'échanger quelques touches (a/q,m/:,... pour un
clavier fr) mais cela est assez utile lorsque l'on veut taper « win ».

Je vous conseille toutefois de ne pas faire de label utilisant des
touches qui diffèrent entre l'AZERTY et le QWERTY, ne serait-ce que si
vous devez avoir un jour un autre utilisateur sur votre ordinateur...

Il est plus simple de faire des labels courts et d'utiliser des
programmes comme GAG ou GRUB, remplaçant fort avantageusement les lignes
de lilo par un magnifique menu graphique dans le cas de GAG.

<sect1>Groff (man)<p>

Sur certaines distributions, le programme man n'est pas configuré pour
afficher les accents.

Si vous rencontrez ce problème, éditez son fichier de configuration
(/etc/man.config sur les distributions actuelles) et localisez une ligne
ressemblant à cela :

<tscreen><verb>
NROFF		/usr/bin/groff -Tascii -mandoc
</verb></tscreen>

Remplacez-là par :

<tscreen><verb>
NROFF		/usr/bin/groff -Tlatin1 -mandoc
</verb></tscreen>

Les vieilles versions de man utilisent aussi col, et le point suivant
s'applique aussi.

<sect1>Divers<p>

Une belle discussion sur le thème de l'ISO-8859-1 et sur « comment
manipuler les caractères 8-bits » est
<htmlurl name="disponible"
url="ftp://grasp.insa-lyon.fr/pub/faq/fr/accents">

<sect>Réglage du clavier pour les applications X

<sect1>Les xterminaux (xterm, nxterm, rxvt...)<p>

Les faire fonctionner avec toutes les touches standard du clavier 102 touches
relève du miracle, quant aux accents, seule une recompilation vous
permettra de les utiliser !

Pour xterm, essayez de mettre dans votre <tt>.Xdefaults</tt> :

<tscreen><verb>
XTerm*eightBitInput: true
XTerm*eightBitOutput: true
*customization: -color
XTerm*VT100*Translations: #override\n\
XTerm*pointerColor: red
None<Key>Begin: string(0x1b) string("[1~")\n\
None<Key>End: string(0x1b) string("[4~")\n\
None<Key>Prior: scroll-back(1,halfpage)\n\
None<Key>Next: scroll-forw(1,halfpage)\n\
Shift<Key>Prior: scroll-back(1,page)\n\
Shift<Key>Next: scroll-forw(1,page)
XTerm*fontMenu*fontdefault*Label: Default
XTerm*VT100*font: 9x15
XTerm*fontMenu*font1*Label: Illisible
XTerm*VT100*font1: nil2
XTerm*fontMenu*font2*Label: Minuscule
XTerm*VT100*font2: 5x7
XTerm*fontMenu*font3*Label: Petit
XTerm*VT100*font3: 6x10
XTerm*fontMenu*font4*Label: Normal
XTerm*VT100*font4: fixed
XTerm*fontMenu*font5*Label: Moyen
XTerm*VT100*font5: 7x13
XTerm*fontMenu*font6*Label: Tres grand
XTerm*VT100*font6: 10x20
</verb></tscreen>

Dans <tt>.inputrc</tt> :

<tscreen><verb>
# pour rxvt
"\e[7&tilde;":beginning-of-line
"\e[8&tilde;":end-of-line
# pour xterm
"\e[H": beginning-of-line
"\e[F": end-of-line
</verb></tscreen>

Mais ces deux solutions ne vous garantissent pas de résoudre tous les
problèmes de rxvt et de xterm ...

Pour les résoudre sans créer de fichiers dans
<tt>/usr/X11R6/lib/X11/app-defaults</tt>, je tiens sinon à votre
disposition un xiterm, un terminal X supportant *TOUTES* les touches des
claviers standard, avec Home, End, Page_Up (...) et même le
pavé numérique, fonctionnant comme en mode console, i.e.
Shift-Page_Up permettant de faire défiler une page, voire mieux : le
pavé numérique reconnaissant enfin la différence entre
Verr. Num allumé et Verr. Num éteint.

X international terminal (xiterm pour les intimes) est bien sûr sous GPL et
mis à jour pour suivre parallèlement l'évolution de rxvt.

Sur par exemple  <htmlurl name="mon site"
url="http://metalab.unc.edu/guylhem/xiterm"> vous trouverez donc xiterm,
qui remplace votre xterm classique en y apportant la couleurs, les
accents et les touches étendues.

Pour l'installer, compilez-le, devenez root et tapez :

<tscreen><verb>
rm /usr/X11R6/bin/xterm
rm /usr/X11R6/lib/X11/app-defaults/xterm
rm /usr/X11R6/lib/X11/app-defaults/rxvt
rm /usr/X11R6/lib/X11/app-defaults/Xterm
rm /usr/X11R6/lib/X11/app-defaults/XTerm
rm /usr/X11R6/lib/X11/app-defaults/Rxvt
rm /usr/X11R6/lib/X11/app-defaults/RXvt
cp xiterm /usr/local/bin

ln -sf /usr/local/bin/xiterm /usr/X11R6/bin/xterm
ln -sf /usr/local/bin/xiterm /usr/X11R6/bin/rxvt
</verb></tscreen>

<sect1>Les applications Motif<p>

Là, je n'ai malheureusement aucun remède miracle !

Il faudrait modifier le code source, code indiqué plus haut, pour
remplacer XLookupString par XmLookupString.

Utilisez les possibilités du fichier french au lieu des touches mortes
(AltGr (voyelle) : voyelle accent circonflexe... ) !

<sect1>Le manuel<p>

Pablo Saratxaga tient à votre disposition un xman modifié
pour qu'il supporte la variable « LANG » et puisse afficher les pages en
d'autres langues qu'anglais.

Il est disponible sur le lip6 en <htmlurl name="sources"
url="ftp.lip6.fr:/pub/linux/distributions/redhat-contrib/SRPMS/xman-3.1.6-3.src.rpm">
ou en <htmlurl name="binaires"
url="ftp.lip6.fr:/pub/linux/distributions/redhat-contrib/i386/xman-3.1.6-3.i386.rpm">

<sect1>NumLock<p>

Pour l'activer sous X, mettre en commentaire ServerNumLock dans la
section keyboard de XF86Config, puis rajouter au dessous Xleds 2, ce qui
allumera la led.

Attention, ce conseil ne s'applique que lorsque l'on n'utilise pas xkb,
i.e. qu'on met XkbDisable dans XF86Config...

<sect1>XDM<p>

/etc/X11/xdm/Xresources sert à ne rencontrer aucun problème avec les
touches « spéciales » (Home, End ...) sous X.

<tscreen><verb>
xlogin*login.translations: #override\
      Ctrl<Key>R: abort-display() \n\
      <Key>BackSpace: delete-previous-character() \n\
      <Key>Home: move-to-begining() \n\
      <Key>Delete: delete-character() \n\
      <Key>End: move-to-end() \n\
      <Key>Left: move-backward-character() \n\
      <Key>Return: set-session-argument() finish-field() \n\
      <Key>Right: move-forward-character()
</verb></tscreen>

<sect>Remerciements<p>

Ce document ne serait pas ce qu'il est sans l'aide de Nat Makarévitch
(nat à nataa.fr.eu.org) qui l'a relu et m'a aidé à le modifier de nombreuses
fois.

Un excellent document plus générique, traitant de l'installation par ex,
est le Guide du Rootard, disponible sur <htmlurl
name="freenix"
url="http://www.freenix.fr/linux/Guide"> ou <htmlurl
name="le lip6"
url="ftp://ftp.lip6.fr:/pub/linux/french/docs/">

Remercions enfin par ordre alphabétique ces contributeurs :
<verb>
Jean-Michel Antoine
Michel Billaud
Chmouel Boudjnah
Stephane Bortzmeyer
Denis Braussen
Rémy Card
Julien Cassaigne
Xavier Cazin
Laurent Chemla
René Cougnenc
Bruno Cornec
Yann Dirson
&Eacute;ric Dubreuil
&Eacute;ric Dumas
Arnaud Gomes-do-Vale
Pierre Ficheux
Laurent Frigault
Hugolino
Antoine Leca
Frederic Lepied
Jeannot Langlois
Stephane Marzloff
Marc Merlin
Thomas Parmelan
Frédéric Petit
Thomas Quinot
David Robert
Olivier Robert
Benjamin Ryzman
Pablo Saratxaga
Julien Simon
Loïc Tortay
J.M. Vansteene
</verb>

Surtout, si je vous oublie, signalez-le moi !
De même si vous ne voulez plus figurer dans cette liste...

Envoyez moi vos suggestions et modifications (guylhem à metalab.unc.edu), je me
ferai un plaisir de les intégrer dans les prochaines versions !

Signalez-moi aussi les erreurs : cet HOWTO est en perpétuel changement, avec
des nouveautés incluses à chaque version ; des erreurs peuvent facilement s'y
glisser !

</article>

