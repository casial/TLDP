<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<article id="Flash-Memory-HOWTO">

<articleinfo>


  <title>USB Flash Memory HOWTO</title>

  <author>
     <firstname> Niko</firstname>
     <surname> Sauer</surname>
     <affiliation>
       <orgname> Unit of Advanced Study</orgname>
       <orgdiv> University of Pretoria, South Africa</orgdiv>
       <address>
           <email> nikos@friedrichs.up.ac.za</email>
       </address>
     </affiliation>
  </author>


   <revhistory id="revhistory">
		<revision>
		<revnumber>0.06</revnumber>
		<date>2004-03-10</date>
		<authorinitials>ns</authorinitials>
		<revremark>Added section on Linux-2.6.</revremark>
		</revision>
		<revision>
		<revnumber>0.05</revnumber>
		<date>2003-12-26</date>
		<authorinitials>ejh</authorinitials>
		<revremark>Technical review.</revremark>
		</revision>
      <revision>
         <revnumber> 0.04</revnumber>
         <date> 2003-12-11</date>
         <authorinitials>ns</authorinitials>
      </revision>
      <revision>
         <revnumber> 0.03</revnumber>
         <date> 2003-12-02</date>
         <authorinitials> ejh</authorinitials>
          <revremark>
            Technical review.
          </revremark>
		</revision>
      <revision>
         <revnumber> 0.02</revnumber>
         <date> 2003-10-30</date>
         <authorinitials> ns</authorinitials>
          <revremark>
            Changed 2003-11-20
          </revremark>
      </revision>

   </revhistory>

  <abstract>

    <para>
     This document describes procedures for installing USB Flash
     Memory devices and the way of formatting them for various file
     systems such as vfat (the way they usually come) and ext2 (the
     way they fit in better with Linux). It is also described how to
     partition the device in two sections with different file types.
    </para>

  </abstract>

</articleinfo>




<!-- Section1: purpose-->

<sect1 id="purpose">
   <title> Purpose</title>


   <para>
    The purpose of this document is to describe procedures for
    implementing USB flash memory devices (memory sticks) on
    Linux. This entails the following:
   </para>
   
   <itemizedlist>
       <listitem>
         <para>
         making over-the-counter devices, pre-formatted for the MS
         Windows system, work on Linux;
         </para>
       </listitem>
       <listitem>
         <para>
         formatting the device in the ext2 filesystem on a single
         partition and making it work. This is intended for situations
         where the device will be used exclusively on Linux machines;
         </para>
       </listitem>
       <listitem>
         <para>
         formatting the device on a dual partition in the ext2 and
         vfat filesystems and making it work. The purpose of this
         is for situations where Linux + Linux and Linux + Windows are
         possible;
         </para>
       </listitem>
       <listitem>
         <para>
         making the device more user friendly;
         </para>
       </listitem>
       <listitem>
         <para>
         maintaining the filesystem of the device;
         </para>
       </listitem>
       <listitem>
         <para>
         using additional features of Linux-2.6.x.
         </para>
       </listitem>
   </itemizedlist>


   <para>
    The procedures described in this document should work on
    any USB memory stick device which can be operated as a read-write
    device. Read-only devices do not fall in this category. The
    procedures will not work if the write facility of the device is
    disabled (i.e. if the write protect switch is on).
   </para>

   <para>
    The procedures described for formatting and maintenance in
    particular filesystems may (in principle) be adapted for other
    filesystems such as ext3 and reiserfs. These have not been tried
    and tested. Neither has any attention been paid to adaptation of
    the procedures to other related operating systems.
   </para>


   <warning><para>
    It may be dangerous to re-format the flash memory
    intended for a digital camera. The camera may then be unable to
    understand it. Use the camera's built-in menu system to do this
	 reformatting for you.
	 <!-- added the last sentence -->
   </para></warning>

</sect1>

<!-- End Section1: purpose -->
<!-- Section1: buying -->
<!-- Sect1: Physical -->

<sect1 id="physical">
   <title>Physical devices</title>

   <para>
    Flash memory devices come mainly in the form of small, portable
    devices often referred to as <emphasis>memory sticks</emphasis> or
    <emphasis>keychains</emphasis>, and as part of digital
    cameras. They are <emphasis>non-volatile devices</emphasis> which
    operate on the principle that electric charges are used to
    represent data in binary format. These charges can remain
    unchanged almost indefinitely, but changes (such as writing to the
    device) limit the life span of the device (100000 writes of 8MB
    each).
   </para>
   
   <para> 
    Memory sticks plug directly into a USB-port at the back of your
    computer. The power it needs is supplied by the USB-port. It is
    sometimes convenient to use a USB-extension cable to bring the
    device within easy reach. 
   </para>
   
   <para>
    Memory sticks usually have <emphasis>write protect
    switches</emphasis> which should be turned off if you want to use
    it as read-write device. If the switch is in the <quote>on</quote> position,
    the device is <emphasis>read-only</emphasis>. The devices are
    usually equipped with a led (light emitting diode), which
    indicates that the device is operational. The led also flickers
    while data is being transferred to or from the device.
   </para>

   <para>
    Digital cameras use flash memory for image storage. These are 
    powered by the camera and connected to the computer's USB-port via
    an electronic interface. To be able to connect to the computer,
    the camera's power must be turned on for the duration of the
    interfacing, and should only be turned off after the device had
    been unmounted from the computer. It is important to remember that
    the device takes power from the camera's battery. The operation
    should therefore be terminated as soon as possible.
   </para> 
 
</sect1>

<!-- End Section1: physical -->


<sect1 id="buying">
   <title> Buying a memory stick</title>	
	
	<para>
    Important considerations when buying a memory stick are the
    following:
   </para>
	
	<variablelist>
	
	<varlistentry>
	<term><emphasis role="strong">The size of the memory</emphasis></term>
	<listitem>
	<para>
		This will depend on whatever use you have in mind. 128MB seems to be
		a popular choice.
	</para>
	</listitem>
	</varlistentry>
	<varlistentry>
	<term><emphasis role="strong">Is it known to work on Linux?</emphasis></term>
	<listitem>
	<para>
    The established brands have web sites in which this may be stated
    explicitly. Alternatively, ask the supplier. But beware: the sales
    person may not know what you are talking about. The instruction
    leaflet may also mention something like: Works on Linux-2.4, or
    may have a picture of the Linux penguin. If these inquiries fail, it
    may be wise not to buy.  
	</para>
	</listitem>
	</varlistentry>
	<varlistentry>
	<term><emphasis role="strong">Extension cable and keychain</emphasis></term>
	<listitem>
	<para>
    Memory sticks usually are packaged with an extension cable 
    (<xref linkend="physical" />) and a keychain. The latter provides
    a safe and with-it way of transporting the device. Make sure that
    these are included. You may need an additional extension cable,
    depending on circumstances. Laptop and notebook computers usually
    don't need them.
	</para>
	</listitem>
	</varlistentry>
	<varlistentry>
	<term><emphasis role="strong">File system</emphasis></term>
	<listitem>
	<para>
    Over-the-counter memory sticks are usually formatted in vfat
    (msdos), and this will work in Linux, but you will not have the
    strength and versatility of the standard ext2 (or other) file
    system. This is not a problem. It can be endowed with other file
    systems as will be described later in this document.
	</para>
	</listitem>
	</varlistentry>
	<varlistentry>
	<term><emphasis role="strong">Cost</emphasis></term>
	<listitem>
	<para>
    Prices of memory sticks of a given size may vary considerably. It
    is a good idea to find out what that range is. The internet is
    excellent for the purpose.
	</para>
	</listitem>
	</varlistentry>
	</variablelist>

</sect1>

<!-- End Section1: buying -->

<!-- Section1: reading -->

<sect1 id="reading">
   <title> Reading</title>

   <para> 
    Users of this document might want to acquaint themselves with
    the following:
     <footnote id="ftn-heavy-dependencies">
        <para>
         This document leans heavily on the texts marked with an asterisk
        </para>
     </footnote>
   </para>
 
   <itemizedlist mark="none" spacing="compact">
      <listitem>
        <simpara>
          Manual pages of the following tools:
          <application>mount</application>,
			 <application>umount</application>, <application>fdisk</application>, <application>mke2fs</application>, <application>mkdosfs</application>,
          <application>dumpe2fs</application>> and <application>fsck.ext2</application>.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <ulink url="http://www.tldp.org">
            Linux documentation project
          </ulink>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <ulink url="http://www.tldp.org/HOWTO/USB-Digital-Camera-HOWTO">
            USB-Digital Camera HOWTO
          </ulink>*
        </simpara>
       </listitem>
      <listitem>
        <simpara>
          <ulink url="http://www.tldp.org/HOWTO/Partition"> The Linux 
            Partition HOWTO
          </ulink>*
        </simpara>
      </listitem>
      <listitem>
        <simpara>
         <ulink 
           url="http://www.tldp.org/HOWTO/The Linux SCSI-2.4-HOWTO">
           The Linux 2.4 SCSI subsystem HOWTO
         </ulink>
        </simpara>
      </listitem> 
      <listitem>
        <simpara>
         <ulink url="http://www.tldp.org/HOWTO/Kernel-HOWTO">
           The Linux Kernel HOWTO
         </ulink>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
         <ulink url="http://www.linux-usb.org/USB-guide/book1.html">
           The Linux USB subsystem
         </ulink>*
        </simpara>
      </listitem>
      <listitem>
        <simpara>
         <ulink url="http://www.tldp.org/guides.html">
           Linux filesystem hierarchy
         </ulink>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
         <ulink url="http://www.tldp.org/guides.html">
           The Linux Kernel
         </ulink>
        </simpara>
      </listitem>
      <listitem>
        <simpara>
           Linux Kernel 2.4.xx/Documentation (should be in
           <filename> /usr/src/linux/Documentation</filename> )
        </simpara>
       </listitem>
   </itemizedlist>

</sect1>

<!-- End Section1: reading -->

<!-- Section1: hardware -->

<sect1 id="hardware">
   <title> Hardware and kernel</title>

 <!-- Section2: setup -->

 <sect2 id="setup">
   <title> Setup</title>

   <para>
    This is a description of the salient features of the setup used to
    develop the procedures described below. All the procedures have
    been tried and tested, also for Linux-2.6. The screen-like
    displays are precise copies of what appeared on my screen.
   </para>

   <itemizedlist mark="none" spacing="compact">
     <listitem>
      <simpara>
       Hardware: Intel (R) Celeron (TM) 1100 MHz
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Distribution: RedHat Linux 7.0 (extensively modified)
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Kernel: Linux-2.4.20 (from www.kernel.org). See also
       <xref linkend="linux-2.6"/> for Linux-2.6.x.
      </simpara>
     </listitem> 
     <listitem>
      <simpara>
       Tools: util-linux-2.11z (<application>mount</application>, <application>umount</application>, <application>fdisk</application>); 
          e2fsprogs-1.32 (<application>mke2fs</application>, <application>dumpe2fs</application>, <application>fsck.ext2</application>);
          mkdosfs-2.2
      </simpara>
     </listitem>
   </itemizedlist>

 </sect2>
 
 <!-- Section2: kernel -->

 <sect2 id="kernel">
 <title> Kernel options</title> 

   <para>
    It is uncertain if USB-support is sufficient in kernels earlier
    than 2.4.xx. The following support, relevant to this document, was
    compiled into the kernel. A modular approach may also be followed.
   </para>

 <!-- Section3: scsi -->

 <sect3 id="scsi">
 <title> SCSI support</title>

   <itemizedlist mark="none" spacing="compact">
     <listitem>
      <simpara> SCSI support (CONFIG_SCSI  scsi_mod.o)</simpara>
     </listitem>
     <listitem>
      <simpara> SCSI disk support (CONFIG_BLK_DEV_SD  sd_mod.o)</simpara>
     </listitem>
   </itemizedlist>

 </sect3>

 <!-- Section3: fss -->

 <sect3 id="fss">
 <title> File systems</title>         

   <itemizedlist mark="none" spacing="compact">
     <listitem>
      <simpara> DOS FAT fs support (CONFIG_FAT_FS  fat.o)</simpara>
     </listitem>
     <listitem>
      <simpara> MSDOS fs support (CONFIG_MSDOS_FS  msdos.o)</simpara>
     </listitem>
     <listitem>
      <simpara> 
        VFAT (Windows 95) fs support (CONFIG_VFAT_FS  vfat.o)
	</simpara>
     </listitem>
     <listitem>
      <simpara> /proc filesystem (CONFIG_PROC_FS)</simpara>
     </listitem>
     <listitem>
      <simpara> 
        Second extended fs support (ext2fs) (CONFIG_EXT2_FS  ext2.o)
      </simpara>
     </listitem>
   </itemizedlist>
 
 </sect3>

 <!-- Section3: usb -->

 <sect3 id="usb">
 <title> USB support</title>
       
   <itemizedlist mark="none" spacing="compact">
     <listitem>
      <simpara> Support for USB (CONFIG_USB  usbcore.o)</simpara>
     </listitem>
     <listitem>
      <simpara> 
        Preliminary USB device filesystem (CONFIG_USB_DEVICEFS)
      </simpara>
     </listitem>
     <listitem>
      <simpara> 
        USB Mass Storage support (CONFIG_USB_STORAGE  usb-storage.o)
      </simpara>
     </listitem>
   </itemizedlist>

  </sect3>
  </sect2>

  <sect2 id="notes">
  <title>Notes</title>
    
    <para>
     In the lists above the entities in uppercase refer to the
     variable names to be found in the <filename>.config</filename>
     file in the upper level directory of the kernel source (<filename
     class="directory">/usr/src/linux/</filename>). The entities
     <filename>xxx.o</filename> refer to the modules created when a
     modular approach is followed. When there is no reference to a
     module, the option can only be hard-compiled into the kernel.
    </para>
     
    <para>
     Different kernel versions may have different indications of
     options when, for example, <emphasis>make menuconfig</emphasis>
     or <emphasis> make xconfig</emphasis> are run. Variables such
     as CONFIG_USB, which can be gleaned from the various <emphasis>
     help</emphasis> options, may be a more reliable indication.
    </para>

    <para>
     Very recent Linux distributions such as
     <emphasis>RedHat</emphasis> and <emphasis>SuSE</emphasis>
     probably have the appropriate kernel options compiled in.
    </para>

    <para>
     Under USB-support, options for a number of digital cameras are 
     available.
    </para>

    <para>
     Please consult the relevant texts as set out in 
     <xref linkend="reading"/> if you consider (re)compiling your 
     kernel.
    </para>
 
  </sect2>

</sect1>

<!-- End Section1: hardware -->

<!-- Section1: Basics -->
<sect1 id="basics">
   <title> Some basic concepts</title>    

   <para>
    In this section we discuss in a very brief manner, some basic
    Linux concepts which should contribute to an understanding of the
    procedures described below.
   </para>

  <sect2 id="proc">
    <title>The /proc filesystem</title>

    <para>
      The /proc filesystem serves as a window through which we can see
      the workings of a Linux setup. The objects of most interest for
      this document are the directories<filename
      class="directory">/proc/bus/usb/</filename> and <filename
      class="directory">/proc/scsi/</filename>. These will be used to
      verify that the kernel had been set up properly for our purpose
      (<xref linkend="proc-probe" />). 

    </para>
  </sect2>

 <sect2 id="scsidev">
 <title> SCSI devices</title>

   <para>
    Your memory stick will be considered as a USB mass storage device
    posing as a removable SCSI disk (sd).  SCSI disk devices are
    mapped to the <filename class="directory"> /dev</filename>
    (devices) directory under <filename class="directory">
    /dev/sda</filename> , <filename class="directory">
    /dev/sdb</filename> , ... When different disk devices are present,
    they will be mapped to <filename>/dev/sda</filename>,
    <filename>/dev/sdb</filename>, etc.  If, for example, a memory
    stick and a digital camera are plugged in, the one would be mapped
    to <filename>/dev/sda</filename> and the other to
    <filename>/dev/sdb</filename>. Tests have indicated that the first
    device to be detected is mapped to <filename>sda</filename> and
    represented in the directory <filename
    class="directory">/proc/scsi/usb-storage-0</filename>. The second
    will be mapped to <filename>sdb</filename> and represented in
    <filename class="directory">/proc/scsi/usb-storage-0</filename>.
    What will happen when both devices are present at boot-up, is not
    known. An overview of the partitions relevant to this document,
    the file <filename>/proc/partitions</filename> may be consulted.
    Look for entries like <filename>sda, sda1, sdb</filename>. Under
    the Linux-2.6 series of kernels this problem may be very neatly
    resolved (<xref linkend="linux-2.6"/>).


    </para>
    
   <para>
    In the descriptions further on, it will be assumed that only one
    memory stick is present, and therefore mapped to 
    <filename>/dev/sda</filename>.
   </para>

   <para>
    In most distributions these points exist in abundance. You should
    check that this is the case in your setup
	 (<userinput><command>ls</command> /dev/sda*</userinput>. If there are none you can create them by
    doing (as root, indicated by the hash).
   </para>

   <screen>
             <prompt>#</prompt> <userinput><command>mknod</command> /dev/sda  b 8 0</userinput>
             <prompt>#</prompt> <userinput><command>mknod</command> /dev/sda1 b 8 1</userinput>
             <prompt>#</prompt> <userinput><command>mknod</command> /dev/sda2 b 8 2</userinput>
   </screen>
        
   <para>
    etc, up to <filename>/dev/sda15</filename> if necessary. The
    device as a whole is mapped to <filename>/dev/sda</filename>,
    while <filename>/dev/sdax (x = 1 ... 15)</filename> represent
    the various partitions of the device. We shall describe, later on,
    how to create different partitions for different file systems (see
    <xref linkend="ext2" /> and <xref linkend="mixed" /> ). If you
    intend to use your memory stick with a single partition
    (filesystem), <filename>/dev/sda1</filename> is sufficient. 
   </para>
 </sect2>

  <sect2 id="usbfs">
  <title> The USB device filesystem</title>
    <para>
     This dynamically generated filesystem should be mounted at
     <filename class="directory">/proc/bus/usb/</filename>. It is
     therefore essential that this mount point exists. Once it is
     mounted, there should be more to be seen in <filename
     class="directory">/proc/bus/usb/</filename> and in <filename
     class="directory">/proc/scsi/</filename> (<xref
     linkend="mounting" />). To find out which USB devices are
     present, read the file <filename>/proc/bus/usb/devices</filename>
     (<command> less /proc/bus/usb/devices</command>). It takes a
     small effort to interpret the writing on the screen, but it is
     not difficult. A memory stick is indicated by <emphasis>Mass
     Storage Device</emphasis>.
    </para>
  </sect2>

  <sect2 id="ext2fs">
  <title>The ext2 filesystem</title>
    <para>
     The ext2 (second extended) filesystem still is the most prevalent
     in Linux setups. It is most versatile and sophisticated, carrying
     with it permissions (read-write-execute, who is permitted to do
     what), ownership (user, group, others), a timestamp (when last
     modified), etc. Moreover, tools for the proper maintenance of a
     device endowed with ext2, exist (<xref linkend="maintain"/>).  If
     a flash memory device is to be used exclusively within Linux
     setups, it is therefore desirable to format it in ext2 (see <xref
     linkend="ext2" />).
    </para>
   </sect2>

  <sect2 id="vfatfs">
  <title>The vfat filesystem</title>
    <para>
     Enabling vfat in the kernel makes it possible to mount
     filesystems created under Dos/Windows to be mounted in a Linux
     system. Most memory sticks are formatted for direct use on
     Windows and should therefore be considered as vfat-formatted. The
     vfat filesystem is less sophisticated than ext2 and will
     therefore be more economic as far as memory space is
     concerned. It does not carry permissions in the same way as ext2
     with the result that an ext2-file saved in vfat will re-appear
     with its permissions changed. Nonetheless, if a memory stick is
     to be used for the purpose of carrying data between Linux and
     Windows machines, it is best to keep it in the vfat format. A
     compromise is to partition the memory stick in two parts: one in
     vfat and the other in ext2. At least the Linux machine should be
     able to handle both. This is described in <xref linkend="mixed"/>
    </para>
  </sect2>

  <sect2 id="options">
  <title>Explanation of command options</title>

   <para>
    Here is a short list of command options that occur in this
    document:
   </para>

   <itemizedlist mark="none" spacing="compact">
     <listitem>
      <simpara> 
       <userinput><command>mount</command> -t ext2 /dev/sda1 /mnt/memstick</userinput> 
       Mount in filetype ext2, device sda1 at mountpoint /mnt/memstick
      </simpara>
     </listitem>
     <listitem>
      <simpara> 
       <userinput><command>ls</command> -l</userinput>
       Make a complete list (modes, ownerships, etc.)
      </simpara>
     </listitem>
     <listitem>
      <simpara> 
       <userinput><command>mkdosfs</command> -F 32 /dev/sda1</userinput>
       Create an ms-dos filesystem, FAT-size 32, on the
            partition /dev/sda1
      </simpara>
     </listitem>
     <listitem>
      <simpara> 
       <userinput><command>ln</command> -s /dev/sda1 /dev/flash</userinput>
      	link, symbolically, the existing /dev/sda1 to 
         the symbolic /dev/flash
      </simpara>
     </listitem>
     <listitem>
      <simpara> 
       <userinput><command>mkdir</command> -m 777
		 /mnt/memstick/superdir</userinput>
        create a new directory with mode rwx for user, group and others
      </simpara>
     </listitem>
     <listitem>
      <simpara> 
       <userinput><command>dumpe2fs</command> -h /dev/sda1</userinput>
       Show the header of the ext2 partition /dev/sda1
      </simpara>
     </listitem>
   </itemizedlist>
  </sect2>  

</sect1>

<!-- Section1: verifications -->

<sect1 id="verifications">
   <title>Basic verifications</title>

<important>
  <para>
   In order to make sure that the device you look at and write on is
   the one intended, it is best to remove similar devices from
   the USB-bus before starting these procedures.
  </para>
</important>

 <!-- Section2: quick check -->
 
 <sect2 id="quick">
 <title>A quick check</title>
 
   <para>
    It is possible that your system is already set up for handling a
    USB-flash memory device. To check this, simply issue the command 
    <prompt>$ </prompt><userinput><command>mount</command></userinput> from an X-terminal. If something like
   </para>

      <screen>
           none on /proc/bus/usb type usbfs (rw)
      </screen>

   <para>
    appears among the output, you are ready to go to 
    <xref linkend="tests" /> and proceed from there. It may be
    virtuous, however, to glance through the intervening sections.
    If the test is unsuccessful, all is not lost. Please read on.
   </para>
 
</sect2>
 
 <!-- Section2: proc -->

 <sect2 id="proc-probe">
 <title> Probing the /proc filesystem</title>
 
   <para>
    A few things in the <filename class="directory"> /proc</filename>
    directory can be checked so see if the kernel options have been
    properly included or the appropriate modules properly inserted. As
    a first check, see if the directory <filename
    class="directory">/proc/bus/usb</filename> exists. If it does,
    your kernel supports the USB-subsystem correctly. If this is not
    the case the kernel has to be re-compiled with appropriate USB
    support (see <xref linkend="usb" />) or the kernel has to be
    updated. Next, check if the directory <filename
    class="directory">/proc/scsi</filename> exists. If it does, you're
    well-away. If it doesn't, SCSI support has not been compiled into
    your kernel (see <xref linkend="scsi" />).
   </para>

   <para>
    In <filename class="directory"> /proc</filename> there should be
    provision for a mount point for the USB filesystem. That point is
    <filename class="directory"> /proc/bus/usb</filename>. If it
    exists, the kernel is correctly set up.  
   </para>

 </sect2>

 <!-- Section2: scsidev -->



 <!-- Section2: mounting -->

 <sect2 id="mounting">
 <title> Mounting the USB filesystem</title>

   <para>
    If the verifications of the previous sections were positive, the
    next step is to mount the USB filesystem. This is issued from root
    as follows:
   </para>

   <screen>
             <prompt># </prompt><userinput><command>mount</command> -t usbfs none /proc/bus/usb </userinput>
   </screen>
   <note>
   <para>
    In older kernel versions the mount command above may have to
    be changed by replacing <parameter>usbfs</parameter> with
    <parameter>usbdevfs</parameter>. In Linux-2.4.20 both forms work.
   </para>
   </note>
   <para>
    If there are no complaints, do some more tests. The first is the
    quick test (<xref linkend="quick" />).  A deeper probe would be to
    issue the command <prompt># </prompt><userinput><command>ls</command> -l /proc/bus/usb</userinput> . This
    should give something similar to
   </para>

   <screen>
             dr-xr-xr-x 1 root root 0  Sep 19  14:21  001
             dr-xr-xr-x 1 root root 0  Sep 19  14:21  002
             -r--r--r-- 1 root root 0  Sep 19  22:30  devices 
             -r--r--r-- 1 root root 0  Sep 19  22:30  drivers
   </screen>

   <para>
    The path <filename class="directory">
    /proc/scsi/usb-storage-0/</filename> should now exist and one of
    the files at the end will show this. In my setup the command
    <prompt>$ </prompt><userinput><command>less</command> /proc/scsi/usb-storage-0/1</userinput> gives
   </para>
    
   <screen>
                Host scsi1: usb-storage  
                    Vendor: Generic  
                   Product: Mass Storage Device  
             Serial Number: None  
                  Protocol: Transparent SCSI  
                 Transport: Bulk  
                      GUID: 0ed166800000000000000000  
                  Attached: Yes/No  
   </screen>

   <para>
    If the flashdrive is present, the last line will have the entry
    "Yes". If it is not plugged in, the entry will be "No".
   </para>  
 

 </sect2>

 <!-- Section2: tests -->

 <sect2 id="tests">
 <title> Tests -- vfat</title>

   <para> You are now ready to find out if the memory stick is
   working. Let us suppose that you bought it over the counter. Its
   instruction leaflet will most likely tell you how to set it up for
   Windows. That is an indication that it is formatted in vfat. Before
   you try to mount it, create a mount point for it. Do something like
   <prompt># </prompt><userinput><command>mkdir</command> -m 777
   /mnt/memstick</userinput>. The mounting command would most likely
   be
   </para>

   <screen>
    <prompt># </prompt><userinput><command>mount</command> -t vfat /dev/sda1 /mnt/memstick</userinput>
   </screen>


   <para> 
    If everything went smoothly, you should be able to see the device:
    <prompt># </prompt><userinput><command>ls</command>
    /mnt/memstick</userinput>.
   </para>

   <para> 
    Now try some standard things like making a directory on the device
    and copying a favourite text file to it:
   </para>

   <screen>
             <prompt># </prompt><userinput><command>mkdir</command> /mnt/memstick/apollo </userinput>
             <prompt># </prompt><userinput><command>cp</command> /home/myname/myfavourite_file /mnt/memstick/apollo/.</userinput>
   </screen>

    <para> 
    List again (<prompt># </prompt><userinput><command>ls</command> -l /mnt/memstick</userinput> ) and
    pay attention to the permissions.
    </para>

    <para> 
     Unmount the device (<prompt>#
     </prompt><userinput><command>umount</command>
     /dev/sda1</userinput> ) and mount it again as above. List again
     and check the permissions. Most likely your favourite text file
     will now have an x-permission. It became executable. That is
     normal in the vfat filesystem. If you are happy with that,
     unmount the device and skip to <xref linkend="users" /> .
    </para>

 </sect2>

</sect1>

<!-- End Section1: verifications -->

<!-- Section1: ext2 -->

<sect1 id="ext2">
<title> Setting up an Ext2 filesystem</title>

<para>
  The procedures described here will give the entire flash memory
  device a single partition endowed with the ext2 filesystem. This
  will make the device more suitable for use between Linux machines.
  Don't do this if the device is supposed to operate between
  Linux and Windows machines.
</para>

<important>
  <para>
    The device associated with <filename>/dev/sda</filename> will be
    re-formatted. Any data present on it will be destroyed. To make
    sure that the device you work with is the one intended, remove
    similar devices from the USB-bus before starting these procedures.
  </para>
</important>



 <!-- Section2: partitioning -->

 <sect2 id="partition">
 <title> Partitioning</title>

   <para>
    It is assumed that the flash memory is mapped to <filename>
    /dev/sda</filename>. In this section we treat the situation where
    the whole flash memory device will become devoted to a single ext2
    partition. In the example procedure shown below, a 128MB flash
    memory was formatted for ext2. That is why figures like 131MB and
    888 cylinders appear. The fdisk tool, which is used, simply reads
    that from the device.
   </para>

   <para> 
    All operations are done by root. The single partition will be
    created on <filename> /dev/sda</filename>
    (please note: not <filename>
    /dev/sda1</filename> ) The procedure is described in a series of
    steps with comments. The standard prompt of
    <application>fdisk</application> is <prompt> Command (m for
    help):</prompt> and you can, at any stage enter
    <userinput>m</userinput> to see the available commands. If you do
    that the result would be
   </para>

   <screen>
             Command   action 
                a      toggle a bootable flag 
                b      edit bsd disklabel 
                c      toggle the dos compatibility flag 
                d      delete a partition 
                l      list known partition types 
                m      print this menu 
                n      add a new partition 
                o      create a new empty DOS partition table 
                p      print the partition table 
                q      quit without saving changes 
                s      create a new empty Sun disklabel 
                t      change a partition's system id 
                u      change display/entry units 
                v      verify the partition table 
                w      write table to disk and exit 
                x      extra functionality (experts only) 
   </screen>


   <para>
    Your memory stick must be plugged in, but not mounted. Take care
    that write protect is off.
   </para>

   <para> Here goes:</para>

   <screen>
             <prompt>#</prompt><userinput><command> fdisk</command> /dev/sda</userinput> 
             Command (m for help):<userinput>d</userinput> {enter }
             Selected partition 1  
             Command (m for help):<userinput>n</userinput> {enter} 
             Command action  
                e  extended  
                p  primary partition (1-4)  
             <userinput>p</userinput> {enter}  
             Partition number (1-4):<userinput>1</userinput> {enter} 
             First cylinder (1-888, default 1): {press enter} 
             Using default value 1  
             Last cylinder ... (1-888, default 888): {press enter} 
             Using default value 888  
   </screen>

   <para> 
    Now is a good time to verify that all went well by printing out
    the partition details and table.
   </para>

   <screen>
             Command (m for help): <userinput>p</userinput> 
             Disk /dev/sda: 131 MB, 131072000 bytes  
             9 heads, 32 sectors/track, 888 cylinders  
             Units = cylinders of 288 * 512 = 147456 bytes 

             Device     Boot Start End Blocks Id System 
	  
             /dev/sda1         1   888 127856 83 Linux 
   </screen>

   <para>
    Make sure that the partition is not set up as bootable. There
    should not be an asterisk under the heading "Boot" in the
    partition table. Furthermore, the headings "Id" and "System"
    should be as they are in the printout shown above. That indicates
    that you can format the device in ext2 (next section). These are
    the defaults. If they are not, they can be changed by
   </para>

   <screen>
             Command (m for help): <userinput>a</userinput> [toggle a bootable flag] 
             Command (m for help): <userinput>t</userinput> [change a partition's system id] 
   </screen>

    <para> 
     If (or when) the partition table is correct, you can conclude the
     procedure with
    </para>

    <screen>
             Command (m for help): <userinput>w</userinput> [write table to disk and exit] 
    </screen>

    <para> That's it!</para>                         

 </sect2>

 <!-- Section2: making-ext2 -->
 <sect2 id="making-ext2">
 <title> Making an ext2 device</title>

   <para> 
    Having completed the partition part, we go straight on to
    "formatting" the device in ext2. For this we use the tool
    mke2fs. This is straightforward.
   </para>

   <screen>
             <prompt>#</prompt> <userinput><command>mke2fs</command> /dev/sda1</userinput> 
   </screen>

   <para>
    You might like to watch the led on your memory stick flicker
    while this is happening. When it stops, the job is done.
   </para>

 </sect2>

 <!-- Section2: tests4 -->

 <sect2 id="tests4">
 <title> Tests -- ext2</title>

   <para> 
    To see if you were successful, essentially repeat the procedures
    described in <xref linkend="mounting" /> and <xref linkend="tests"
	 />
    with two exceptions of detail. In the first place the mount
    command should be
   </para>

   <screen>
             <prompt>#</prompt> <userinput><command>mount</command> -t ext2 /dev/sda1 /mnt/memstick</userinput> 
   </screen>

   <para> 
    The second exception is that the permissions on your favourite
    text file should not change anymore.
   </para>

 </sect2>
</sect1>

<!-- End Section1: ext2 -->

<!-- Section1: mixed -->

<sect1 id="mixed">
<title> Setting up a dual partition</title>

 <!-- Section2: double-partition -->

 <sect2 id="double-partition">
 <title> Partitioning</title>
<para>
  The procedures described here will partition the flash memory device
  in two pieces -- one of the partitions will be formatted in ext2 and
  the other in vfat. This may be handy when the device is to be used
  to transport data between two (or more) Linux machines (ext2) and between Linux
  and Windows machines (vfat)
</para>

<important>
  <para>
    The device mapped to <filename>/dev/sda</filename> will be
    re-formatted. Any data present on it will be destroyed.  To make
    sure that the device you work with is the one intended, remove
    similar devices from the USB-bus before starting these procedures.
  </para>
</important>

   <para> 
    In this section we describe how to set up a dual partition for
    the memory stick: One half of the device will be
    devoted to the vfat filesystem, and the other will be ext2. In
    this way your device will be more versatile, but also a little
    shattered. The procedure will be given in somewhat less detailed
    than in <xref linkend="partition" /> . Note that the procedure
    of the previous section is repeated and that the hex code for 
    each file type is explicitly entered (lines following the entry 
    "t": Win95 = b; Linux = 83). When the partition will only be for
    Linux, this is unnecessary -- Linux is the default. Also note that
    the vfat partition goes on first -- that is the way Windows would 
    have it.
   </para>

   <screen>
             <prompt>#</prompt> <userinput><command>fdisk</command> /dev/sda</userinput>
	    
             <prompt>Command (m for help):</prompt> <userinput>d</userinput>
             <computeroutput>Selected partition 1</computeroutput>

             <prompt>Command (m for help):</prompt> <userinput>n</userinput>
             <computeroutput>Command action
                e   extended
                p   primary partition (1-4)</computeroutput>
             <userinput>p</userinput>
             <prompt>Partition number (1-4):</prompt> <userinput>1</userinput>
             <prompt>First cylinder (1-888, default 1): </prompt>
             <computeroutput>Using default value 1</computeroutput>
             <prompt>Last cylinder or +size or +sizeM or +sizeK (1-888,
                   default 888):</prompt><userinput>444</userinput>
             <prompt>Command (m for help):</prompt> <userinput>t</userinput>
             <computeroutput>Selected partition 1</computeroutput>
             <prompt>Hex code (type L to list codes):</prompt> <userinput>b</userinput>
             <computeroutput>
              Changed system type of partition 1 to b (Win95 FAT32)
             </computeroutput>
             <prompt>Command (m for help):</prompt> <userinput>n</userinput>
             <computeroutput>Command action
                e   extended
                p   primary partition (1-4)</computeroutput>
             <userinput>p</userinput>
             <prompt>Partition number (1-4):</prompt> <userinput>2</userinput>
             <prompt>First cylinder (445-888, default 445): </prompt>
             <computeroutput>Using default value 445</computeroutput>
             <prompt>
              Last cylinder or +size or +sizeM or +sizeK (445-888,
              default 888): 
             </prompt>
             <computeroutput>Using default value 888</computeroutput>

             <prompt>Command (m for help):</prompt> <userinput>t</userinput>
             <prompt>Partition number (1-4):</prompt> <userinput>2</userinput>
             <prompt>Hex code (type L to list codes):</prompt> <userinput>83</userinput>

             <prompt>Command (m for help):</prompt> <userinput>p</userinput>

             <computeroutput>
				 Disk /dev/sda: 131 MB, 131072000 bytes
             9 heads, 32 sectors/track, 888 cylinders
             Units = cylinders of 288 * 512 = 147456 bytes

                Device Boot    Start       End    Blocks   Id  System
             /dev/sda1             1       444     63920    b  Win95 FAT32
             /dev/sda2           445       888     63936   83  Linux
				 </computeroutput>

             <prompt>Command (m for help):</prompt><userinput>w</userinput>

   </screen>
 
   <note><para>
    Note that we went on with the second partition before writing.
   </para></note>

   <para>
    The choice of splitting the device right in the middle (1--444;
    445--888 for a 128 MB memory stick) is arbitrary. Any other
    well-conceived splitting would be fine.
   </para>

   <para>
    If you had more than one partition to begin with, the "delete"
    part of the procedure would have to be repeated.
   </para>

 </sect2>

 <!-- Section2: both -->

 <sect2 id="both">
 <title>Making a dual ext2/vfat system</title>

   <para> 
    This step is a repetition of <xref linkend="making-ext2" />. The first step
	 makes the dos partition, the second makes the Linux ext2 partition.
   </para>

   <screen>
             <prompt>#</prompt> <userinput><command>mkdosfs</command> -F 32 /dev/sda1</userinput>
             <prompt>#</prompt> <userinput><command>mke2fs</command> /dev/sda2</userinput>
   </screen>

 </sect2>

 <!-- Section2: mixed-tests -->

 <sect2 id="mixed-tests">
 <title> Tests -- ext2 and vfat</title>

   <para> 
    Simply carry out the tests of <xref linkend="tests" /> and <xref
    linkend="tests4" /> on the two devices separately. The mount commands
    would be
   </para>

   <screen>
             <prompt>#</prompt> <userinput><command>mount</command> -t vfat /dev/sda1 /mnt/fatstick </userinput>
             <prompt># </prompt><userinput><command>mount</command> -t ext2 /dev/sda2 /mnt/memstick</userinput>
   </screen>

   <para>
	 to mount both partitions on your device.
   </para>

 </sect2>

 <sect2 id="config-linux">
 <title>Configuring Linux for the dual partition</title>

  <para>
   The Linux machine you did the partitioning on, will be
   configured for the dual partition. Evidently you need to carry the
   keychain to another Linux machine. There you will find that it only
   sees <filename>/dev/sda1</filename>. This is, perhaps, a shortcoming
   of the kernel. The workaround is as follows: On the new host
   machine do (keychain plugged in but not mounted)
  </para>
 
  <screen>
             <prompt>#</prompt> <userinput><command>fdisk</command> /dev/sda</userinput>
                   <computeroutput>Choose p; check partition table
                   If satisfied, choose w</computeroutput>
             <prompt>#</prompt> <userinput><command>less</command> /proc/partitions</userinput>
  </screen>        

  <para>
   Your device with its partitions should be there. Data on your
   keychain should be untouched. For a single partition this is not 
   necessary.
  </para>
 
  </sect2>

</sect1>

<!-- End Section1: mixed -->

<!-- Section1: users -->

<sect1 id="users">
<title> Making the memory stick accessible to users</title>

   <para> 
    What we have described so far, are simply the procedures of setting
    up the system and formatting memory sticks. We have to make the
    mounting of the USB filesystem more permanent, and we have to make
    mounting of such a device easier for non-root users. There are
    only a few things to be done.
   </para>

   <para>
    The procedure described below is for the more complex situation of
    a memory stick with a dual partition (<xref linkend="mixed"/>). If 
    the partition is a single ext2, the procedure should be simplified
    by leaving out the line referring to the vfat part and changing 
    <filename>sda2</filename> to <filename>sda1</filename>.
   </para>

   <para> 
    Suppose that the mount points <filename> /mnt/memstick</filename>
    and <filename> /mnt/fatstick</filename> have been created. You do
    not have to use those words and they don't even have to be
    sub-directories of <filename> /mnt</filename>
   </para>

   <para> 
    To make remembering easier, create the following symbolic links:
   </para>

   <screen>
 
             <prompt>#</prompt> <userinput><command>ln</command> -s /dev/sda1 /dev/fatflash</userinput>
             <prompt>#</prompt> <userinput><command>ln</command> -s /dev/sda2 /dev/flash</userinput> 
   </screen>

   <para> 
    For smoother and easier mounting add the following lines to
   <filename> /etc/fstab</filename> : (<emphasis> See NOTE at the end of
   </emphasis> <xref linkend="mounting" /> )</para>

    <screen>
             none          /proc/bus/usb usbfs       defaults       0 0 
             /dev/flash    /mnt/memstick ext2,vfat   rw,user,noauto 0 0 
             /dev/fatflash /mnt/fatstick vfat        rw,user,noauto 0 0 
   </screen>

   <para> 
    The middle line enables mounting either in ext2 or vfat.
    The last two lines make it possible for any user to mount the
    device by the command
   </para>

   <screen>
             <prompt>$</prompt><userinput><command> mount</command> /dev/flash</userinput>  [for ext2 or vfat] 
             <prompt>$</prompt><userinput><command> mount</command> /dev/fatflash</userinput>  [for vfat] 
   </screen>

   <para> 
     It is possible to mount both partitions simultaneously. See <xref linkend="mixed" />.
   </para>

   <para> 
    In the case of an ext2-formatted device it does not seem possible
    for a user (other than root) to mount in read-write mode. The
    solution is to create a directory on the memory stick owned by the
    particular user with complete permissions. Root should do that:
   </para>

   <screen>
             <prompt>#</prompt> <userinput><command>mount </command>/dev/flash </userinput>
             <prompt># </prompt><userinput><command>mkdir</command> -m 777 /mnt/memstick/superdir </userinput>
             <prompt># </prompt><userinput><command>chown</command> charles:charles /mnt/memstick/superdir </userinput>
   </screen>
 
   <para>
    If the device is in the vfat format, this step is unnecessary.
   </para>

   <para> 
    In conclusion, here is a small script I use to mount and unmount
    my (ext2) flash drive:
   </para>

   <programlisting>
             #!/bin/bash 
             EXCODE="keepit" 
             green='\033[0;32m' 
             yellow='\033[0;33m' 
             ## ___________________________ 
             ## Function to echo in colours 
             echo_in_color () 
             { 
                  message=$2 
                  message1=$4 
                  color=$1 
                  color1=$3 
                  echo -e -n $color 
		      echo -n $message 
                  echo -e -n $color1 " " 
                  echo  -n $message1 " " 
                  tput sgr0 
                  return 
             } 
             ## ___________________________ 
             clear 
             mount /dev/flash 
             echo_in_color $green "Flash drive mounted" 
             sleep 2 
             while [ $EXCODE != "flexit" ] 
                  do 
                     clear 
                     echo_in_color $yellow "Enter [flexit] to unmount and exit:" 
                     read EXCODE 
                  done 
             umount /dev/flash 
             exit 
   </programlisting>

   <para> 
    I call this from an FVWM menu by <userinput> Exec exec xterm
    -geometry 43x2+1250+0 -e /home/nikos/bin/flashdrive</userinput>
    which places it on a tiny x-term in one corner of the screen. The
    horizontal displacement of 1250 may have to be modified according
    to the horizontal resolution of your screen.
   </para>

</sect1>

<!-- End Section1:users -->

<!-- Section1: maintain -->

<sect1 id="maintain">
<title> Maintenance</title>

 <!-- Section2: fs-inspect -->

 <sect2 id="fs-inspect">
 <title> Filesystem inspection</title>

   <para>
    It is a virtuous habit to inspect your ext2 filesystem on the
    flash memory regularly. To do this, the tool
    <application>dumpe2fs</application> may be used in the following way:
    <prompt># </prompt><userinput><command>dumpe2fs</command> -h /dev/sda1</userinput> (you must be root and
    the device should not be mounted). The result should be similar to
    the following:
   </para>

   <screen>
             Filesystem volume name:   &lt;none&gt;
             Last mounted on:          &lt;not available&gt;
             Filesystem UUID:          c42a6963-5e6a-4cd2-b7d7-c8f09dca6c52
             Filesystem magic number:  0xEF53
             Filesystem revision #:    1 (dynamic)
             Filesystem features:      dir_index filetype sparse_super
             Default mount options:    (none)
             Filesystem state:         clean
             Errors behavior:          Continue
             Filesystem OS type:       Linux
             Inode count:              32000
             Block count:              127856
             Reserved block count:     6392
             Free blocks:              116456
             Free inodes:              31922
             First block:              1
             Block size:               1024
             Fragment size:            1024
             Blocks per group:         8192
             Fragments per group:      8192
             Inodes per group:         2000
             Inode blocks per group:   250
             Filesystem created:       Sat Sep 20 12:43:00 2003
             Last mount time:          Tue Oct 28 14:13:03 2003
             Last write time:          Tue Oct 28 14:28:27 2003
             Mount count:              13
             Maximum mount count:      35
             Last checked:             Sat Oct 18 11:28:26 2003
             Check interval:           15552000 (6 months)
             Next check after:         Thu Apr 15 11:28:26 2004
             Reserved blocks uid:      0 (user root)
             Reserved blocks gid:      0 (group root)
             First inode:              11
             Inode size:               128
             Default directory hash:   tea
             Directory Hash Seed:      118bee0a-efa5-4771-967e-41a0badd0355
   </screen>

   <para>
    A few important aspects need to be pointed out.
   </para>

   <itemizedlist>
       <listitem>
         <simpara>
           When the ext2 filesystem is created, it is by default
           given maximal usage before it has to be checked. These can
           be seen <emphasis> Maximum mount count </emphasis> (35) and
           <emphasis> Check interval</emphasis> (expiry date).
         </simpara>
        </listitem>
        <listitem>
         <simpara>
           The usage so far: <emphasis> Mount count</emphasis> and
           <emphasis> Last checked</emphasis> .
         </simpara>
        </listitem>
        <listitem>
         <simpara>
           The existence of corrupted files (bad blocks):
           <emphasis> Filesystem state</emphasis> .
         </simpara>
        </listitem>
   </itemizedlist>

   <para>
    You might get warnings about these things when you mount the
    device or when you try the read files from the device.
   </para>

 </sect2>

 <!-- Section2: and-then -->

 <sect2 id="and-then">
 <title> And then?</title>
   <para>
    When the usage allocation has been spent, or there is evidence of
    file corruption, the thing to do is to run <prompt>#</prompt> <userinput><command>fsck.ext2</command> /dev/sda1</userinput> with the device unmounted. After that, usage
    parameters will be freshly allocated and bad blocks will be gone.
    </para>

    <note>
      <para> 
       When dealing with the vfat system, the <application>
       dump</application> does not seem to exist. The command
       <prompt>#</prompt> <userinput><command>dumpe2fs</command> -f /dev/sda1</userinput> for filesystems
       other than ext2 does not work for vfat. The tool <application>
       dosfsck</application> exists (it is still Alpha), and may be
       risky to use on a device you have not formatted yourself.
      </para>
     </note>

 </sect2> 

 

</sect1>

<!-- End Section1: maintain -->

<!-- Section1: linux-2.6 -->

<sect1 id="linux-2.6">
   <title> The Linux-2.6 kernel</title>

<!-- Section2: What's new -->
  <sect2 id="What-is-new">
    <title> What is new?</title>

     <para> 
      Setting up your system as described above for the Linux-2.4.x
      kernels will be perfectly good, but with the Linux-2.6.x kernels
      (x = 0, 1, 2, 3 at the time of this writing) much more is possible:
     </para>

    <itemizedlist>
       <listitem>
         <para>
          USB Hotplugging of devices has been improved immensely. This
          means that it has become possible to attach and remove a
          device from the USB port with full cognisance of the
          system. If a device is attached, it will show in the /proc
          filesystem. Once it is removed, it will not show anymore.
         </para>
       </listitem>
       <listitem> 
         <para>
          The <emphasis>sysfs</emphasis> system has been
          introduced. By using this facility, a very tight grip on
          attached devices, their attributes and nodes of attachment
          is possible.
         </para>
       </listitem>
       <listitem>
         <para>
          Utilities for handling hotplugging have been improved or
          became available. With the aid of these it is possible to
          easily distinguish between attached devices irrespective of
          the order in which they were attached.
         </para>
       </listitem>
    </itemizedlist> 

  </sect2>

<!-- End 

Section2 -->

<!-- Section2 Kernel options -->

  <sect2 id="kernel-options">
    <title> Kernel options </title>

     <para>
      Kernel configuration options are very much the same as described
      in <xref linkend="kernel" />. The configuration menu
      (<prompt>#</prompt><userinput><command> make </command>  
      menuconfig</userinput>) has been organized differently
      and more systematically. Here are the relevant choices:
     </para> 

     <sect3 id="bus-options">
       <title> Bus options</title>
        <itemizedlist mark="none" spacing="compact">
         <listitem>
          <simpara>
           Support for hot-pluggable devices (CONFIG_HOTPLUG)
          </simpara>
         </listitem>
        </itemizedlist>
     </sect3>

     <sect3 id="device-drivers">
       <title> Device drivers</title>
        <itemizedlist mark="none" spacing="compact">

         <listitem override="bullet">
          <simpara>
           <emphasis role="strong"> SCSI device support</emphasis>
          </simpara>
         </listitem>
         <listitem>
          <simpara>
            SCSI device support (CONFIG_SCSI scsi_mod)
          </simpara>
         </listitem>
         <listitem>
          <simpara> 
           legacy /proc/scsi support (CONFIG_SCSI_PROC_FS)
          </simpara>
         </listitem>
         <listitem>
          <simpara> 
           SCSI disk support (CONFIG_BLK_DEV_SD sd_mod)
          </simpara>
         </listitem>

         <listitem><para> </para></listitem>

         <listitem override="bullet">
          <simpara>
           <emphasis role="strong"> USB support</emphasis>
          </simpara>
         </listitem>
         <listitem>
          <simpara>
           Support for USB (CONFIG_USB usbcore)
          </simpara>
         </listitem>
         <listitem>
          <simpara>
           USB device filesystem (CONFIG_USB_DEVICEFS)
          </simpara>
         </listitem>
         <listitem>
          <simpara>
           UHCI HCD support (CONFIG_USB_UHCI_HCD uhci_hcd) 
          </simpara>
         </listitem>
         <listitem>
          <simpara>
           USB Mass Storage support (CONFIG_USB_STORAGE usb_storage)
          </simpara>
         </listitem>
        </itemizedlist>
     </sect3>

     <sect3 id="fss-2.6">
      <title> File systems</title>

        <itemizedlist mark="none" spacing="compact">
         <listitem>
          <simpara> 
           Second extended (CONFIG_EXT2_FS ext2)
          </simpara>
         </listitem>

         <listitem><para> </para></listitem>

         <listitem override="bullet">
          <simpara> 
           <emphasis role="strong"> DOS/FAT/NT filesystems</emphasis>
          </simpara>
         </listitem>
         <listitem>
          <simpara> 
           DOS FAT fs support (CONFIG_FAT_FS fat)
          </simpara>
         </listitem>
         <listitem>
          <simpara> 
           MSDOS fs support (CONFIG_MSDOS_FS msdos)
          </simpara>
         </listitem>
         <listitem>
          <simpara> 
           VFAT (Windows 95) fs support (CONFIG_VFAT_FS vfat)
          </simpara>
         </listitem>

         <listitem><para> </para></listitem>

         <listitem override="bullet">
          <simpara>
           <emphasis role="strong"> Pseudo filesystems</emphasis>
          </simpara>
         </listitem>
         <listitem>
          <simpara> 
           /proc file system support (CONFIG_PROC_FS)
          </simpara>
         </listitem>
        </itemizedlist>
     </sect3>
         
  </sect2>

  <sect2 id="notes-2.6">
  <title>Notes</title>
   
    <para>
     It may be in your interest to consult 
        <ulink url="http://thomer.com/linux/migrate-to-2.6.html">
          Migrating to Linux Kernel 2.6</ulink>,
     but it is not necessary to follow steps that cannot be followed.
    </para>
  </sect2>

<!-- End Section2 -->

<!-- Section2 Hotplugging -->

   <sect2 id="hotplug">
     <title> Hotplugging and Naming </title>
     
       <para>
         In <xref linkend="scsidev" /> the situation of two USB
         devices plugged in at the same time was discussed. The
         difficulty is that it becomes hard for the user to
         distinguish the two devices. Progress recently made in the
         <ulink url="http://sourceforge.net/search/">Linux Hotplug
         Project </ulink> (search for hotplug) and implemented in the
         2.6-series of kernels, has made it possible to address this
         problem efficiently. For implementation some utilities are
         needed:
       </para>

       <itemizedlist spacing="compact">
         <listitem>
          <simpara> sysfs -- compiled by default into Linux-2.6.x
          </simpara> 
         </listitem> 

         <listitem>
          <simpara>
           <ulink url="http://linux-diag.sourceforge.net/Sysfsutils.html">
            sysfsutils-0.4.0 or later</ulink>
          </simpara>
         </listitem> 
 
         <listitem> 
          <simpara> 
           <ulink url="http://sourceforge.net/projects/linux-hotplug">
           hotplug-2004_01_05 or later</ulink>
          </simpara>
         </listitem>

         <listitem>
          <simpara>
            <ulink url="http://www.kernel.org/pub/linux/utils/kernel/hotplug">
             udev-016 or later</ulink>
          </simpara>
         </listitem>
        </itemizedlist>

     <sect3 id="installation">
       <title> Installation</title>
        
         <formalpara>
          <title>The sysfs filesystem</title>
           <para></para>
         </formalpara>

           <para>
             The <emphasis>sysfs</emphasis> filesystem is intrinsic to
             the Linux-2.6 kernel series. It is used by
             <emphasis>udev</emphasis> and
             <emphasis>sysfstools</emphasis> to obtain information
             about kernel objects (devices, etc.), their attributes
             and mutual linkages. Activation is according to the
             following procedure:
            </para>
              
            <screen>
              <prompt># </prompt><userinput><command>cd</command></userinput> /
              <prompt># </prompt><userinput><command>mkdir</command></userinput> sys
              <prompt># </prompt><userinput><command>mount</command></userinput> -t sysfs none /sys
            </screen>

            <para> 

             If you do <userinput><command> ls </command>  -F
             /sys</userinput>, a whole directory structure
             with entries like <emphasis>block/</emphasis>,
             <emphasis>bus/</emphasis>, ... will be shown. You were
             successful. The mounting should now be made permanent by
             adding the following line to
             <filename>/etc/fstab</filename>:
            </para>
            
            <screen>
              none  /sys   sysfs  defaults  0  0
            </screen>

         <formalpara>
          <title>Sysfsutils</title>
           <para></para>
         </formalpara>

           <para>
             This is installed in one of the usual ways without having
             to make special configuration options. Instructions in
             the README file are very clear. You should, however,
             first make sure that the entry
             <filename>/usr/local/lib</filename> is entered in
             <filename>/etc/ld.so.conf</filename> so that the
             <filename>libsysfs.so</filename> libraries will be
             recognisable by the system. After installation, check
             that the utilities <filename>/usr/local/bin/lsbus</filename>
             and <filename>/usr/local/bin/systool</filename> have been
             installed. Also check that the libraries mentioned above
             have been properly linked in
             (<userinput><command>ldconfig </command>-p | grep
             libsysfs</userinput>).
           </para>

         <formalpara>
          <title>Hotplug</title>
           <para></para>
         </formalpara>

           <para>
             Next install the <filename>hotplug</filename>
             scripts. The first thing to do is to check that
             hotplugging will work on your system. Do:
             <userinput><command> less </command>
             /proc/sys/kernel/hotplug</userinput>. The
             result should be
             <computeroutput>/sbin/hotplug</computeroutput>. If it is
             not so, you should add the line <filename> echo
             "/sbin/hotplug" > /proc/sys/kernel/hotplug</filename> to
             an appropriate initialization script,
             e.g. <filename>/etc/rc.d/rc.local</filename>. This
             command could also be given (as root) before checking
             that everything works. Installation is extremely
             simple. Do: <prompt># </prompt><userinput><command> make
             </command> install</userinput>. Check afterwards that the
             script <filename>/sbin/hotplug</filename> exists.
            </para>

         <formalpara>
          <title>Udev.</title>
           <para></para>
         </formalpara>
           
           <para>
             This is the last installation. Study the README file and
             follow the instructions necessary to be able to run
             <userinput><command>make </command>
             USE_KLIBC=true</userinput>. If you have
             compiled the Linux-2.6.x kernel, this should not be too
             difficult. A quick check would be to find out if
             <filename>/sbin/udev</filename> and
             <filename>/sbin/udevinfo</filename> exist. There are
             other occurences as well, a very important one being
             <filename>/etc/udev/udev.rules</filename>. If you have a
             working setup for memory sticks (as described above) and
             a memory stick plugged in you could try
             <userinput><command>ls </command>/udev</userinput>, you
             should see the device (sda, sda1, ...). If it is there,
             unplug the device and list again. It should be gone!
           </para>
           
      </sect3>

      <sect3 id="names">
      <title>Naming memory sticks</title>
           <para>
             With the <emphasis>udev</emphasis> utility in place, it
             is possible to identify a memory stick on the basis of
             some built-in attribute. One that works, is the
             <emphasis>vendor</emphasis> identity. To find this for an
             attached device, do <userinput><command>systool
             </command> -vb scsi | grep vendor</userinput>. This
             should give a list of attached SCSI devices (remember
             that your memory stick poses as a SCSI device <xref
             linkend="scsidev"/>). Let us suppose that you have two
             memory sticks plugged in at the same time and found (as I
             did) two vendor Id's, namely "UFD" and "STORAGE". Then
             add to the file <filename>/etc/udev/udev.rules</filename>
             the following lines (at the top if you like):
           </para>

           <screen>
              ## Flash Memory 1
              BUS="scsi", SYSFS_vendor="UFD*", NAME="namib%n"

              ## Flash Memory 2
              BUS="scsi", SYSFS_vendor="STORAGE*", NAME="kalahari%n"
           </screen>

           <para>
             The vendor-identities may have trailing blank spaces, and
             therefore the wildcard asterisks have a purpose. Do not
             ignore them.  Remove and replace the memory sticks, then
             do <userinput><command>ls </command>
             /udev</userinput>. Instead of the impersonal
             <filename>sda</filename>, <filename>sda1</filename>,
             etc. there should now be <filename>kalahari</filename>,
             <filename>kalahari1</filename>,
             <filename>namib</filename> and
             <filename>namib1</filename>. The devices have been named
             according to the "vendor" information in them. Thus we
             can identify the device, no matter where it was
             mapped. All that remains to be done is to creat
             appropriate mount points like
             <filename>/mnt/namib</filename> and
             <filename>kalahari</filename> and make entries like
           </para>
            <screen>
             /udev/namib1     /mnt/namib     vfat,ext2  user,noauto,rw  0 0 
             /udev/kalahari1  /mnt/kalahari  vfat,ext2  user,noauto,rw  0 0         
            </screen>
           <para>
             in <filename>/etc/fstab</filename> to enable mounting
             from other places.
           </para>
           <para>
             This is great fun ... and remember, there are other
             deserts on the planet.
           </para> 


      </sect3>

   </sect2>

<!-- End Section2 -->

</sect1>

<!-- End Section1 -->

<!-- Section1: formal -->

<sect1 id="formal">
   <title> Formalities</title>

<!-- Section2: copyright -->

 <sect2 id="copyright">
   <title> Copyright Information</title>

   <para>
    This document is copyrighted (c) 2003 Niko Sauer and is
    distributed under the terms of the Linux Documentation Project
    (LDP) license, stated below.
   </para>

   <para>
    Unless otherwise stated, Linux HOWTO documents are
    copyrighted by their respective authors. Linux HOWTO documents may
    be reproduced and distributed in whole or in part, in any medium
    physical or electronic, as long as this copyright notice is
    retained on all copies. Commercial redistribution is allowed and
    encouraged; however, the author would like to be notified of any
    such distributions.
   </para>

   <para>
    All translations, derivative works, or aggregate works
    incorporating any Linux HOWTO documents must be covered under this
    copyright notice. That is, you may not produce a derivative work
    from a HOWTO and impose additional restrictions on its
    distribution. Exceptions to these rules may be granted under
    certain conditions; please contact the Linux HOWTO coordinator at
    the address given below.
   </para>

   <para>
    In short, we wish to promote dissemination of this
    information through as many channels as possible. However, we do
    wish to retain copyright on the HOWTO documents, and would like to
    be notified of any plans to redistribute the HOWTOs.
   </para>

   <para>
    If you have any questions, please contact 
    <email>nikos@friedrichs.up.ac.za </email>
   </para>
 </sect2>

<!-- Section2: disclaimer -->

 <sect2 id="disclaimer">
   <title> Disclaimer</title>

   <para>
    No liability for the contents of this documents can be accepted.
    Use the concepts, examples and other content at your own risk.
    As this is a new document, there may be errors
    and inaccuracies, that may of course be damaging to your system.
    Proceed with caution, and although this is highly unlikely,
    the author do not take any responsibility for that.
   </para>

   <para>
    All copyrights are held by their by their respective owners, unless
    specifically noted otherwise.  Use of a term in this document
    should not be regarded as affecting the validity of any trademark
    or service mark.
   </para>

   <para>
    Naming of particular products or brands should not be seen 
    as endorsements.
   </para>

   <para>
    You are strongly recommended to take a backup of your system 
    before major installation and backups at regular intervals.
   </para>

 </sect2>

<!-- Section2: credits -->

 <sect2 id="credits">
   <title> Credits</title>

   <para>
    I wish to express my deep gratitude towards my sons Paul and
    Philip who in 1995 persuaded me to move to Linux. Philip gave me
    profound advice and insights which made this project a pleasant
    learning experience.
   </para>
   <para>
     Emma Jane Hogbin, in her review, raised a number of important
     questions which served to improve this document immensely. My
     sincerest thanks to her.
   </para>
 
 </sect2>

<!-- Section2: feedback -->

 <sect2 id="feedback">
   <title> Feedback</title>
   <para>
    Users of this document are most welcome to email me with
    suggestions on the improvement of the presentation and possible
    additions to the scope of it.
   </para>

 </sect2>



</sect1>

<!-- Section1: formal: END -->


</article>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
xml-omittag:t
xml-shorttag:t
xml-namecase-general:t
xml-general-insert-case:lower
xml-minimize-attributes:nil
xml-always-quote-attributes:yes
xml-indent-step:1
xml-indent-data:t
xml-parent-document:nil
xml-exposed-tags:nil
xml-local-catalogs:nil
xml-local-ecat-files:nil
End:
-->
