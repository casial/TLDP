<?xml version="1.0"?>
<!--
** The syntax of DOCTYPE is described in 
http://www.freebsd.cz/doc/en_US.ISO8859-1/books/fdp-primer/sgml-primer-doctype-declaration.html 
** 
<DOCTYPE	first-element-in-doc  formal-public-identifier-FPI>
** FPI is Owner//Keyword and Description//Language, -//Owner indicates 
unregisterd and +//Owner indicates registered owner. ** Keyword can be 
DTD,ELEMENT,ENTITIES or TEXT ** Description can be anything like "DocBook XML 
my version V4.2" ** Language is 2 letter like EN for english --> 
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"/usr/share/sgml/docbook/xml-dtd-4.2-1.0-19/docbookx.dtd" [ 
<!ENTITY version "0.01">
] > 
<!--
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
[ 
<!ENTITY version "0.01">
] > 
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://docbook.org/xml/4.2/docbookx.dtd" [ 
<!ENTITY version "0.01">
] > ********** *** For some reason file:/usr/share/... does not work, remove 
file: and change to '/usr/share/...' then it works 
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"/usr/share/sgml/docbook/xml-dtd-4.2-1.0-19/docbookx.dtd" [ 
<!ENTITY version "0.01">
] > 
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"file:/usr/share/sgml/docbook/xml-dtd-4.2-1.0-19/docbookx.dtd" [ 
<!ENTITY version "0.01">
] > 
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://docbook.org/xml/4.2/docbookx.dtd" [ 
<!ENTITY version "0.01">
] > 
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [ 
<!ENTITY version "0.01">
] > --> 
<article id="Kernel-HOWTO">
  <articleinfo>
    <title>
      The Linux Kernel HOWTO 
    </title>
    <author>
      <firstname>
        Al Dev (Alavoor Vasudevan) 
      </firstname>
      <authorblurb>
        <para>
          <ulink url="mailto:       alavoor[AT]yahoo.com    ">
            alavoor[AT]yahoo.com 
          </ulink>
        </para>
      </authorblurb>
      <affiliation>
        <address format="linespecific">
          <email>
            alavoor[AT]yahoo.com 
          </email>
        </address>
      </affiliation>
    </author>
    <pubdate>
      v7.3, 27 Oct 2003 
    </pubdate>
    <abstract>
      <para>
        This is a detailed guide to kernel configuration, compilation, 
        upgrades, and troubleshooting for ix86-based systems. Can be useful 
        for other architectures as well. This document is kept small &amp; 
        simple, so that even non-technical "home computer users" will be able 
        to compile and run the Linux Kernel. 
      </para>
    </abstract>
  </articleinfo>
  <sect1 id="introduction">
    <title>
      Introduction 
    </title>
    <para>
      You compile Linux kernel for one of following reasons: 
      <itemizedlist>
        <listitem>
          <para>
            You are doing kernel development 
          </para>
        </listitem>
        <listitem>
          <para>
            You are adding a new hardware to machine 
          </para>
        </listitem>
        <listitem>
          <para>
            You want to customize the kernel and do not want the default 
            kernel shipped out to you. 
          </para>
        </listitem>
        <listitem>
          <para>
            For 
            <emphasis remap="bf">
              Defence Industries 
            </emphasis>
            or 
            <emphasis remap="bf">
              Military applications 
            </emphasis>
            , you must read the kernel source code and compile with your own 
            hands. No exceptions!! (U.S Dept of Defence compiles the Linux 
            kernel before distributing the computers). 
          </para>
        </listitem>
        <listitem>
          <para>
            Every country and every Government in the world compiles the 
            kernel on site for security and integrity. Every 
            Government/Corporation audits and verifies each and every line of 
            the OS kernel source code before using the computer. 
          </para>
        </listitem>
        <listitem>
          <para>
            Military Intelligence agencies around the world reads and compiles 
            the Linux kernel source code. They know what each and every line 
            of Linux kernel source code is doing!! 
          </para>
        </listitem>
        <listitem>
          <para>
            If you compile the Linux kernel with your own hands, then it is 
            <emphasis remap="bf">
              as good as reading and verifying 
            </emphasis>
            all the kernel source code! 
          </para>
        </listitem>
        <listitem>
          <para>
            Each and every University, School and College in the world 
            compiles the OS kernel before using any computer! 
          </para>
        </listitem>
        <listitem>
          <para>
            For your education and knowledge of Linux kernel and ofcourse, 
            just for fun! 
          </para>
        </listitem>
        <listitem>
          <para>
            For very advanced scientific applications - you may need to do 
            kernel compile 
          </para>
        </listitem>
        <listitem>
          <para>
            It is an International Law (the U.N. laws) - "You cannot use a 
            computer WITHOUT compiling the OS kernel with your own hands". If 
            you disobey this law you will be "punished" with lot of computer 
            problems!! You must compile the kernel with your own hands and not 
            rely on someone else to do it for you!! 
          </para>
        </listitem>
        <listitem>
          <para>
            It is Illegal, Unlawful, Felony and Fraud to use a computer 
            without compiling the OS Kernel with your VERY OWN hands! There is 
            a punishment of 1 to 3 months jail (imprionment) and fine ranging 
            from US$100 to US$2000 if you use a computer without compiling the 
            the OS Kernel source code. Some states / countries / governments 
            have stringent laws which prohibit using any computer without 
            compiling the kernel source code. 
          </para>
        </listitem>
        <listitem>
          <para>
            In USA, all the corporations mandate compilation of OS kernel 
            before using the computer and hence there is Linux, Linux &amp; 
            Linux everywhere in United States! 
          </para>
        </listitem>
        <listitem>
          <para>
            And for many hundreds of reasons - too numerous to list! 
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      Note: This document is kept small &amp; simple, so that even 
      non-technical "home computer users" will be able to compile and run the 
      Linux Kernel! 
    </para>
    <sect2 id="warnings">
      <title>
        WARNING NOTICE 
      </title>
      <para>
        It is the usual industry practice to have a debug PC box, a test PC 
        box, and a production PC box. Nobody works directly on a production 
        box without experimenting first on debug PC and test PC. This is 
        because the skills of a person varies and every person needs a warm-up 
        exercise before doing the final show. A computer hardware is a very 
        sophisticated technology like "Space Shuttle" and risks are involved 
        as it can fail unexpectedly. Eventhough efforts are made to ensure 
        that this document is upto-date and all commands are pre-tested, it is 
        strongly recommended that you should practice your skills first on a 
        trainer test PC before you do anything to "LIVE" production box. You 
        will sharpen your skills and hone your knowledge first on a test PC 
        running Linux and after everything works, then change the production 
        box with extreme caution. Even if you break the test PC with dangerous 
        commands you will learn by doing mistakes and you can afford breaking 
        the test PC. You will be more confident working first on Test PC. Most 
        companies purchase old PCs for using them as "Trainer Machines". 
        Please understand that there is no warranty or guaranty on this 
        document and you can build your own warranty by checking this document 
        with your test PC or your home PC (low risk environments). (Write your 
        own warranty document and hang it on wall near your computer!!) 
      </para>
    </sect2>
  </sect1>
  <sect1 id="quick_steps" >
    <title>
      Quick Steps - Kernel Compile 
    </title>
    <para>
      This section is written by 
      <ulink url="mailto:alavoor[AT]yahoo.com">
        Al Dev (alavoor[AT]yahoo.com) 
      </ulink>
      (The 
      <emphasis remap="bf">
        latest version 
      </emphasis>
      of this document is at 
      <ulink url="http://milkyway.has.it">
        "http://milkyway.has.it" 
      </ulink>
      and 
      <ulink url="http://www.milkywaygalaxy.freeservers.com">
        "http://www.milkywaygalaxy.freeservers.com" 
      </ulink>
      . You may want to check there for changes). Mirror sites are at - 
      <ulink url="http://milkyway.bounceme.net">
        http://milkyway.bounceme.net 
      </ulink>
      . These sites have lot of linux goodies and tips. 
    </para>
    <para>
      Kernel re-compile is required in order to make the kernel very lean and 
      which will result in FASTER operating system . It is also required to 
      support any new devices. 
    </para>
    <sect2 id="precautions">
      <title>
        Precautionary Preparations 
      </title>
      <para>
        Before you build kernel, it is a good idea to do a backup of the 
        system. If you had not backed up your system recently then you can do 
        it now. You can use commercial backup tools like 
        <ulink url="http://24.221.230.253">
          BRS Backup-Recovery-Software 
        </ulink>
        (also in this page you can find open-source/freeware backup tools 
        listed under 'Backup and Restore Utility'). Backup is just a 
        suggestion and it is not mandatory to do backup before building the 
        Linux kernel. 
      </para>
    </sect2>
    <sect2 id="upgrading">
      <title>
        Minor Upgrading of Kernel 
      </title>
      <para>
        If you had already built the kernel and you want to upgrade to next 
        patch release, then you can simply copy the existing config file and 
        reuse it. (For example you have built kernel 2.4.19 and want to 
        upgrade to 2.4.20). 
      </para>
      <para>
        <emphasis remap="bf">
          For minor upgrades : 
        </emphasis>
        This step may save you time, if you want to reuse the old settings. 
        Whenever you install the kernel, generally you put the config file in 
        /boot. Do not save the .config as .config.save because 'make mrproper' 
        will wipe out all .config* files!! So, you can use the existing 
        version of config file: 
        <programlisting format="linespecific">
	bash# mkdir /usr/src/kernelconfigs 
	bash# cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save
	bash# cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # ExtraSafe
	bash# cp /boot/config*  /usr/src/linux/configs/  # ExtraSafe
	bash# cp /boot/config-2.4.18-19.8.0  /usr/src/linux/.config
        </programlisting>
        Or another method is - you can copy the .config file from your old 
        linux kernel source tree to new kernel tree. 
        <programlisting format="linespecific">
	bash# ls -l /usr/src/lin*  # You can see that /usr/src/linux is a soft link
	bash# cd /usr/src/linux 
	bash# cp ../linux-old-tree/.config .  # Example cp ../linux-2.4.19/.config .
        </programlisting>
      </para>
      <para>
        or one other method is - you can use "make oldconfig" which default 
        all questions based on the contents of your existing ./.config file. 
      </para>
      <para>
        NOTE: If you do not have lot of disk space in /usr/src then you can 
        unpack the kernel source package on any partition where you have free 
        disk space (like /home). Because kernel compile needs lot of disk 
        space for object files like *.o. For this reason the /usr/src/linux 
        MUST be a soft link pointing to your source directory. 
      </para>
      <para>
        After this, look in the next section to do make and install. 
      </para>
    </sect2>
    <sect2 id="Documentation">
      <title>
        New Release Changes: Documentation 
      </title>
      <para>
        If you downloaded the new kernel sources, then make sure you read the 
        following files in /usr/src/linux/Documentation 
        <itemizedlist>
          <listitem>
            <para>
              Changes: This file lists the minimum requirements and some notes 
            </para>
          </listitem>
          <listitem>
            <para>
              kernel.txt: This file has 'Understanding the Linux Kernel' 
            </para>
          </listitem>
          <listitem>
            <para>
              Read all *.txt files in /usr/src/linux/Documentation but most 
              important ones are kernel*.txt files. 
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
    <sect2 id="impatient">
      <title>
        For the Impatient 
      </title>
      <para>
        <orderedlist inheritnum="ignore" continuation="restarts">
          <listitem>
            <para>
              Unpack the sources 
            </para>
          </listitem>
          <listitem>
            <para>
              cd /usr/src/linux; mkdir /usr/src/kernelconfigs ; cp 
              /usr/src/linux/.config /usr/src/kernelconfigs/.config.save; make 
              clean; make mrproper; make clean; cp 
              /usr/src/kernelconfigs/.config.save .config # In case you want 
              to reuse the config file ?? 
            </para>
          </listitem>
          <listitem>
            <para>
              Optional - Copy config file : You can copy the config file from 
              your old linux kernel source tree to new kernel tree (may save 
              time, if you want to reuse the old settings). 
            </para>
          </listitem>
          <listitem>
            <para>
              make xconfig # Nicer, but limited; only runs in "X" 
            </para>
          </listitem>
          <listitem>
            <para>
              make dep 
            </para>
          </listitem>
          <listitem>
            <para>
              Give a unique name to your new Kernel - Edit 
              /usr/src/linux/Makefile and change EXTRAVERSION 
            </para>
          </listitem>
          <listitem>
            <para>
              nohup make bzImage 
            </para>
          </listitem>
          <listitem>
            <para>
              'make modules' and 'make modules_install' 
            </para>
          </listitem>
          <listitem>
            <para>
              And you can go to lunch or go to bed (have nice Linux dreams in 
              sleep) and when you come back the system is ready! And see the 
              log with 'less nohup.out'. 
            </para>
          </listitem>
          <listitem>
            <para>
              make install # But "NOT recommended" - use cp 
              /usr/src/linux/arch/i386/boot/bzImage /boot/bzImage.myker 
            </para>
            <para>
              Copy the System.map file to /boot # cp System*.map* /boot/ 
            </para>
            <para>
              Copy your kernel "configuration file" (the options you selected) 
              Not required but will be useful later. cp .config 
              /boot/config.KERNEL_VERSION.Name 
            </para>
          </listitem>
          <listitem>
            <para>
              Configure GRUB or LILO. 
            </para>
          </listitem>
          <listitem>
            <para>
              Reboot and check new kernel is booting 
            </para>
          </listitem>
          <listitem>
            <para>
              Create emergency boot disk - bzdisk or mkbootdisk 
            </para>
          </listitem>
          <listitem>
            <para>
              Optional - make rpm # To build rpm packages 
            </para>
          </listitem>
          <listitem>
            <para>
              Optional - make clean (If you want to free up disk space) 
            </para>
          </listitem>
        </orderedlist>
      </para>
      <para>
        See details of above steps in the following sections.... 
      </para>
    </sect2>
    <sect2 id="steps">
      <title>
        Building New Kernel - Explanation of Steps 
      </title>
      <para>
        <emphasis remap="bf">
          Details of the steps mentioned in the previous section: 
        </emphasis>
      </para>
      <para>
        <emphasis remap="bf">
          Note: 
        </emphasis>
        Below 'bash#' denotes the bash prompt, you should type the commands 
        that appear after the 'bash#' prompt. Below are commands tested on 
        Redhat Linux Kernel 2.4.7-10, but it should work for other 
        distributions with very minor changes. It should also work for older 
        kernel versions like 2.2, 2.0 and 1.3. It should also work for future 
        or newer versions of kernel (with little changes - let me know). 
      </para>
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <emphasis remap="bf">
                Note: 
              </emphasis>
              You can have many kernel images on your system. By following the 
              steps below you do not overwrite or damage your existing kernel. 
              These steps are 
              <emphasis remap="bf">
                very safe 
              </emphasis>
              and your current kernel will be intact and will not be touched. 
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        <orderedlist inheritnum="ignore" continuation="restarts">
          <listitem>
            <para>
              <emphasis remap="bf">
                Unpack the sources: 
              </emphasis>
              Login in as 'root' throughout all these steps. Mount Redhat 
              linux cdrom (Disc 2 of Redhat9) and install the linux kernel 
              source rpm 
              <programlisting format="linespecific">
	bash$ su - root
	bash# cd /mnt/cdrom/RedHat/RPMS 
	bash# rpm -i kernel-headers*.rpm 
	bash# rpm -i kernel-source*.rpm 
	bash# rpm -i dev86*.rpm   
	bash# rpm -i bin86*.rpm   
              </programlisting>
              (The bin86*.rpm and 'as86' is required only for 
              <emphasis remap="bf">
                OLDER Linux 
              </emphasis>
              systems like Redhat 5.x. Get Intel assembler 'as86' command from 
              dev86*.rpm on cdrom or from 
              <ulink url="http://rpmfind.net/linux/RPM/mandrake/7.1/Mandrake/RPMS/bin86-0.4-12mdk.i586.html">
                bin86-mandrake 
              </ulink>
              , 
              <ulink url="http://rpmfind.net/linux/RPM/kondara/jirai/i586/bin86-0.4-8k.i586.html">
                bin86-kondara 
              </ulink>
              ). In latest Redhat 9, the kernel-source.rpm contains the 
              kernel-headers. Usually kernel source is on Redhat discs or in 
              SRPMs disc. Otherwise, you can get from 
              <ulink url="http://rpmfind.net/linux/rpm2html/search.php?query=kernel-source&amp;submit=Search+...&amp;system=&amp;arch=">
                rpmfind.net kernel-source 
              </ulink>
              (look for RawHide for latest Redhat) and 
              <ulink url="http://rpmfind.net/linux/rpm2html/search.php?query=kernel-headers&amp;submit=Search+...&amp;system=&amp;arch=">
                rpmfind.net kernel-headers 
              </ulink>
              . Also make sure that /usr/src/linux is soft link pointing to 
              proper unpacked source. 
              <programlisting format="linespecific">
	bash# cd /usr/src
	bash# ls -l    # You should see that /usr/src/linux is soft link pointing to source
	lrwxrwxrwx    1 root     root           19 Jan 26 11:01 linux -&gt; linux-2.4.18-19.8.0
	drwxr-xr-x   17 root     root         4096 Jan 25 21:08 linux-2.4.18-14
	drwxr-xr-x   17 root     root         4096 Mar 26 12:50 linux-2.4.18-19.8.0
	drwxr-xr-x    7 root     root         4096 Jan 14 16:32 redhat
              </programlisting>
              If it is not a soft link then do rename /usr/src/linux to 
              /usr/src/linux-2.4.yy and create a soft link. 
            </para>
            <para>
              NOTE: If you do not have lot of disk space in /usr/src then you 
              can unpack the kernel source package on any partition where you 
              have free disk space (like /home). Because kernel compile needs 
              lot of disk space for object files like *.o. For this reason the 
              /usr/src/linux MUST be a soft link pointing to your source 
              directory. 
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Clean : 
              </emphasis>
              Before doing mrproper below, you may want to backup the .config 
              file. 
              <programlisting format="linespecific">
	bash# cd /usr/src/linux 
    bash# mkdir /usr/src/kernelconfigs ;
    bash# cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save;
	bash# cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # ExtraSafe
	bash# cp /boot/config*  /usr/src/linux/configs/  # ExtraSafe
	bash# make clean
	bash# make mrproper  # "MUST DO THIS mrproper", otherwise you will face hell lot of problems !!
	bash# make clean
	bash# cp /usr/src/kernelconfigs/.config.save .config  # In case you want to reuse the config file ??
              </programlisting>
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Optional - Copy config file : 
              </emphasis>
              This step may save you time, if you want to reuse the old 
              settings. Whenever you install the kernel, generally you put the 
              config file in /boot. There are some baseline config files which 
              are located in /usr/src/linux/configs/kernel-*.config which you 
              can use. So, you can use the existing version of config file: 
              <programlisting format="linespecific">
    bash# mkdir /usr/src/kernelconfigs ;
    bash# cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save;
	bash# cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # ExtraSafe
	bash# cp /boot/config*  /usr/src/linux/configs/  # ExtraSafe
	bash# cp /boot/config-2.4.18-19.8.0  /usr/src/linux/.config
	Or copy from the default vanilla config file from /usr/src/linux/configs
	bash# cp /usr/src/linux/configs/kernel-2.4.18-i686.config  /usr/src/linux/.config
	Or for athlon processors
	bash# cp /usr/src/linux/configs/kernel-2.4.18-athlon.config  /usr/src/linux/.config
              </programlisting>
              Or another method is - you can copy the .config file from your 
              old linux kernel source tree to new kernel tree 
              <programlisting format="linespecific">
	bash# ls -l /usr/src/lin*  # You can see that /usr/src/linux is a soft link
	bash# cd /usr/src/linux 
	bash# cp ../linux-old-tree/.config .  # Example cp ../linux-2.4.19/.config .
              </programlisting>
              or one other method is - you can use "make oldconfig" which 
              default all questions based on the contents of your existing 
              ./.config file. 
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Configure: 
              </emphasis>
              <itemizedlist>
                <listitem>
                  <para>
                    Start X-windows with 'startx'. If you are not able to 
                    start X-window then see next step below. 
                    <programlisting format="linespecific">
	bash# man startx
	bash# startx
	bash# cd /usr/src/linux 
	bash# make xconfig  # Nicer, but limited; only runs in "X"
                    </programlisting>
                    If you get error that wish is not found, then install the 
                    tk-8.3.rpm package. 
                  </para>
                </listitem>
                <listitem>
                  <para>
                    If you are not able to start X-window above then try - 
                    <programlisting format="linespecific">
		bash# export TERM=xterm
		bash# make menuconfig  # Newer, uses ncurses/curses, may fail if not installed
	If you find scrambled display, then use different terminal emulators like vt100,
	vt102, vt220 or ansi. The display will be scrambled and will have garbage 
	characters in cases where you use telnet to login to remote linux. In such 
	cases you should use the terminal emulators like vt100, vt220. 
	For example:
		bash# export TERM=vt220
		bash# export TERM=ansi
	At a lower level of VT, use: 
		bash# export TERM=vt100
		bash# make menuconfig  # Newer, uses ncurses/curses, may fail if not installed
	If the menuconfig command fails then try -
		bash# make config   # Old, user unfriendly method !!
                    </programlisting>
                  </para>
                </listitem>
              </itemizedlist>
              The 
              <emphasis remap="bf">
                "make xconfig" or "make menuconfig" 
              </emphasis>
              brings up a user friendly GUI interface. And 
              <emphasis remap="bf">
                "make config" 
              </emphasis>
              brings up command-line console mode interface. You can load the 
              configuration file from 
              <emphasis remap="it">
                /usr/src/linux/.config 
              </emphasis>
              (dot config file. Note the dot before config). Click on button 
              "Load Configuration from File". Within 'make xconfig' you must 
              do these (to avoid problems) - 
              <itemizedlist>
                <listitem>
                  <para>
                    <emphasis remap="bf">
                      VERY IMPORTANT !!! : 
                    </emphasis>
                    Select proper CPU type - Pentium 3, AMD K6, Cyrix, Pentium 
                    4, Intel 386, DEC Alpha, PowerPC otherwise kernel compile 
                    will fail and even if it compiles, it will not boot!! 
                  </para>
                </listitem>
                <listitem>
                  <para>
                    Select SMP support - whether single CPU or multiple CPUs 
                  </para>
                </listitem>
                <listitem>
                  <para>
                    Filesystems - Select Windows95 Vfat, MSDOS, NTFS as part 
                    of kernel and not as loadable modules. (My personal 
                    preference, but you are free to pick your own option). 
                  </para>
                </listitem>
                <listitem>
                  <para>
                    Enable the Loadable kernel modules support! With this 
                    option you can load/unload the device drivers dynamically 
                    on running linux system on the fly. See the Modules 
                    chapter at 
                    <xref linkend="loadable_modules"/>
                    . 
                  </para>
                </listitem>
              </itemizedlist>
              Save and Exit "make xconfig". All the options which you selected 
              is now saved into configuration file at 
              <emphasis remap="it">
                /usr/src/linux/.config 
              </emphasis>
              (dot config file). 
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Dep : 
              </emphasis>
              And now, do - 
              <programlisting format="linespecific">
	bash# make dep
              </programlisting>
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Give a unique name to your new Kernel: 
              </emphasis>
              You can give a name to your kernel, so that it is unique and 
              does not interfere with others. 
              <programlisting format="linespecific">
	bash# cd /usr/src/linux
	bash# vi Makefile
              </programlisting>
              Here look for EXTRAVERSION = -19.8.0_Blah_Blah_Blah and change 
              to something like EXTRAVERSION = -19.8.0MyKernel.26Jan2003 
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Do make: 
              </emphasis>
              Read the following file (to gain some knowledge about kernel 
              building. Tip: Use the color editor 
              <ulink url="http://www.linuxdoc.org/HOWTO/Vim-HOWTO.html">
                gvim 
              </ulink>
              for better readability. 
              <programlisting format="linespecific">
	bash# gvim -R   /usr/src/linux/arch/i386/config.in 
	bash# man less 
	bash# less   /usr/src/linux/arch/i386/config.in 
	Type 'h' for help and to navigate press i, j, k, l, h or arrow, page up/down keys. 
              </programlisting>
              Now, give the make command - 
              <programlisting format="linespecific">
		bash# cd /usr/src/linux
		bash# man nohup
		bash# nohup make bzImage &amp;  
		bash# man tail
		bash# tail -f nohup.out     (.... to monitor the progress) 
	This will put the kernel in /usr/src/linux/arch/i386/boot/bzImage 
                </programlisting>
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                LOADABLE MODULES: 
              </emphasis>
              Now, while the 'make' is cranking along in the previous step "Do 
              make", you should bring up another new xterm shell window and 
              follow these steps: This step is required 
              <emphasis remap="bf">
                ONLY if 
              </emphasis>
              you had enabled Loadable module support in step "Configure Step" 
              above. Loadable module are located in /lib/modules. You MUST do 
              this step if you enabled or disabled any modules, otherwise you 
              will get 'unresolved symbols' errors during or after kernel 
              boot. 
              <programlisting format="linespecific">
	# Bring up a new Xterm shell window and ...
	bash# cd /usr/src/linux
	# Redirect outputs such that you do not overwrite the nohup.out which is still running...
	bash# nohup make modules 1&gt; modules.out 2&gt; modules.err  &amp;
	bash# make modules_install   # Do this, only after the above make command is successful
              </programlisting>
              This will copy the modules to /lib/modules directory. See the 
              Modules chapter at 
              <xref linkend="loadable_modules"/>
              . 
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Now go to Lunch or Bed : 
              </emphasis>
              Since both the make windows are cranking along, and now, you can 
              go to lunch (chitchat, have nap) or go to bed (have nice Linux 
              dreams in sleep) and when you wake up and come back the system 
              is ready! You can check with command 'less nohup.out' to see the 
              log of output. 
              <programlisting format="linespecific">
	bash# cd /usr/src/linux
	bash# less nohup.out
	bash# less modules.err
	bash# less modules.out
	If no errors then do:
	bash# make modules_install  
              </programlisting>
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                bzImage: 
              </emphasis>
              After bzImage is successful, copy the kernel image to /boot 
              directory. You must copy the new kernel image to /boot 
              directory, otherwise the new kernel 
              <emphasis remap="bf">
                MAY NOT 
              </emphasis>
              boot. You must also copy the config file to /boot area to 
              reflect the kernel image, for documentation purpose. 
              <programlisting format="linespecific">
	bash# cp /usr/src/linux/arch/i386/boot/bzImage     /boot/bzImage.myker.26mar2001
	# You MUST copy the config file to reflect the corresponding kernel image, 
	# for documentation purpose.
	bash# cp /usr/src/linux/.config /boot/config-&lt;your_kernelversion_date&gt;
	# Example: cp /usr/src/linux/.config /boot/config-2.4.18-19.8.0-26mar2001
              </programlisting>
              <emphasis remap="bf">
                NOTE : 
              </emphasis>
              If you are planning to use the initrd in LILO or GRUB then you 
              may want to build initrd and place it in /boot/initrd*.img. See 
              the Appendix A at 
              <xref linkend="create_initrd"/>
              . 
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Configure GRUB or LILO : 
              </emphasis>
              There are two options for boot loading under Redhat Linux - GRUB 
              and LILO. 
              <emphasis remap="bf">
                Configure GRUB: 
              </emphasis>
              GRUB is recent and much better tool than LILO and it is my first 
              preference to use GRUB. LILO is an older technology. GRUB 
              differs from bootloaders such as LILO in that 
              <emphasis remap="it">
                "it can lie to MS Windows and make MS Windows believe that 
                it's installed on the first partition even if it's not!!" 
              </emphasis>
              . So you can keep your current Linux system where it is and 
              install Windows on the side. See the 
              <xref linkend="grubconf"/>
              file. 
              <emphasis remap="bf">
                Configure LILO: 
              </emphasis>
              LILO is older tool and see the 
              <xref linkend="liloconf"/>
              to configure LILO. 
            </para>
          </listitem>
          <listitem>
            <para>
              Reboot the machine and at lilo press tab key and type 'myker' If 
              it boots then you did a good job! Otherwise at lilo select your 
              old kernel, boot and re-try all over again. Your old kernel 
              <emphasis remap="bf">
                is still INTACT and SAFE 
              </emphasis>
              at say 
              <emphasis remap="it">
                /boot/vmlinuz-2.0.34-0.6 
              </emphasis>
            </para>
          </listitem>
          <listitem>
            <para>
              If your new kernel 'myker' boots and works properly, you can 
              create the boot disk. Insert a blank floppy into floppy drive 
              and - 
              <programlisting format="linespecific">
	bash# cd /usr/src/linux
	bash# make bzdisk
	See also mkbootdisk -
	bash# rpm -i mkbootdisk*.rpm
	bash# man mkbootdisk
              </programlisting>
            </para>
          </listitem>
          <listitem>
            <para>
              Build RPMs Optional - You can also build RPM packages of kernel, 
              in case you want to install the new image on several machines. 
              <programlisting format="linespecific">
	make rpm   # To build rpm packages
                </programlisting>
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis remap="bf">
                Clean: 
              </emphasis>
              Optional - make clean (If you want to free up disk space) 
            </para>
          </listitem>
        </orderedlist>
      </para>
    </sect2>
    <sect2>
      <title>
        Troubleshooting 
      </title>
      <para>
        Having any problems? See the 
        <xref linkend="troubleshoot"/>
        . 
      </para>
    </sect2>
    <sect2 id="postkernel">
      <title>
        Post Kernel Building 
      </title>
      <para>
        See the 
        <xref linkend="post_kernel_building"/>
        . 
      </para>
    </sect2>
    <sect2 id="reportbugs">
      <title>
        Where to Report Bugs ? 
      </title>
      <para>
        You tried everything above and you think it seems to be a kernel bug. 
        You may want to report this bug so that it will be fixed. You can see 
        the file /usr/src/linux/REPORTING-BUGS and visit the following site - 
        <ulink url="http://www.kernel.org/pub/linux/docs/lkml/reporting-bugs.html">
          Reporting Bugs for the Linux Kernel 
        </ulink>
        . 
      </para>
    </sect2>
  </sect1>
  <sect1 id="loadable_modules">
    <title>
      Loadable Modules 
    </title>
    <para>
      Everyone who used 'Loadable Modules' really "loves" them!! I like the 
      Loadable Modules, they are really cute and they break up a large task 
      into tiny manageable pieces. When you start using them, I can bet that 
      you will fall in love them! Loadable Module is peculiar only to Linux. 
      Linux is the first operating system in the world to introduce the 
      concept of Loadable Module. No other operating system has this concept, 
      but in near future other operating systems may implement this. 
    </para>
    <para>
      Loadable kernel modules can save memory and ease configuration. The 
      scope of modules has grown to include filesystems, ethernet card 
      drivers, tape drivers, printer drivers, and more. 
    </para>
    <para>
      Loadable modules are pieces of kernel code which are not linked 
      (included) directly in the kernel. One compiles them separately, and can 
      insert and remove them into the running kernel at almost any time. Due 
      to its flexibility, this is now the preferred way to code certain kernel 
      features. Many popular device drivers, such as the PCMCIA drivers and 
      the QIC-80/40 tape driver, are loadable modules. 
    </para>
    <para>
      See the Module-HOWTO at 
      <ulink url="http://www.tldp.org/HOWTO/Module-HOWTO">
        "http://www.tldp.org/HOWTO/Module-HOWTO" 
      </ulink>
      . 
    </para>
    <para>
      And see these man pages 
      <programlisting format="linespecific">
	bash# rpm -i /mnt/cdrom/Redhat/RPMS/modutils*.rpm
	bash# man lsmod
	bash# man insmod
	bash# man rmmod
	bash# man depmod
	bash# man modprobe
      </programlisting>
      For example to load the module 
      <literal moreinfo="none" remap="tt">
        /lib/modules/2.4.2-2/kernel/drivers/block/loop.o 
      </literal>
      , you would do : 
      <programlisting format="linespecific">
	bash# man insmod
	bash# modprobe loop
	bash# insmod loop
	bash# lsmod 
      </programlisting>
      You can set the PATH which the insmod searches in /etc/modules.conf. 
    </para>
    <sect2>
      <title>
        Installing the module utilities 
      </title>
      <para>
        You can install the Module Utilities RPM with: 
        <programlisting format="linespecific">
	bash# rpm -i /mnt/cdrom/Redhat/RPMS/modutils*.rpm
        </programlisting>
      </para>
      <para>
        <literal moreinfo="none" remap="tt">
          insmod 
        </literal>
        inserts a module into the running kernel. Modules usually have a 
        <literal moreinfo="none" remap="tt">
          .o 
        </literal>
        extension; the example driver mentioned above is called 
        <literal moreinfo="none" remap="tt">
          drv_hello.o 
        </literal>
        , so to insert this, one would say ` 
        <literal moreinfo="none" remap="tt">
          insmod drv_hello.o 
        </literal>
        '. To see the modules that the kernel is currently using, use 
        <literal moreinfo="none" remap="tt">
          lsmod 
        </literal>
        . The output looks like this: blah# lsmod Module: #pages: Used by: 
        drv_hello 1 ` 
        <literal moreinfo="none" remap="tt">
          drv_hello 
        </literal>
        ' is the name of the module, it uses one page (4k) of memory, and no 
        other kernel modules depend on it at the moment. To remove this 
        module, use ` 
        <literal moreinfo="none" remap="tt">
          rmmod drv_hello 
        </literal>
        '. Note that 
        <literal moreinfo="none" remap="tt">
          rmmod 
        </literal>
        wants a 
        <emphasis remap="it">
          module name, 
        </emphasis>
        not a filename; you get this from 
        <literal moreinfo="none" remap="tt">
          lsmod 
        </literal>
        's listing. The other module utilities' purposes are documented in 
        their manual pages. 
      </para>
    </sect2>
    <sect2>
      <title>
        Modules distributed with the kernel 
      </title>
      <para>
        As of version 2.0.30, most of everything is available as a loadable 
        modules. To use them, first make sure that you don't configure them 
        into the regular kernel; that is, don't say 
        <literal moreinfo="none" remap="tt">
          y 
        </literal>
        to it during ` 
        <literal moreinfo="none" remap="tt">
          make config 
        </literal>
        '. Compile a new kernel and reboot with it. Then, 
        <literal moreinfo="none" remap="tt">
          cd 
        </literal>
        to 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux 
        </literal>
        again, and do a ` 
        <literal moreinfo="none" remap="tt">
          make modules 
        </literal>
        '. This compiles all of the modules which you did not specify in the 
        kernel configuration, and places links to them in 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux/modules 
        </literal>
        . You can use them straight from that directory or execute ` 
        <literal moreinfo="none" remap="tt">
          make modules_install 
        </literal>
        ', which installs them in 
        <literal moreinfo="none" remap="tt">
          /lib/modules/x.y.z 
        </literal>
        , where 
        <literal moreinfo="none" remap="tt">
          x.y.z 
        </literal>
        is the kernel release. 
      </para>
      <para>
        This can be especially handy with filesystems. You may not use the 
        minix or msdos filesystems frequently. For example, if I encountered 
        an msdos (shudder) floppy, I would 
        <literal moreinfo="none" remap="tt">
          insmod /usr/src/linux/modules/msdos.o 
        </literal>
        , and then 
        <literal moreinfo="none" remap="tt">
          rmmod msdos 
        </literal>
        when finished. This procedure saves about 50k of RAM in the kernel 
        during normal operation. A small note is in order for the minix 
        filesystem: you should 
        <emphasis remap="it">
          always 
        </emphasis>
        configure it directly into the kernel for use in ``rescue'' disks. 
      </para>
    </sect2>
    <sect2>
      <title>
        Howto Install Just A Single Module ? 
      </title>
      <para>
        Let us assume that you already did 'make modules' and 'make 
        modules_install'. And later you did 'make clean' to free up disk 
        space. And now, you want to change a "C" file in one of the modules 
        and want to rebuild just that module and copy the module file to 
        /lib/modules. How do you do it? And, you do not want to give 'make 
        modules' as that will rebuild everything and will take about 2 to 3 
        hours! 
      </para>
      <para>
        You can compile just a single module file (say like foo.o) and install 
        it. For this simply edit the Makefile and change the SUBDIRS to add 
        only those directories you are interested. 
      </para>
      <para>
        A good example is - I found that my default kernel did not include the 
        NTFS filesystem support (I did make clean after make modules. Darn and 
        Damn it!). So, I decided to compile the loadable module of NTFS. I did 
        not want to compile the whole set (as it will take me about 2 hours), 
        so I followed the procedure below and compiled just the fs/ntfs and 
        did 'insmod ntfs'. It just took me about 5 minutes!! 
      </para>
      <para>
        Another example: If I am interested in installing only fs/autofs 
        module, then I do the following : 
        <programlisting format="linespecific">
	cd /usr/src/linux
	mv Makefile Makefile.original
	cp Makefile.original Makefile.my
	ln -s Makefile.my Makefile   # Because some files underneath still need "Makefile"
	vi Makefile.my
	# And comment out the line having 'SUBDIRS' and add the 
	# directory you are interested, for example like fs/autofs as below :
		#SUBDIRS	=kernel drivers mm fs net ipc lib abi crypto
		SUBDIRS		=fs/autofs
	# Save the file Makefile.my and give -
	make -f Makefile.my modules
	# This will create module autofs.o
	# Now, copy the module object file to destination /lib/modules
	# DANGER: Do NOT DO THIS - "make -f Makefile.my modules_install" This may
	# clean up other good ones in /lib/modules !! But just copy as below:
	cp autofs.o /lib/modules/2.4.18-19.8.0/kernel/fs/autofs
	  
	# Now, reset everything back to normal
	rm Makefile  # This is a link to Makefile.my
	ln -s Makefile.original Makefile
	  
	# Record your changes to the config file for future use
	# Edit the /usr/src/linux/.config file and set the item as module
	cd /usr/src/linux
    mkdir /usr/src/kernelconfigs ;
    cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save;
	cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # ExtraSafe
	cp /boot/config*  /usr/src/linux/configs/  # ExtraSafe
	vi /usr/src/linux/.config 
	# And change the config parameter. For example in case of my
	# ntfs module I did CONFIG_NTFS_FS=m  to indicate as module.
        </programlisting>
      </para>
      <para>
        Learn more about Makefile and make. See the manual for GNU make at 
        <itemizedlist>
          <listitem>
            <para>
              <ulink url="http://www.gnu.org/manual/make">
                "http://www.gnu.org/manual/make" 
              </ulink>
              . 
            </para>
          </listitem>
          <listitem>
            <para>
              University of Utah Makefile 
              <ulink url="http://www.math.utah.edu/docs/info/make-stds_toc.html">
                "http://www.math.utah.edu/docs/info/make-stds_toc.html" 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              University of Hawaii Makefile 
              <ulink url="http://www.eng.hawaii.edu/Tutor/Make">
                "http://www.eng.hawaii.edu/Tutor/Make" 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              In Linux - man make 
            </para>
          </listitem>
          <listitem>
            <para>
              In Linux - info make 
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        Get familiar with the Makefile which makes the modules. The Makefile 
        has module line like 
        <programlisting format="linespecific">
	modules: $(patsubst %, _mod_%, $(SUBDIRS))
        </programlisting>
      </para>
      <para>
        The patsubst function has the syntax $(patsubst 
        pattern,replacement,text). It uses the percent symbol ([percnt]) the 
        same way pattern rules do - as a string which matches in both the 
        pattern and the replacement text. It searches the text for 
        whitespace-separated words that match the pattern and substitutes the 
        replacement for them. 
      </para>
      <para>
        This makefile includes shell functions as well as standard make 
        functions. The syntax for a shell function is $(shell command). This 
        returns the output of the shell function (stripping new lines). 
      </para>
    </sect2>
  </sect1>
  <sect1 id="cloning">
    <title>
      Cloning of Linux Kernels 
    </title>
    <para>
      You may want to build a Linux kernel on a system and then you may want 
      to mass deploy to many identical hardware PCs. To make it easy to 
      install your newly built kernel on hundreds of other systems, you may 
      want to package it in RPMs (Redhat) or DEB package (Debian) or just 
      tar.gz files. 
    </para>
    <para>
      <orderedlist inheritnum="ignore" continuation="restarts">
        <listitem>
          <para>
            Build a kernel rpm package with rpmbuild -ba kernel*.spec 
          </para>
        </listitem>
        <listitem>
          <para>
            Check that the kernel*.rpm generated has all the files in 
            /lib/modules/2.x.x-y directory. Otherwise you may want to tar gzip 
            the directory /lib/modules/2.x.x-y and take it to destination 
            machines. 
          </para>
        </listitem>
        <listitem>
          <para>
            Check that your kernel package has /boot/initrd-2.x.x-y.img file, 
            otherwise you may want to tar gzip and take it to destination 
            machines. 
          </para>
        </listitem>
        <listitem>
          <para>
            And other files in /boot which are not in the kernel*.rpm package. 
          </para>
        </listitem>
      </orderedlist>
    </para>
  </sect1>
  <sect1 id="important_questions">
    <title>
      Important questions and their answers 
    </title>
    <sect2>
      <title>
        What does the kernel do, anyway? 
      </title>
      <para>
        The Unix kernel acts as a mediator for your programs and your 
        hardware. First, it does (or arranges for) the memory management for 
        all of the running programs (processes), and makes sure that they all 
        get a fair (or unfair, if you please) share of the processor's cycles. 
        In addition, it provides a nice, fairly portable interface for 
        programs to talk to your hardware. 
      </para>
      <para>
        There is certainly more to the kernel's operation than this, but these 
        basic functions are the most important to know. 
      </para>
    </sect2>
    <sect2>
      <title>
        Why would I want to upgrade my kernel? 
      </title>
      <para>
        Newer kernels generally offer the ability to talk to more types of 
        hardware (that is, they have more device drivers), they can have 
        better process management, they can run faster than the older 
        versions, they could be more stable than the older versions, and they 
        fix silly bugs in the older versions. Most people upgrade kernels 
        because they want the device drivers and the bug fixes. 
      </para>
    </sect2>
    <sect2>
      <title>
        What kind of hardware do the newer kernels support? 
      </title>
      <para>
        See the 
        <ulink url="http://www.tldp.org/HOWTO/Hardware-HOWTO">
          Hardware-HOWTO 
        </ulink>
        . Alternatively, you can look at the ` 
        <literal moreinfo="none" remap="tt">
          config.in 
        </literal>
        ' file in the linux source, or just find out when you try ` 
        <literal moreinfo="none" remap="tt">
          make config 
        </literal>
        '. This shows you all hardware supported by the standard kernel 
        distribution, but not everything that linux supports; many common 
        device drivers (such as the PCMCIA drivers and some tape drivers) are 
        loadable modules maintained and distributed separately. 
      </para>
    </sect2>
    <sect2>
      <title>
        What version of gcc and libc do I need? 
      </title>
      <para>
        Linus recommends a version of gcc in the 
        <literal moreinfo="none" remap="tt">
          README 
        </literal>
        file included with the linux source. If you don't have this version, 
        the documentation in the recommended version of gcc should tell you if 
        you need to upgrade your libc. This is not a difficult procedure, but 
        it is important to follow the instructions. 
      </para>
    </sect2>
    <sect2>
      <title>
        What's a loadable module? 
      </title>
      <para>
        See the Modules chapter at 
        <xref linkend="loadable_modules"/>
        . 
      </para>
    </sect2>
    <sect2>
      <title>
        How much disk space do I need? 
      </title>
      <para>
        It depends on your particular system configuration. First, the 
        compressed linux source is nearly 14 megabytes large at version 2.2.9. 
        Many sites keep this even after unpacking. Uncompressed and built with 
        a moderate configuration, it takes up another 67 MB. 
      </para>
    </sect2>
    <sect2>
      <title>
        How long does it take? 
      </title>
      <para>
        With newer machines, the compilation takes dramatically less time than 
        older ones; an AMD K6-2/300 with a fast disk can do a 2.2.x kernel in 
        about four minutes. As for old Pentiums, 486s, and 386s, if you plan 
        to compile one, be prepared to wait, possibly hours, days.. 
      </para>
      <para>
        If this troubles you, and you happen to have a faster machine around 
        to compile on, you can build on the fast machines (assuming you give 
        it the right parameters, that your ulilities are up-to-date, and so 
        on), and then transfer the kernel image to the slower machine. 
      </para>
    </sect2>
  </sect1>
  <sect1 id="patching_the_kernel">
    <title>
      Patching the kernel 
    </title>
    <sect2>
      <title>
        Applying a patch 
      </title>
      <para>
        Incremental upgrades of the kernel are distributed as patches. For 
        example, if you have Linux v1.1.45, and you notice that there's a ` 
        <literal moreinfo="none" remap="tt">
          patch46.gz 
        </literal>
        ' out there for it, it means you can upgrade to version 1.1.46 through 
        application of the patch. You might want to make a backup of the 
        source tree first (` 
        <literal moreinfo="none" remap="tt">
          make clean 
        </literal>
        ' and then ` 
        <literal moreinfo="none" remap="tt">
          cd /usr/src; tar zcvf old-tree.tar.gz linux 
        </literal>
        ' will make a compressed tar archive for you.). 
      </para>
      <para>
        So, continuing with the example above, let's suppose that you have ` 
        <literal moreinfo="none" remap="tt">
          patch46.gz 
        </literal>
        ' in 
        <literal moreinfo="none" remap="tt">
          /usr/src 
        </literal>
        . 
        <literal moreinfo="none" remap="tt">
          cd 
        </literal>
        to 
        <literal moreinfo="none" remap="tt">
          /usr/src 
        </literal>
        and do a ` 
        <literal moreinfo="none" remap="tt">
          zcat patch46.gz [verbar] patch -p0 
        </literal>
        ' (or ` 
        <literal moreinfo="none" remap="tt">
          patch -p0 [lt ] patch46 
        </literal>
        ' if the patch isn't compressed). You'll see things whizz by (or 
        flutter by, if your system is that slow) telling you that it is trying 
        to apply hunks, and whether it succeeds or not. Usually, this action 
        goes by too quickly for you to read, and you're not too sure whether 
        it worked or not, so you might want to use the 
        <literal moreinfo="none" remap="tt">
          -s 
        </literal>
        flag to 
        <literal moreinfo="none" remap="tt">
          patch 
        </literal>
        , which tells 
        <literal moreinfo="none" remap="tt">
          patch 
        </literal>
        to only report error messages (you don't get as much of the ``hey, my 
        computer is actually doing something for a change!'' feeling, but you 
        may prefer this..). To look for parts which might not have gone 
        smoothly, cd to 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux 
        </literal>
        and look for files with a 
        <literal moreinfo="none" remap="tt">
          .rej 
        </literal>
        extension. Some versions of 
        <literal moreinfo="none" remap="tt">
          patch 
        </literal>
        (older versions which may have been compiled with on an inferior 
        filesystem) leave the rejects with a 
        <literal moreinfo="none" remap="tt">
          # 
        </literal>
        extension. You can use ` 
        <literal moreinfo="none" remap="tt">
          find 
        </literal>
        ' to look for you; find . -name '*.rej' -print prints all files who 
        live in the current directory or any subdirectories with a 
        <literal moreinfo="none" remap="tt">
          .rej 
        </literal>
        extension to the standard output. 
      </para>
      <para>
        If everything went right, do a ` 
        <literal moreinfo="none" remap="tt">
          make clean 
        </literal>
        ', ` 
        <literal moreinfo="none" remap="tt">
          config 
        </literal>
        ', and ` 
        <literal moreinfo="none" remap="tt">
          dep 
        </literal>
        ' as described in sections 3 and 4. 
      </para>
      <para>
        There are quite a few options to the 
        <literal moreinfo="none" remap="tt">
          patch 
        </literal>
        command. As mentioned above, 
        <literal moreinfo="none" remap="tt">
          patch -s 
        </literal>
        will suppress all messages except the errors. If you keep your kernel 
        source in some other place than 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux 
        </literal>
        , 
        <literal moreinfo="none" remap="tt">
          patch -p1 
        </literal>
        (in that directory) will patch things cleanly. Other 
        <literal moreinfo="none" remap="tt">
          patch 
        </literal>
        options are well-documented in the manual page. 
      </para>
    </sect2>
    <sect2>
      <title>
        If something goes wrong 
      </title>
      <para>
        (Note: this section refers mostly to quite old kernels) 
      </para>
      <para>
        The most frequent problem that used to arise was when a patch modified 
        a file called ` 
        <literal moreinfo="none" remap="tt">
          config.in 
        </literal>
        ' and it didn't look quite right, because you changed the options to 
        suit your machine. This has been taken care of, but one still might 
        encounter it with an older release. To fix it, look at the 
        <literal moreinfo="none" remap="tt">
          config.in.rej 
        </literal>
        file, and see what remains of the original patch. The changes will 
        typically be marked with ` 
        <literal moreinfo="none" remap="tt">
          + 
        </literal>
        ' and ` 
        <literal moreinfo="none" remap="tt">
          - 
        </literal>
        ' at the beginning of the line. Look at the lines surrounding it, and 
        remember if they were set to ` 
        <literal moreinfo="none" remap="tt">
          y 
        </literal>
        ' or ` 
        <literal moreinfo="none" remap="tt">
          n 
        </literal>
        '. Now, edit 
        <literal moreinfo="none" remap="tt">
          config.in 
        </literal>
        , and change ` 
        <literal moreinfo="none" remap="tt">
          y 
        </literal>
        ' to ` 
        <literal moreinfo="none" remap="tt">
          n 
        </literal>
        ' and ` 
        <literal moreinfo="none" remap="tt">
          n 
        </literal>
        ' to ` 
        <literal moreinfo="none" remap="tt">
          y 
        </literal>
        ' when appropriate. Do a patch -p0 &lt; config.in.rej and if it 
        reports that it succeeded (no fails), then you can continue on with a 
        configuration and compilation. The 
        <literal moreinfo="none" remap="tt">
          config.in.rej 
        </literal>
        file will remain, but you can get delete it. 
      </para>
      <para>
        If you encounter further problems, you might have installed a patch 
        out of order. If patch says ` 
        <literal moreinfo="none" remap="tt">
          previously applied patch detected: Assume -R? 
        </literal>
        ', you are probably trying to apply a patch which is below your 
        current version number; if you answer ` 
        <literal moreinfo="none" remap="tt">
          y 
        </literal>
        ', it will attempt to degrade your source, and will most likely fail; 
        thus, you will need to get a whole new source tree (which might not 
        have been such a bad idea in the first place). 
      </para>
      <para>
        To back out (unapply) a patch, use ` 
        <literal moreinfo="none" remap="tt">
          patch -R 
        </literal>
        ' on the original patch. 
      </para>
      <para>
        The best thing to do when patches really turn out wrong is to start 
        over again with a clean, out-of-the-box source tree (for example, from 
        one of the 
        <literal moreinfo="none" remap="tt">
          linux-x.y.z.tar.gz 
        </literal>
        files), and start again. 
      </para>
    </sect2>
    <sect2>
      <title>
        Getting rid of the .orig files 
      </title>
      <para>
        After just a few patches, the 
        <literal moreinfo="none" remap="tt">
          .orig 
        </literal>
        files will start to pile up. For example, one 1.1.51 tree I had was 
        once last cleaned out at 1.1.48. Removing the .orig files saved over a 
        half a meg. find . -name '*.orig' -exec rm -f {} ';' will take care of 
        it for you. Versions of 
        <literal moreinfo="none" remap="tt">
          patch 
        </literal>
        which use 
        <literal moreinfo="none" remap="tt">
          # 
        </literal>
        for rejects use a tilde instead of 
        <literal moreinfo="none" remap="tt">
          .orig 
        </literal>
        . 
      </para>
      <para>
        There are better ways to get rid of the 
        <literal moreinfo="none" remap="tt">
          .orig 
        </literal>
        files, which depend on GNU 
        <literal moreinfo="none" remap="tt">
          xargs 
        </literal>
        : find . -name '*.orig' | xargs rm or the ``quite secure but a little 
        more verbose'' method: find . -name '*.orig' -print0 | xargs --null rm 
        -- 
      </para>
    </sect2>
    <sect2>
      <title>
        Other patches 
      </title>
      <para>
        There are other patches (I'll call them ``nonstandard'') than the ones 
        Linus distributes. If you apply these, Linus' patches may not work 
        correctly and you'll have to either back them out, fix the source or 
        the patch, install a new source tree, or a combination of the above. 
        This can become very frustrating, so if you do not want to modify the 
        source (with the possibility of a very bad outcome), back out the 
        nonstandard patches before applying Linus', or just install a new 
        tree. Then, you can see if the nonstandard patches still work. If they 
        don't, you are either stuck with an old kernel, playing with the patch 
        or source to get it to work, or waiting (possibly begging) for a new 
        version of the patch to come out. 
      </para>
      <para>
        How common are the patches not in the standard distribution? You will 
        probably hear of them. I used to use the noblink patch for my virtual 
        consoles because I hate blinking cursors (This patch is (or at least 
        was) frequently updated for new kernel releases.). With most newer 
        device drivers being developed as loadable modules, though, the 
        frequecy of ``nonstandard'' patches is decreasing significantly. 
      </para>
    </sect2>
  </sect1>
  <sect1 id="tips_and_tricks">
    <title>
      Tips and tricks 
    </title>
    <sect2>
      <title>
        Redirecting output of the make or patch commands 
      </title>
      <para>
        If you would like logs of what those ` 
        <literal moreinfo="none" remap="tt">
          make 
        </literal>
        ' or ` 
        <literal moreinfo="none" remap="tt">
          patch 
        </literal>
        ' commands did, you can redirect output to a file. First, find out 
        what shell you're running: ` 
        <literal moreinfo="none" remap="tt">
          grep root /etc/passwd 
        </literal>
        ' and look for something like ` 
        <literal moreinfo="none" remap="tt">
          /bin/csh 
        </literal>
        '. 
      </para>
      <para>
        If you use sh or bash, (command) 2&gt;&amp;1 | tee (output file) will 
        place a copy of 
        <literal moreinfo="none" remap="tt">
          (command) 
        </literal>
        's output in the file ` 
        <literal moreinfo="none" remap="tt">
          (output file) 
        </literal>
        '. 
      </para>
      <para>
        For csh or tcsh, use (command) |&amp; tee (output file) 
      </para>
      <para>
        For rc (Note: you probably do not use rc) it's (command) &gt;[2=1] | 
        tee (output file) 
      </para>
    </sect2>
    <sect2>
      <title>
        Conditional kernel install 
      </title>
      <para>
        Other than using floppy disks, there are several methods of testing 
        out a new kernel without touching the old one. Unlike many other Unix 
        flavors, LILO has the ability to boot a kernel from anywhere on the 
        disk (if you have a large (500 MB or above) disk, please read over the 
        LILO documentation on how this may cause problems). So, if you add 
        something similar to image = /usr/src/linux/arch/i386/boot/bzImage 
        label = new_kernel to the end of your LILO configuration file, you can 
        choose to run a newly compiled kernel without touching your old 
        <literal moreinfo="none" remap="tt">
          /vmlinuz 
        </literal>
        (after running 
        <literal moreinfo="none" remap="tt">
          lilo 
        </literal>
        , of course). The easiest way to tell LILO to boot a new kernel is to 
        press the shift key at bootup time (when it says 
        <literal moreinfo="none" remap="tt">
          LILO 
        </literal>
        on the screen, and nothing else), which gives you a prompt. At this 
        point, you can enter ` 
        <literal moreinfo="none" remap="tt">
          new_kernel 
        </literal>
        ' to boot the new kernel. 
      </para>
      <para>
        If you wish to keep several different kernel source trees on your 
        system at the same time (this can take up a 
        <emphasis remap="it">
          lot 
        </emphasis>
        of disk space; be careful), the most common way is to name them 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux-x.y.z 
        </literal>
        , where 
        <literal moreinfo="none" remap="tt">
          x.y.z 
        </literal>
        is the kernel version. You can then ``select'' a source tree with a 
        symbolic link; for example, ` 
        <literal moreinfo="none" remap="tt">
          ln -sf linux-1.2.2 /usr/src/linux 
        </literal>
        ' would make the 1.2.2 tree current. Before creating a symbolic link 
        like this, make certain that the last argument to 
        <literal moreinfo="none" remap="tt">
          ln 
        </literal>
        is not a real directory (old symbolic links are fine); the result will 
        not be what you expect. 
      </para>
    </sect2>
    <sect2>
      <title>
        Kernel updates 
      </title>
      <para>
        Russell Nelson ( 
        <literal moreinfo="none" remap="tt">
          nelson@crynwr.com 
        </literal>
        ) summarizes the changes in new kernel releases. These are short, and 
        you might like to look at them before an upgrade. They are available 
        with anonymous ftp from 
        <ulink url="ftp://ftp.emlist.com">
          "ftp://ftp.emlist.com" 
        </ulink>
        in 
        <literal moreinfo="none" remap="tt">
          pub/kchanges 
        </literal>
        or through the URL 
        <ulink url="http://www.crynwr.com/kchanges">
          "http://www.crynwr.com/kchanges" 
        </ulink>
      </para>
    </sect2>
  </sect1>
  <sect1 id="ftpfs">
    <title>
      Mount RPMs With FTPFS 
    </title>
    <para>
      By this time, your kernel is compiled and running ok. You will have the 
      need to access countless number of RPMs which you may need to install in 
      near future. One way is to physically mount the Linux CDROMS, but there 
      are more than 3 Linux cdroms and it is cumbersome to remove and change 
      the Linux cdroms. Hence, here comes the FTPFS. 
    </para>
    <para>
      If you want to automate the installing of RPMs, then consider the 
      'apt-get' command. The apt-get automatically detects all the 
      dependencies and downloads and installs or upgrades the packages 
      automatically. See the section "Install, Update at Speed of Light" in 
      <xref linkend="apt-get"/>
    </para>
    <para>
      FTP File System is a Linux kernel module, enhancing the VFS with FTP 
      volume mounting capabilities. That is, you can "mount" FTP shared 
      directories in your very personal file system and take advantage of 
      local files ops. It is at 
      <ulink url="http://lufs.sourceforge.net/lufs">
        "http://lufs.sourceforge.net/lufs" 
      </ulink>
      and at 
      <ulink url="http://ftpfs.sourceforge.net">
        "http://ftpfs.sourceforge.net" 
      </ulink>
      . 
    </para>
    <sect2>
      <title>
        Using the ftpfs 
      </title>
      <para>
        Download the ftpfs and install it on your system. The ftpfs is 
        installed as a module in 
        /lib/modules/2.4.18-19.8.0/kernel/fs/ftpfs/ftpfs.o. And also the 
        command ftpmount is in /usr/bin/ftpmount. And you can do the 
        following: 
      </para>
      <para>
        Login as root (su - root) and run this script: 
        <programlisting format="linespecific">
	#!/bin/sh -x
	# Use this script to mount ftp redhat cdroms rpms directory disk1,2,3
	# Built rpm by name ftpfs.
	# http://lufs.sourceforge.net/main/projects.html
	# ftpmount --help
	# Try this: ftpmount [user[:pass]@]host_name[:port][/root_dir] mount_point [-o]
	# [-uid=id] [gid=id] [fmask=mask] [dmask=mask]
	#ftpmount anonymous:pass@ftp.kernel.org /mnt/ftpfs
	#mkdir -p /mnt/ftpfs /mnt/ftpfs/updates /mnt/ftpfs/rpms /mnt/ftpfs/contrib
	# Redhat ftp mirror sites - http://www.redhat.com/download/mirror.html
	FTPSITE="csociety-ftp.ecn.purdue.edu"
	USER="anonymous:pass"
	ftpmount $USER@$FTPSITE/pub/redhat/redhat  /mnt/ftpfs/site
	ftpmount $USER@$FTPSITE/pub/redhat/redhat/linux/updates/8.0/en/os  /mnt/ftpfs/updates
	ftpmount $USER@$FTPSITE/pub/redhat/redhat/linux/8.0/en/os/i386/RedHat /mnt/ftpfs/rpms
	ftpmount $USER@$FTPSITE/pub/redhat-contrib /mnt/ftpfs/contrib
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        The ftpfs Commands 
      </title>
      <para>
        Before you even start thinking about mounting FTP volumes, make sure 
        you have a decent bandwidth or it's gonna suck. 
      </para>
      <sect3>
        <title>
          The autofs way - A must try! 
        </title>
        <para>
          If you were wise enough to install the autofs/automount bridge 
          (check out the installation notes) there is a cool way to use ftpfs: 
          just try to access any file/dir on the desired server under 
          /mnt/ftpfs. 
          <programlisting format="linespecific">
	cd /mnt/ftpfs/[user:pass@]ftp_server[:port]
          </programlisting>
        </para>
        <para>
          Something like cd /mnt/ftpfs/ftp.kernel.org. And guess what? You're 
          there! 
        </para>
        <para>
          Normally you will only use this for anonymous ftp since you don't 
          want your user/pass info to show up in the /mnt/ftpfs/ tree. 
        </para>
      </sect3>
      <sect3>
        <title>
          The ftpmount way 
        </title>
        <para>
          <emphasis remap="bf">
            ftpmount [lsqb ]user[lsqb ]:password]@]hostname[lsqb ]:port ][lsqb 
            ]/root_dir] mount_point [lsqb ]-own] [lsqb ]-uid=id] [lsqb 
            ]-gid=id] [lsqb ]-fmask=mask] [lsqb ]-dmask=mask] [lsqb ]-active] 
          </emphasis>
        </para>
        <para>
          <programlisting format="linespecific">
	The parameters: [defaults]
	    * user: The user to be used for logging on the FTP server. [anonymous]
	    * password: The password for that user. [user@ftpfs.sourceforge.net]
	    * hostname: The FTP server.
	    * port: The port the server is listening on. [21]
	    * root_dir: The directory on the FTP server you want to be mounted. This should be specified without the trailing slash (that is "/home/duru", not "/home/duru/"). [/]
	    * mount_point: The local directory you want to mount the FTP server onto.
	    * own: Flag to force ownership on all remote files. Useful for FTP servers that list user IDs instead of user names.
	    * uid: The local user ID you want to be the owner of the mounted tree.
	    * gid: The local group ID you want to own the mounted tree.
	    * fmask: The numeric mode to be ORed on all mounted files.
	    * dmask: The numeric mode to be ORed on all mounted dirs.
	    * active: Flag to enable active mode for FTP transfers. Useful if you're behind some firewall and cannot connect to random ports.
          </programlisting>
        </para>
        <para>
          Eg: ftpmount mali@ftp.linuxnet.wox.org /mnt/ftpfs -uid=500 -gid=500 
          -dmask=555 
        </para>
        <para>
          It is generally a good idea not to provide your password as a 
          parameter, since ftpmount will ask for it. 
        </para>
      </sect3>
      <sect3>
        <title>
          The mount way 
        </title>
        <para>
          If for some reason you choose not to use ftpmount (you probably 
          installed the kernel patch and are too lazy to install ftpmount 
          too), here's the way to use good-ol mount: 
        </para>
        <para>
          <emphasis remap="bf">
            mount -n -t ftpfs none mount_point -o ip=server_ip [lsqb 
            ],user=user_name] [lsqb ],pass=password] [lsqb ],port=server_port] 
            [lsqb ],root= root_dir] [lsqb ],own] [lsqb ],uid=id] [lsqb 
            ],gid=id] [lsqb ],fmode=mask] [lsqb ],dmode=mask] [lsqb ],active] 
          </emphasis>
        </para>
        <para>
          Please note that you have to provide the server's IP and that the 
          only way to enter a password is in clear. For example, while 
          testing, I used the following command: 
        </para>
        <para>
          mount -n -t ftpfs none /mnt/ftpfs -o 
          ip=127.0.0.1,user=mali,pass=my_pass 
        </para>
      </sect3>
      <sect3>
        <title>
          Some notes 
        </title>
        <para>
          To unmount the volume, you go like 
          <programlisting format="linespecific">
	umount mount_point
          </programlisting>
        </para>
        <para>
          The own option (-o for ftpmount) forces ownership by the mounting 
          user on all files. This is useful for accommodating servers with 
          strange user/permissions management (SERVU &amp; stuff). 
        </para>
        <para>
          A few words of wisdom: 
          <itemizedlist>
            <listitem>
              <para>
                Use -n mount option! I bet you don't want your user/password 
                information listed in mtab. 
              </para>
            </listitem>
            <listitem>
              <para>
                Don't push it! (pushing it = a dozen processes reading on the 
                mount point) 
              </para>
            </listitem>
            <listitem>
              <para>
                It works best for one process! While concurrent access (under 
                normal circumstances) shouldn't cause any problem, the output 
                is optimized for one process reading (the TCP connection is 
                kept alive). So, if you're gonna watch a movie, you don't want 
                other processes to access the mount point and kill the 
                throughoutput (trust me!). 
              </para>
            </listitem>
            <listitem>
              <para>
                The address in IP format sucks! - Go get ftpmount. 
              </para>
            </listitem>
          </itemizedlist>
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="kernel_textbooks">
    <title>
      Linux Kernel Textbooks and Documents 
    </title>
    <para>
      Check the following books on "The Linux Kernel" at 
      <itemizedlist>
        <listitem>
          <para>
            Understanding the Linux Kernel : In your computer at 
            /usr/src/linux/Documentation, see the file kernel-docs.txt which 
            is also online at 
            <ulink url="http://www.dit.upm.es/~jmseyas/linux/kernel/hackers-docs.html">
              "http://www.dit.upm.es/~jmseyas/linux/kernel/hackers-docs.html" 
            </ulink>
            This lists several important links on Linux Kernel Textbooks and 
            kernel documentation. Must visit this website. 
          </para>
        </listitem>
        <listitem>
          <para>
            Kernel book 
            <ulink url="http://kernelbook.sourceforge.net">
              "http://kernelbook.sourceforge.net" 
            </ulink>
            and at 
            <ulink url="http://sourceforge.net/projects/kernelbook">
              "http://sourceforge.net/projects/kernelbook" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Linux Kernel books like 'The Linux Kernel Module Programming 
            Guide', 'Linux Kernel 2.4 Internals', 'The Linux System 
            Administrators Guide', 'The Linux Network Administrator's Guide' 
            and others at 
            <ulink url="http://www.tldp.org/guides.html">
              "http://www.tldp.org/guides.html" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            FreeTech books 
            <ulink url="http://www.tcfb.com/freetechbooks/booklinuxdev.html">
              "http://www.tcfb.com/freetechbooks/booklinuxdev.html" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Rusty's 
            <ulink url="http://www.netfilter.org/unreliable-guides">
              "http://www.netfilter.org/unreliable-guides" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Linux Kernel links 
            <ulink url="http://www.topology.org/soft/lkernel.html">
              "http://www.topology.org/soft/lkernel.html" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Linux Kernel Internals 
            <ulink url="http://www.moses.uklinux.net/patches/lki.html">
              "http://www.moses.uklinux.net/patches/lki.html" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Books links 
            <ulink url="http://linux-mm.org/kernel-links.shtml">
              "http://linux-mm.org/kernel-links.shtml" 
            </ulink>
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      Presentation of Kernel building process 
      <ulink url="http://mike.passwall.com/nblug/kernel-talk">
        NBLUG Linux Seminars - Kernel Building Presentation Talks 
      </ulink>
    </para>
    <para>
      Refer also to other relevant HOWTOs at: 
      <itemizedlist>
        <listitem>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html">
              Bootdisk-HOWTO 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/Sound-HOWTO/index.html">
              Sound-HOWTO : 
            </ulink>
            sound cards and utilities 
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/SCSI-Generic-HOWTO/index.html">
              SCSI-HOWTO: 
            </ulink>
            all about SCSI controllers and devices. And see also 
            <ulink url="http://www.tldp.org/HOWTO/SCSI-2.4-HOWTO/index.html">
              SCSI-2.4-HOWTO 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/Net-HOWTO/index.html">
              NET-2-HOWTO: 
            </ulink>
            networking 
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/PPP-HOWTO/index.html">
              PPP-HOWTO: 
            </ulink>
            PPP networking in particular 
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/PCMCIA-HOWTO.html">
              PCMCIA-HOWTO: 
            </ulink>
            about the drivers for your notebook 
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.doclib.org/Linux/docs/HOWTO/other-formats/html/ELF-HOWTO-html/ELF-HOWTO.html">
              ELF-HOWTO: 
            </ulink>
            ELF: what it is, converting.. Mirror sites at 
            <ulink url="http://cs.mipt.ru/docs/comp/eng/os/linux/howto/howto_english/elf/elf-howto.html">
              ELF-HOWTO-mirror 
            </ulink>
            . See also 
            <ulink url="http://www.tldp.org/HOWTO/GCC-HOWTO">
              GCC-HOWTO 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.tldp.org/HOWTO/Hardware-HOWTO/index.html">
              Hardware-HOWTO: 
            </ulink>
            overview of supported hardware 
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://tldp.org/HOWTO/mini/Modules/index.html">
              Module mini-HOWTO: 
            </ulink>
            more on kernel modules 
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://tldp.org/HOWTO/mini/Kerneld/index.html">
              Kerneld mini-HOWTO: 
            </ulink>
            about kerneld 
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://tldp.org/HOWTO/mini/BogoMips.html">
              BogoMips mini-HOWTO: 
            </ulink>
            in case you were wondering 
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </sect1>
  <sect1 id="kernel_files_info">
    <title>
      Kernel Files Information 
    </title>
    <para>
      This section gives a "very brief" and "introduction" to some of the 
      Linux Kernel System. If you have time you can give one reading. 
    </para>
    <para>
      Caution: You should be extra careful about these Kernel Files and you 
      must not edit or touch or move/delete/rename them. 
    </para>
    <sect2 id="vmlinuz">
      <title>
        vmlinuz and vmlinux 
      </title>
      <para>
        The "vm" stands for "Virtual Memory". Linux supports virtual memory 
        unlike old operating systems like DOS which have a hard limit of 640KB 
        memory. Linux can use the hard disk space as "virtual memory" and 
        hence the name "vm". The vmlinuz is the Linux kernel executable. This 
        is located at /boot/vmlinuz. This can be a soft link to something like 
        /boot/vmlinuz-2.4.18-19.8.0. The vmlinuz is created by "make zImage" 
        and you do "cp /usr/src/linux/arch/i386/linux/boot/zImage 
        /boot/vmlinuz". The vmlinuz is a compressed file of vmlinux. The 
        zImage is there for backward compatibility (smaller kernels). Note 
        that, in near future zImage may be dropped in favor of 'make bzImage' 
        (big zImage). The zImage (vmlinuz) is not just a compressed image, but 
        has gzip decompressor code built into it as well (at the beginning). 
        So you cannot use gunzip or gzip -dc to unpack vmlinuz. 
      </para>
      <para>
        Both zImage and bzImage are compressed with gzip. The kernel includes 
        a mini-gunzip to uncompress the kernel and boot into it. The 
        difference is that the old zImage uncompresses the kernel into low 
        memory (the first 640k), and bzImage uncompresses the kernel into high 
        memory (over 1M). 
      </para>
      <para>
        The vmlinux is the uncompressed built kernel, vmlinuz is the 
        compressed one, that has been made bootable. (Note both names vmlinux 
        and vmlinuz look same except for last letter z). Generally, you don't 
        need to worry about vmlinux, it is just an intermediate step. 
      </para>
      <para>
        The kernel usually makes a bzImage, and stores it in arch/i386/boot, 
        and it is up to the user to copy it to /boot and configure GRUB or 
        LILO. 
      </para>
    </sect2>
    <sect2 id="bootload">
      <title>
        Bootloader Files 
      </title>
      <para>
        The .b files are "bootloader" files. they are part of the dance 
        required to get a kernel into memory to begin with. You should NOT 
        touch them. 
        <programlisting format="linespecific">
	ls -l /boot/*.b
	-rw-r--r--    1 root     root         5824 Sep  5  2002 /boot/boot.b
	-rw-r--r--    1 root     root          612 Sep  5  2002 /boot/chain.b
	-rw-r--r--    1 root     root          640 Sep  5  2002 /boot/os2_d.b
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        Message File 
      </title>
      <para>
        The 'message' file contains the message your bootloader will display, 
        prompting you to choose an OS. So DO NOT touch it. 
        <programlisting format="linespecific">
	ls -l /boot/message*
	-rw-r--r--    1 root     root        23108 Sep  6  2002 /boot/message
	-rw-r--r--    1 root     root        21282 Sep  6  2002 /boot/message.ja
        </programlisting>
      </para>
    </sect2>
    <sect2 id="initrdimg">
      <title>
        initrd.img 
      </title>
      <para>
        See the Appendix A at 
        <xref linkend="create_initrd"/>
        . 
      </para>
    </sect2>
    <sect2 id="bzimagelbl">
      <title>
        bzImage 
      </title>
      <para>
        The bzImage is the compressed kernel image created with command 'make 
        bzImage' during kernel compile. It important to note that bzImage is 
        not compressed with 
        <emphasis remap="bf">
          bzip2 
        </emphasis>
        !! The name bz in bzImage is misleading!! It stands for "Big Zimage". 
        The "b" in bzImage is "big". Both zImage and bzImage are compressed 
        with gzip. The kernel includes a mini-gunzip to uncompress the kernel 
        and boot into it. The difference is that the old zImage uncompresses 
        the kernel into low memory (the first 640k), and bzImage uncompresses 
        the kernel into high memory (over 1M). The only problem is that there 
        are a very few machines where bzImage is known to have problems 
        (because the machines are buggy). The bzImage actually boots faster, 
        but other than that, there's no difference in the way the system 
        *runs*. The rule is that if all drivers cannot fit into the zImage, 
        then you need to modularize more. 
      </para>
      <para>
        If the kernel is small, it will work as both a zImage and a bzImage, 
        and the booted system runs the same way. A big kernel will work as a 
        bzImage, but not as a zImage. Both bootimages are gzipped, (bzImage is 
        not bzipped as the name would suggest), but are put together and 
        loaded differently, that allows the kernel to load in higher address 
        space, that does not limit it to lower memory in the pathetic intel 
        architecture. So why have both? Backward compatability. Some older 
        lilos and loadlins don't handle the bzImage format. Note, they *boot* 
        differently, but *run* the same. There is a lot of misinformation 
        given out about what a bzImage file is (mostly about it being 
        bzip2ed). 
      </para>
    </sect2>
    <sect2 id="moduleinfo">
      <title>
        module-info 
      </title>
      <para>
        This file "module-info" is a symbolic link: 
        <programlisting format="linespecific">
	$ uname -r
	2.4.18-19.8.0custom
	  
	# ls -l /boot/module-info*
	lrwxrwxrwx    1 root     root           25 Jan 26 10:44 /boot/module-info ->
 module-info-2.4.18-19.8.0
	-rw-r--r--    1 root     root        15436 Sep  4  2002 /boot/module-info-2.4.18-14
	-rw-r--r--    1 root     root        15436 Jan 26 01:29 /boot/module-info-2.4.18-19.8.0
        </programlisting>
      </para>
      <para>
        Note above that it is not a requirement is make module-info symlink to 
        a kernel specific file like the way System-map and vmlinuz is 
        required. It's just a text file so as long as module-info list is 
        recent, you'll be fine. Before removing all the stock RH kernels from 
        your system, you should make a backup of this file: 
        <programlisting format="linespecific">
# cp /boot/module-info-2.4.20-19.9 /boot/module-info-2.4.20-19.9.backup 
        </programlisting>
        It should be safe to do this as module-info rarely changes within the 
        same point release of RH kernels. 
      </para>
      <para>
        This file 'module-info' is created by anaconda/utils/modlist (specific 
        to Redhat Linux Anaconda installer). Other Linux distributions may be 
        having equivalent command. Refer to your Linux distributor's manual 
        pages. 
      </para>
      <para>
        See this script and search for "module-info" 
        <ulink url="http://www.mit.edu/afs/sipb/system/rhlinux/redhat-6.2/misc/src/trees/updmodules">
          updmodules 
        </ulink>
        . 
      </para>
      <para>
        Below is a cut from this script: 
        <programlisting format="linespecific">
	#!/bin/bash
	# updmodules.sh
		MODLIST=$PWD/../anaconda/utils/modlist
		MODINFO=$KERNELROOT/boot/module-info-$version
	-- snip cut 
	blah blah blah 
	-- snip cut 
	    # create the module-info file
	    $MODLIST --modinfo-file $MODINFO --ignore-missing --modinfo \
			$(ls *.o | sed 's/\.o$//') &gt; ../modinfo
        </programlisting>
      </para>
      <para>
        The program anaconda/utils/modlist is located in anaconda-runtime*.rpm 
        on the Redhat CDROM 
        <programlisting format="linespecific">
	cd /mnt/cdrom/RedHat/RPMS
	rpm -i anaconda-8.0-4.i386.rpm
	rpm -i anaconda-runtime-8.0-4.i386.rpm
	ls -l /usr/lib/anaconda-runtime/modlist
        </programlisting>
        Get the source code for anaconda/utils/modlist.c from 
        anaconda*.src.rpm at 
        <ulink url="http://www.rpmfind.net/linux/rpm2html/search.php?query=anaconda">
          "http://www.rpmfind.net/linux/rpm2html/search.php?query=anaconda" 
        </ulink>
        Read online at 
        <ulink url="http://www.trustix.net/pub/Trustix/trustix-1.5/i586/misc/src/anaconda/utils/modlist.c">
          modlist.c 
        </ulink>
        . . 
      </para>
      <para>
        The file 'module-info' is generated during the compile. It is an 
        information file that is at least used during filing proper kernel 
        OOPS reports. It is a list of the module entry points. It may also be 
        used by depmod in building the tables that are used by insmod and its 
        kith and kin. This includes dependancy information for other modules 
        needed to be loaded before any other given module, etc. 
      </para>
      <para>
        Bottom line is: "Don't remove this file module-info." 
      </para>
      <para>
        Some points about module-info: 
        <itemizedlist>
          <listitem>
            <para>
              Is provided by the kernel rpms (built by anaconda-runtime*.rpm) 
            </para>
          </listitem>
          <listitem>
            <para>
              Is a link to module-info-{kernel-version} 
            </para>
          </listitem>
          <listitem>
            <para>
              Contains information about all available modules (at least those 
              included in the default kernel config.) 
            </para>
          </listitem>
          <listitem>
            <para>
              Important to anaconda - in anaconda/utils/modlist command. 
            </para>
          </listitem>
          <listitem>
            <para>
              Might be used by kudzu to determine default parameters for 
              modules when it creates entries in /etc/modules.conf. If you 
              move module-info out of the way, shut down, install a new 
              network card, and re-boot then kudzu would complain loudly. Look 
              at the kudzu source code. 
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
    <sect2 id="configfiles">
      <title>
        config 
      </title>
      <para>
        Everytime you compile and install the kernel image in /boot, you 
        should also copy the corresponding config file to /boot area, for 
        documentation and future reference. Do NOT touch or edit these files!! 
        <programlisting format="linespecific">
	ls -l /boot/config-*
	-rw-r--r--    1 root     root        42111 Sep  4  2002 /boot/config-2.4.18-14
	-rw-r--r--    1 root     root        42328 Jan 26 01:29 /boot/config-2.4.18-19.8.0
	-rw-r--r--    1 root     root        51426 Jan 25 22:21 /boot/config-2.4.18-19.8.0BOOT
	-rw-r--r--    1 root     root        52328 Jan 28 03:22 /boot/config-2.4.18-19.8.0-26mar2003
        </programlisting>
      </para>
    </sect2>
    <sect2 id="grubdir">
      <title>
        grub 
      </title>
      <para>
        If you are using GRUB, then there will be 'grub' directory. 
        <programlisting format="linespecific">
	ls /boot/grub
	device.map     ffs_stage1_5  menu.lst        reiserfs_stage1_5  stage2
	e2fs_stage1_5  grub.conf     minix_stage1_5  splash.xpm.gz      vstafs_stage1_5
	fat_stage1_5   jfs_stage1_5  stage1          xfs_stage1_5
        </programlisting>
        See also 
        <xref linkend="grubconf"/>
        file. 
      </para>
    </sect2>
    <sect2 id="systemmap">
      <title>
        System.map 
      </title>
      <para>
        System.map is a "phone directory" list of function in a particular 
        build of a kernel. It is typically a symlink to the System.map of the 
        currently running kernel. If you use the wrong (or no) System.map, 
        debugging crashes is harder, but has no other effects. Without 
        System.map, you may face minor annoyance messages. 
      </para>
      <para>
        Do NOT touch the System.map files. 
        <programlisting format="linespecific">
	ls -ld /boot/System.map*
	lrwxrwxrwx    1 root     root           30 Jan 26 19:26 /boot/System.map -&gt; System.map-2.4.18-19.8.0custom
	-rw-r--r--    1 root     root       501166 Sep  4  2002 /boot/System.map-2.4.18-14
	-rw-r--r--    1 root     root       510786 Jan 26 01:29 /boot/System.map-2.4.18-19.8.0
	-rw-r--r--    1 root     root       331213 Jan 25 22:21 /boot/System.map-2.4.18-19.8.0BOOT
	-rw-r--r--    1 root     root       503246 Jan 26 19:26 /boot/System.map-2.4.18-19.8.0custom
        </programlisting>
      </para>
      <para>
        <emphasis remap="bf">
          How The Kernel Symbol Table Is Created ? 
        </emphasis>
        System.map is produced by 'nm vmlinux' and irrelevant or uninteresting 
        symbols are grepped out, When you compile the kernel, this file 
        'System.map' is created at /usr/src/linux/System.map. Something like 
        below: 
        <programlisting format="linespecific">
	nm /boot/vmlinux-2.4.18-19.8.0 &gt; System.map
	# Below is the line from /usr/src/linux/Makefile 
	nm vmlinux | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort &gt; System.map
	cp /usr/src/linux/System.map /boot/System.map-2.4.18-14   # For v2.4.18
        </programlisting>
      </para>
      <para>
        From 
        <ulink url="http://www.dirac.org/linux/systemmap.html">
          "http://www.dirac.org/linux/systemmap.html" 
        </ulink>
      </para>
      <sect3>
        <title>
          System.map 
        </title>
        <para>
          There seems to be a dearth of information about the System.map file. 
          It's really nothing mysterious, and in the scheme of things, it's 
          really not that important. But a lack of documentation makes it 
          shady. It's like an earlobe; we all have one, but nobody really 
          knows why. This is a little web page I cooked up that explains the 
          why. 
        </para>
        <para>
          Note, I'm not out to be 100[percnt] correct. For instance, it's 
          possible for a system to not have /proc filesystem support, but most 
          systems do. I'm going to assume you "go with the flow" and have a 
          fairly typical system. 
        </para>
        <para>
          Some of the stuff on oopses comes from Alessandro Rubini's "Linux 
          Device Drivers" which is where I learned most of what I know about 
          kernel programming. 
        </para>
      </sect3>
      <sect3>
        <title>
          What Are Symbols? 
        </title>
        <para>
          In the context of programming, a symbol is the building block of a 
          program: it is a variable name or a function name. It should be of 
          no surprise that the kernel has symbols, just like the programs you 
          write. The difference is, of course, that the kernel is a very 
          complicated piece of coding and has many, many global symbols. 
        </para>
      </sect3>
      <sect3>
        <title>
          What Is The Kernel Symbol Table? 
        </title>
        <para>
          The kernel doesn't use symbol names. It's much happier knowing a 
          variable or function name by the variable or function's address. 
          Rather than using size_t BytesRead, the kernel prefers to refer to 
          this variable as (for example) c0343f20. 
        </para>
        <para>
          Humans, on the other hand, do not appreciate names like c0343f20. We 
          prefer to use something like size_t BytesRead. Normally, this 
          doesn't present much of a problem. The kernel is mainly written in 
          C, so the compiler/linker allows us to use symbol names when we code 
          and allows the kernel to use addresses when it runs. Everyone is 
          happy. 
        </para>
        <para>
          There are situations, however, where we need to know the address of 
          a symbol (or the symbol for an address). This is done by a symbol 
          table, and is very similar to how gdb can give you the function name 
          from a address (or an address from a function name). A symbol table 
          is a listing of all symbols along with their address. Here is an 
          example of a symbol table: 
        </para>
        <para>
          <programlisting format="linespecific">
	   c03441a0 B dmi_broken
	   c03441a4 B is_sony_vaio_laptop
	   c03441c0 b dmi_ident
	   c0344200 b pci_bios_present
	   c0344204 b pirq_table
	   c0344208 b pirq_router
	   c034420c b pirq_router_dev
	   c0344220 b ascii_buffer
	   c0344224 b ascii_buf_bytes
          </programlisting>
        </para>
        <para>
          You can see that the variable named dmi_broken is at the kernel 
          address c03441a0. 
        </para>
      </sect3>
      <sect3>
        <title>
          What Is The System.map File? 
        </title>
        <para>
          There are 2 files that are used as a symbol table: 
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>
                /proc/ksyms 
              </para>
            </listitem>
            <listitem>
              <para>
                System.map 
              </para>
            </listitem>
          </orderedlist>
        </para>
        <para>
          There. You now know what the System.map file is. 
        </para>
        <para>
          Every time you compile a new kernel, the addresses of various symbol 
          names are bound to change. 
        </para>
        <para>
          /proc/ksyms is a "proc file" and is created on the fly when a kernel 
          boots up. Actually, it's not really a file; it's simply a 
          representation of kernel data which is given the illusion of being a 
          disk file. If you don't believe me, try finding the filesize of 
          /proc/ksyms. Therefore, it will always be correct for the kernel 
          that is currently running.. 
        </para>
        <para>
          However, System.map is an actual file on your filesystem. When you 
          compile a new kernel, your old System.map has wrong symbol 
          information. A new System.map is generated with each kernel compile 
          and you need to replace the old copy with your new copy. 
        </para>
      </sect3>
      <sect3>
        <title>
          What Is An Oops? 
        </title>
        <para>
          What is the most common bug in your homebrewed programs? The 
          segfault. Good ol' signal 11. 
        </para>
        <para>
          What is the most common bug in the Linux kernel? The segfault. 
          Except here, the notion of a segfault is much more complicated and 
          can be, as you can imagine, much more serious. When the kernel 
          dereferences an invalid pointer, it's not called a segfault -- it's 
          called an "oops". An oops indicates a kernel bug and should always 
          be reported and fixed. 
        </para>
        <para>
          Note that an oops is not the same thing as a segfault. Your program 
          cannot recover from a segfault. The kernel doesn't necessarily have 
          to be in an unstable state when an oops occurs. The Linux kernel is 
          very robust; the oops may just kill the current process and leave 
          the rest of the kernel in a good, solid state. 
        </para>
        <para>
          An oops is not a kernel panic. In a panic, the kernel cannot 
          continue; the system grinds to a halt and must be restarted. An oops 
          may cause a panic if a vital part of the system is destroyed. An 
          oops in a device driver, for example, will almost never cause a 
          panic. 
        </para>
        <para>
          When an oops occurs, the system will print out information that is 
          relevent to debugging the problem, like the contents of all the CPU 
          registers, and the location of page descriptor tables. In 
          particular, the contents of the EIP (instruction pointer) is 
          printed. Like this: 
          <programlisting format="linespecific">
	   EIP: 0010:[&lt;00000000&gt;]
	   Call Trace: [&lt;c010b860&gt;]
          </programlisting>
        </para>
      </sect3>
      <sect3>
        <title>
          What Does An Oops Have To Do With System.map? 
        </title>
        <para>
          You can agree that the information given in EIP and Call Trace is 
          not very informative. But more importantly, it's really not 
          informative to a kernel developer either. Since a symbol doesn't 
          have a fixed address, c010b860 can point anywhere. 
        </para>
        <para>
          To help us use this cryptic oops output, Linux uses a daemon called 
          klogd, the kernel logging daemon. klogd intercepts kernel oopses and 
          logs them with syslogd, changing some of the useless information 
          like c010b860 with information that humans can use. In other words, 
          klogd is a kernel message logger which can perform name-address 
          resolution. Once klogd tranforms the kernel message, it uses 
          whatever logger is in place to log system wide messages, usually 
          syslogd. 
        </para>
        <para>
          To perform name-address resolution, klogd uses System.map. Now you 
          know what an oops has to do with System.map. 
        </para>
        <para>
          <emphasis remap="bf">
            Fine print: 
          </emphasis>
          There are actually two types of address resolution are performed by 
          klogd. 
        </para>
        <para>
          <itemizedlist>
            <listitem>
              <para>
                Static translation, which uses the System.map file. 
              </para>
            </listitem>
            <listitem>
              <para>
                Dynamic translation which is used with loadable modules, 
                doesn't use 
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          System.map and is therefore not relevant to this discussion, but 
          I'll describe it briefly anyhow. 
        </para>
        <para>
          <emphasis remap="bf">
            Klogd Dynamic Translation 
          </emphasis>
        </para>
        <para>
          Suppose you load a kernel module which generates an oops. An oops 
          message is generated, and klogd intercepts it. It is found that the 
          oops occured at d00cf810. Since this address belongs to a 
          dynamically loaded module, it has no entry in the System.map file. 
          klogd will search for it, find nothing, and conclude that a loadable 
          module must have generated the oops. klogd then queries the kernel 
          for symbols that were exported by loadable modules. Even if the 
          module author didn't export his symbols, at the very least, klogd 
          will know what module generated the oops, which is better than 
          knowing nothing about the oops at all. 
        </para>
        <para>
          There's other software that uses System.map, and I'll get into that 
          shortly. 
        </para>
      </sect3>
      <sect3>
        <title>
          Where Should System.map Be Located? 
        </title>
        <para>
          System.map should be located wherever the software that uses it 
          looks for it. That being said, let me talk about where klogd looks 
          for it. Upon bootup, if klogd isn't given the location of System.map 
          as an argument, it will look for System.map in 3 places, in the 
          following order: 
          <orderedlist inheritnum="ignore" continuation="restarts">
            <listitem>
              <para>
                /boot/System.map 
              </para>
            </listitem>
            <listitem>
              <para>
                /System.map 
              </para>
            </listitem>
            <listitem>
              <para>
                /usr/src/linux/System.map 
              </para>
            </listitem>
          </orderedlist>
        </para>
        <para>
          System.map also has versioning information, and klogd intelligently 
          searches for the correct map file. For instance, suppose you're 
          running kernel 2.4.18 and the associated map file is 
          /boot/System.map. You now compile a new kernel 2.5.1 in the tree 
          /usr/src/linux. During the compiling process, the file 
          /usr/src/linux/System.map is created. When you boot your new kernel, 
          klogd will first look at /boot/System.map, determine it's not the 
          correct map file for the booting kernel, then look at 
          /usr/src/linux/System.map, determine that it is the correct map file 
          for the booting kernel and start reading the symbols. 
        </para>
        <para>
          A few nota bene's: 
        </para>
        <para>
          <itemizedlist>
            <listitem>
              <para>
                Somewhere during the 2.5.x series, the Linux kernel started to 
                untar into linux-version, rather than just linux (show of 
                hands -- how many people have been waiting for this to 
                happen?). I don't know if klogd has been modified to search in 
                /usr/src/linux-version/System.map yet. TODO: Look at the klogd 
                srouce. If someone beats me to it, please email me and let me 
                know if klogd has been modified to look in the new directory 
                name for the linux source code. 
              </para>
            </listitem>
            <listitem>
              <para>
                The man page doesn't tell the whole the story. Look at this: 
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          <programlisting format="linespecific">
	   # strace -f /sbin/klogd | grep 'System.map'
	   31208 open("/boot/System.map-2.4.18", O_RDONLY|O_LARGEFILE) = 2
          </programlisting>
        </para>
        <para>
          Apparently, not only does klogd look for the correct version of the 
          map in the 3 klogd search directories, but klogd also knows to look 
          for the name "System.map" followed by "-kernelversion", like 
          System.map-2.4.18. This is undocumented feature of klogd. 
        </para>
        <para>
          A few drivers will need System.map to resolve symbols (since they're 
          linked against the kernel headers instead of, say, glibc). They will 
          not work correctly without the System.map created for the particular 
          kernel you're currently running. This is NOT the same thing as a 
          module not loading because of a kernel version mismatch. That has to 
          do with the kernel version, not the kernel symbol table which 
          changes between kernels of the same version! 
        </para>
      </sect3>
      <sect3>
        <title>
          What else uses the System.map 
        </title>
        <para>
          Don't think that System.map is only useful for kernel oopses. 
          Although the kernel itself doesn't really use System.map, other 
          programs such as klogd, lsof, 
        </para>
        <para>
          <programlisting format="linespecific">
	   satan# strace lsof 2&gt;&amp;1 1&gt; /dev/null | grep System
	   readlink("/proc/22711/fd/4", "/boot/System.map-2.4.18", 4095) = 23
          </programlisting>
        </para>
        <para>
          and ps : 
        </para>
        <para>
          <programlisting format="linespecific">
	   satan# strace ps 2&gt;&amp;1 1&gt; /dev/null | grep System
	   open("/boot/System.map-2.4.18", O_RDONLY|O_NONBLOCK|O_NOCTTY) = 6
          </programlisting>
        </para>
        <para>
          and many other pieces of software like dosemu require a correct 
          System.map. 
        </para>
      </sect3>
      <sect3>
        <title>
          What Happens If I Don't Have A Healthy System.map? 
        </title>
        <para>
          Suppose you have multiple kernels on the same machine. You need a 
          separate System.map files for each kernel! If boot a kernel that 
          doesn't have a System.map file, you'll periodically see a message 
          like: System.map does not match actual kernel Not a fatal error, but 
          can be annoying to see everytime you do a ps ax. Some software, like 
          dosemu, may not work correctly (although I don't know of anything 
          off the top of my head). Lastly, your klogd or ksymoops output will 
          not be reliable in case of a kernel oops. See the manual pages by 
          giving commands 'man ksymoops' and 'man klogd'. 
        </para>
      </sect3>
      <sect3>
        <title>
          How Do I Remedy The Above Situation? 
        </title>
        <para>
          The solution is to keep all your System.map files in /boot and 
          rename them with the kernel version. Suppose you have multiple 
          kernels like: 
        </para>
        <para>
          <itemizedlist>
            <listitem>
              <para>
                /boot/vmlinuz-2.2.14 
              </para>
            </listitem>
            <listitem>
              <para>
                /boot/vmlinuz-2.2.13 
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          Then just rename your map files according to the kernel version and 
          put them in /boot, like: 
          <programlisting format="linespecific">
	   /boot/System.map-2.2.14
	   /boot/System.map-2.2.13
          </programlisting>
        </para>
        <para>
          Now what if you have two copies of the same kernel? Like: 
          <itemizedlist>
            <listitem>
              <para>
                /boot/vmlinuz-2.2.14 
              </para>
            </listitem>
            <listitem>
              <para>
                /boot/vmlinuz-2.2.14.nosound 
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          The best answer would be if all software looked for the following 
          files: 
          <programlisting format="linespecific">
	   /boot/System.map-2.2.14
	   /boot/System.map-2.2.14.nosound
          </programlisting>
        </para>
        <para>
          You can also use symlinks: 
          <programlisting format="linespecific">
	   System.map-2.2.14
	   System.map-2.2.14.sound
	   ln -s System.map-2.2.14.sound System.map     # Here System.map -&gt; System.map-2.2.14.sound
          </programlisting>
        </para>
      </sect3>
    </sect2>
  </sect1>
  <sect1 id="linux_admin_tools">
    <title>
      Linux System Administration Tools 
    </title>
    <para>
      There are two best admin tools for Linux. They are Linuxconf and Webmin. 
    </para>
    <para>
      The Linux System administration tools are : 
      <itemizedlist>
        <listitem>
          <para>
            Linuxconf 
            <ulink url="http://www.solucorp.qc.ca/linuxconf">
              http://www.solucorp.qc.ca/linuxconf 
            </ulink>
            Linuxconf is a extremely large project. It is tremendously 
            powerful and has large number of features. Linuxconf is the BEST 
            KNOWN system admin tool for Linux!! It is available in all distros 
            like Redhat, Debian, Suse, and others. The Linuxconf is the 
            equivalent of SAM of HPUX and SMITTY of AIX. It runs on console 
            window and as well as in GUI in X-Window. On Debian Linux to 
            download and install just do 'apt-get linuxconf'. 
          </para>
        </listitem>
        <listitem>
          <para>
            The Webmin is the most powerful and very popular system admin tool 
            for Linux. Webmin is so popular and it was awarded the best System 
            Administration tool for Solaris, BSD, Linux, HPUX, AIX, SCO and 
            others. Webmin had been winning awards year after year for the 
            past 5 years by many organisations, conferences and editors. 
            Webmin can also be used for admin of other OSes like AIX, Solaris, 
            HPUX, IRIX, BSD, SCO Unix, OSF, Darwin, Apple Macintosh Mac OS X 
            and Cygwin. The best supported systems at the moment are Solaris, 
            Linux (Redhat in particular) and FreeBSD. Webmin is written in 
            Perl and Perl is universal like "C" and unlike "C" it is scripting 
            language. Perl is "cousin-brother" of "C" language. But major 
            drawback is that you need a X-Window system, Apache Webserver and 
            Perl installed and running before using Webmin. And here is where 
            Linuxconf fills the gap - you do not need X-Window and others to 
            run Linuxconf. Linuxconf can run even in dumb text-terminal 
            console with ncurses. The Webmin is at 
            <ulink url="
              http://www.webmin.com "> http://www.webmin.com 
            </ulink>
            . Go here and download the Webmin package. 
          </para>
        </listitem>
        <listitem>
          <para>
            Google directory 
            <ulink url="
              http://directory.google.com/Top/Computers/Software/Operating_Systems/Unix/Administration/ 
              "> 
              http://directory.google.com/Top/Computers/Software/Operating_Systems/Unix/Administration/ 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Here is a list of Redhat admin tools given below: 
            <programlisting format="linespecific">
	# ls /usr/sbin/redhat-con*
	/usr/sbin/redhat-config-bind           /usr/sbin/redhat-config-packages
	/usr/sbin/redhat-config-bind-gui       /usr/sbin/redhat-config-printer
	/usr/sbin/redhat-config-kickstart      /usr/sbin/redhat-config-printer-gui
	/usr/sbin/redhat-config-network        /usr/sbin/redhat-config-printer-tui
	/usr/sbin/redhat-config-network-cmd    /usr/sbin/redhat-config-proc
	/usr/sbin/redhat-config-network-druid  /usr/sbin/redhat-config-services
	
	To start the progam -
	# /usr/sbin/redhat-config-bind &amp;
	# /usr/sbin/redhat-config-network &amp;
	  
	And try other commands.
		</programlisting>
          </para>
        </listitem>
        <listitem>
          <para>
            The Visual Admin Tool, Samba tools and others 
            <ulink url="
              http://www.ibiblio.org/pub/Linux/system/admin/frontends/!INDEX.html 
              "> 
              http://www.ibiblio.org/pub/Linux/system/admin/frontends/!INDEX.html 
            </ulink>
            and 
            <ulink url="
              http://www.ibiblio.org/pub/Linux/system/admin/!INDEX.html "> 
              http://www.ibiblio.org/pub/Linux/system/admin/!INDEX.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            The System, Networking and Administration tools 
            <ulink url="
              http://gd.tuwien.ac.at/opsys/linux/applications/text1.html#sysad 
              "> 
              http://gd.tuwien.ac.at/opsys/linux/applications/text1.html#sysad 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Screen based admin tools from Linux Refresher : 
            <ulink url="
              http://linuxrefresher.com/maintenance/admgui/guiconf.htm "> 
              http://linuxrefresher.com/maintenance/admgui/guiconf.htm 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Suse has YAST admin tool, Redhat has /usr/sbin/redhat-conf* Other 
            tools : 
            <ulink url="
              http://freshmeat.net/browse/253/?topic_id=253 "> 
              http://freshmeat.net/browse/253/?topic_id=253 
            </ulink>
            <ulink url="
              http://freshmeat.net/browse/201/?topic_id=201 "> 
              http://freshmeat.net/browse/201/?topic_id=201 
            </ulink>
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      List of User Guides for Linux System Administration: 
      <itemizedlist>
        <listitem>
          <para>
            <ulink url="
              http://tldp.org/guides.html "> http://tldp.org/guides.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="
              http://tldp.org/LDP/lame/LAME/linux-admin-made-easy/index.html 
              "> 
              http://tldp.org/LDP/lame/LAME/linux-admin-made-easy/index.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="
              http://tldp.org/LDP/nag2/index.html "> 
              http://tldp.org/LDP/nag2/index.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Linux System Administration Tutorials: 
            <ulink url="
              http://www.yolinux.com/TUTORIALS/LinuxTutorialSysAdmin.html "> 
              http://www.yolinux.com/TUTORIALS/LinuxTutorialSysAdmin.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="
              http://www-106.ibm.com/developerworks/views/linux/tutorials.jsp 
              "> IBM Linux Tutorials 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="
              http://tariqnazir.tripod.com/unix.html "> 
              http://tariqnazir.tripod.com/unix.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="
              http://www.unixtools.com "> http://www.unixtools.com 
            </ulink>
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      System Administration Magazine: 
      <itemizedlist>
        <listitem>
          <para>
            <ulink url="
              http://www.samag.com/ "> http://www.samag.com/ 
            </ulink>
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      Educational courses on Linux System Administration: 
      <itemizedlist>
        <listitem>
          <para>
            Online India, Pune: 
            <ulink url="
              http://www.nixcraft.com/services/education/redhat/ "> 
              http://www.nixcraft.com/services/education/redhat/ 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Online UK : 
            <ulink url="
              http://www.firstalt.co.uk/courses/la2.html "> 
              http://www.firstalt.co.uk/courses/la2.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Online UK : 
            <ulink url="
              http://training.gbdirect.co.uk/courses/linux/running_linux_in_the_enterprise.html 
              "> 
              http://training.gbdirect.co.uk/courses/linux/running_linux_in_the_enterprise.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Online USA : 
            <ulink url="
              http://www.sgi.com/support/custeducation/courses/linux/sys_admin.html 
              "> 
              http://www.sgi.com/support/custeducation/courses/linux/sys_admin.html 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Online USA : 
            <ulink url="
              http://www.traininghott.com/Courses/Linux-System-Admin-Hands-On-Training-Course-Class-Seminar-NIS-DNS-DHCP-LILO.htm?source=findwhat_keyword=linux-admin-group 
              "> HOTT Training 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Google directory: 
            <ulink url="
              http://www.google.com/search?q=courses+Linux+system+admin+&amp;hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8 
              "> Google Linux System Admin education 
            </ulink>
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </sect1>
  <sect1 id="apt-get">
    <title>
      Install, Upgrade at Speed of Light With apt-get (Redhat, Debian, Suse, 
      Mandrake, Others) 
    </title>
    <para>
      You can automate the process of maintaining the Linux system with the 
      powerful tool like apt-get. The apt-get tool is immensely powerful and 
      used by millions of computers world-wide on Linux systems. The apt-get 
      utility works with Redhat Linux and Debian. The apt-get works with 
      distros which support RPM or Deb packages. The apt-get may work with 
      most of the distributions; if it does not you can very easily tailor the 
      code. Mandrake has tool called urpmi. 
      <itemizedlist>
        <listitem>
          <para>
            If you are using the Redhat Linux, download and get the apt-get 
            package from 
            <ulink url="http://apt.freshrpms.net">
              Apt for Redhat Linux 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Read more details about Apt for Redhat at - 
            <ulink url="http://freshrpms.net/apt">
              Apt for Redhat Linux 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Make sure you thoroughly read the documents of apt-get before 
            using it. See 
            <ulink url="http://www.debian.org/doc/ddp">
              Debian Docs 
            </ulink>
            and click on 
            <ulink url="http://www.debian.org/doc/user-manuals">
              User's Manuals 
            </ulink>
            and click on 
            <ulink url="http://www.debian.org/doc/user-manuals#apt-howto">
              APT HOWTO 
            </ulink>
            and click on your language 
            <ulink url="http://www.debian.org/doc/manuals/apt-howto/index.en.html">
              English: HTML 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://bazar.conectiva.com.br/~godoy/apt-howto">
              Apt+RPM howto 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://apt4rpm.sourceforge.net">
              APT for RPM Based Linux Distributions 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.debian.org/doc/manuals/apt-howto/ch-distros.en.html">
              List of Distributions which support APT 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            See also YUM tool at 
            <ulink url="http://www.linux.duke.edu/projects/yum">
              YUM - Yellowdog Updater, Modified 
            </ulink>
            . 
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      Want to know more about apt-get command ? Just see the help page on 
      apt-get by typing the following command at bash shell prompt: 
      <programlisting format="linespecific">
		$ apt-get -h  | more
			  
		apt 0.5.5cnc6 for linux i386 compiled on Jul 19 2003 21:23:24
		Usage: apt-get [options] command
			   apt-get [options] install|remove pkg1 [pkg2 ...]
			   apt-get [options] source pkg1 [pkg2 ...]
			  
		apt-get is a simple command line interface for downloading and
		installing packages. The most frequently used commands are update
		and install.
			  
		Commands:
		   update - Retrieve new lists of packages
		   upgrade - Perform an upgrade
		   install - Install new packages (pkg is libc6 not libc6.rpm)
		   remove - Remove packages
		   source - Download source archives
		   build-dep - Configure build-dependencies for source packages
		   dist-upgrade - Distribution upgrade, see apt-get(8)
		   clean - Erase downloaded archive files
		   autoclean - Erase old downloaded archive files
		   check - Verify that there are no broken dependencies
			  
		Options:
		  -h  This help text.
		  -q  Loggable output - no progress indicator
		  -qq No output except for errors
		  -d  Download only - do NOT install or unpack archives
		  -s  No-act. Perform ordering simulation
		  -y  Assume Yes to all queries and do not prompt
		  -f  Attempt to continue if the integrity check fails
		  -m  Attempt to continue if archives are unlocatable
		  -u  Show a list of upgraded packages as well
		  -b  Build the source package after fetching it
		  -D  When removing packages, remove dependencies as possible
		  -c=? Read this configuration file
		  -o=? Set an arbitary configuration option, eg -o dir::cache=/tmp
		See the apt-get(8), sources.list(5) and apt.conf(5) manual
		pages for more information and options.
							   This APT has Super Cow Powers.
	  </programlisting>
    </para>
    <para>
      You can see the online man pages on apt-get as given below: 
      <programlisting format="linespecific">
			man apt-get
	  In the bottom of manual page, look at "See Also" section
			man apt.conf
			man apt-cache
			man apt-cdrom
	  </programlisting>
    </para>
    <para>
      An example of usage of apt-get: 
      <programlisting format="linespecific">
			apt-get -f  upgrade postgresql-contrib
			apt-get  upgrade postgresql-contrib
			apt-get  install postgresql-contrib
			apt-get  install gaim
			apt-get dist-upgrade
		</programlisting>
    </para>
    <sect2 id="sourcecode_apt-get">
      <title>
        Source Code of 'apt-get' 
      </title>
      <para>
        You can download and recompile the apt-get source code for your 
        distro. Download source code of apt-get from 
        <ulink url="http://ftp.freshrpms.net/pub/freshrpms/redhat/9/apt">
          http://ftp.freshrpms.net/pub/freshrpms/redhat/9/apt 
        </ulink>
        . 
      </para>
    </sect2>
    <sect2 id="rpmfind_tool">
      <title>
        The 'rpmfind' Tool 
      </title>
      <para>
        Apart from apt-get you can also use rpmfind tool in redhat. The 
        rpmfind tool has some similarities with apt-get. Visit the rpmfind 
        site at : 
        <ulink url="http://rpmfind.net/linux/rpmfind">
          http://rpmfind.net/linux/rpmfind 
        </ulink>
        . The rpmfind is a utility that will find, install, autoupgrade RPM 
        files on rufus to your local computer. The main site of rpmfind 
        "search site" is 
        <ulink url="http://rpmfind.net">
          http://rpmfind.net 
        </ulink>
        . 
      </para>
    </sect2>
  </sect1>
  <sect1 id="linux_boot_process">
    <title>
      Advanced Topics - Linux Boot Process 
    </title>
    <para>
      This section may not be interesting for 'average Joe home PC user' but 
      will be more directed towards someone with computer science background. 
    </para>
    <para>
      The chain of events at boot are: CPU-> VGA-> Power-On-Self-Test-> SCSI-> 
      Boot Manager-> Lilo boot loader-> kernel-> init-> bash. The firmware and 
      software programs output various messages as the computer and Linux come 
      to life. 
    </para>
    <para>
      A guided tour of a Linux Boot process: 
      <orderedlist inheritnum="ignore" continuation="restarts">
        <listitem>
          <para>
            The Motherboard BIOS Triggers the Video Display Card BIOS 
            Initialization 
          </para>
        </listitem>
        <listitem>
          <para>
            Motherboard BIOS Initializes Itself 
          </para>
        </listitem>
        <listitem>
          <para>
            SCSI Controller BIOS Initializes 
          </para>
        </listitem>
        <listitem>
          <para>
            Hardware Summary: The motherboard BIOS then displays the following 
            summary of its hardware inventory. And runs its Virus checking 
            code that looks for changed boot sectors. 
          </para>
        </listitem>
        <listitem>
          <para>
            BootManager Menu : The Master Boot Record (MBR) on the first hard 
            disk is read, by DOS tradition, into address 0x00007c00, and the 
            processor starts executing instructions there. This MBR boot code 
            loads the first sector of code on the active DOS partition. 
          </para>
        </listitem>
        <listitem>
          <para>
            Lilo is started: If the Linux selection is chosen and if Linux has 
            been installed with Lilo, Lilo is loaded into address 0x00007c00. 
            Lilo prints LILO with its progress revealed by individually 
            printing the letters. The first "L" is printed after Lilo moves 
            itself to a better location at 0x0009A000. The "I" is printed just 
            before it starts its secondary boot loader code. Lilo's secondary 
            boot loader prints the next "L", loads descriptors pointing to 
            parts of the kernel, and then prints the final "O". The 
            descriptors are placed at 0x0009d200. The boot message and a 
            prompt line, if specified, are printed. The pressing "Tab" at the 
            prompt, allows the user to specify a system and to provide 
            command-line specifications to the Linux Kernel, its drivers, and 
            the "init" program. Also, environment variables may be defined at 
            this point. 
            <programlisting>
The following line is from /boot/message:
>
>
>
 Press  to list available boot image labels.
The following line is the prompt from /sbin/lilo:
boot:
Note: If Lilo is not used, then the boot code built into the head 
      of the Linux kernel, linux/arch/i386/boot/bootsect.S 
	  prints "Loading" and continues.
Lilo displays the following as it loads the kernel code. It gets the 
text "Linux-2.2.12" from the "label=..." specification in lilo.conf.
Loading linux-2.2.12..........
		  	</programlisting>
          </para>
        </listitem>
        <listitem>
          <para>
            The kernel code in /linux/arch/i386/boot/setup.S arranges the 
            transition from the processor running in real mode (DOS mode) to 
            protected mode (full 32-bit mode). Blocks of code named 
            Trampoline.S and Trampoline32.S help with the transition. Small 
            kernel images (zImage) are decompressed and loaded at 0x00010000. 
            Large kernel images (bzImage) are loaded instead at 0x00100000. 
            This code sets up the registers, decompresses the compressed 
            kernel (which has linux/arch/i386/head.S at its start), printing 
            the following 2 lines from linux/arch/i386/boot/compressed/misc.c 
            Uncompressing Linux... Ok. Booting the kernel. The i386-specific 
            setup.S code has now completed its job and it jumps to 0x00010000 
            (or 0x00100000) to start the generic Linux kernel code. 
            <itemizedlist>
              <listitem>
                <para>
                  Processor, Console, and Memory Initialization : This runs 
                  linux/arch/i386/head.S which in turn jumps to 
                  start_kernel(void) in linux/init/main.c where the interrupts 
                  are redefined. linux/kernel/module.c then loads the drivers 
                  for the console and pci bus. From this point on the kernel 
                  messages are also saved in memory and available using 
                  /bin/dmesg. They are then usually transferred to 
                  /var/log/message for a permanent record. 
                </para>
              </listitem>
              <listitem>
                <para>
                  PCI Bus Initialization : mpci_init() in linux/init/main.c 
                  causes the following lines from 
                  linux/arch/i386/kernel/bios32.c to be printed: 
                </para>
              </listitem>
              <listitem>
                <para>
                  Network Initialization: socket_init() in linux/init/main.c 
                  causes the following network initializations: 
                  <programlisting>
linux/net/socket.c prints:
Linux NET4.0 for Linux 2.2
Based upon Swansea University Computer Society NET3.039
linux/net/unix/af_unix.c prints:
NET4: Unix domain sockets 1.0 for Linux NET4.0.
linux/net/ipv4/af_inet.c prints:
NET4: Linux TCP/IP 1.0 for NET4.0
IP Protocols: ICMP, UDP, TCP
linux/net/ipv4/ip_gre.c prints:
GRE over IPv4 tunneling driver
linux/net/core/dev.c prints:
early initialization of device gre0 is deferred
linux/net/core/rtnetlink.c prints:
Initializing RT netlink socket
					</programlisting>
                </para>
              </listitem>
              <listitem>
                <para>
                  The Kernel Idle Thread (Process 0) is Started : At this 
                  point a kernel thread is started running init() which is one 
                  of the routines defined in linux/init/main.c. This init() 
                  must not be confused with the program /sbin/init that will 
                  be run after the Linux kernel is up and running. 
                  mkswapd_setup() in linux/init/main.c causes the following 
                  line from linux/mm/vmscan.c to be printed: Starting kswapd v 
                  1.5 
                </para>
              </listitem>
              <listitem>
                <para>
                  Device Driver Initialization : The kernel routine 
                  linux/arch/i386/kernel/setup.c then initializes devices and 
                  file systems (built into the kernel??). It produces the 
                  following lines and then forks to run /sbin/init: 
                  <itemizedlist>
                    <listitem>
                      <para>
                        Generic Parallel Port Initialization : The parallel 
                        port initialization routine 
                        linux/drivers/misc/parport_pc.c prints the following: 
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        Character Device Initializations : The following 3 
                        lines are from linux/drivers/char/serial.c: 
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        Block Device Initializations : 
                        linux/drivers/block/rd.c prints: RAM disk driver 
                        initialized: 16 RAM disks of 8192K size 
                        linux/drivers/block/loop.c prints: loop: registered 
                        device at major 7 linux/drivers/block/floppy.c prints: 
                        Floppy drive(s): fd0 is 1.44M, fd1 is 1.44M FDC 0 is a 
                        post-1991 82077 
                      </para>
                    </listitem>
                    <listitem>
                      <para>
                        SCSI Bus Initialization: The following lines are from 
                        aic7xxx.c, scsi.c, sg.c, sd.c or sr.c in the 
                        subdirectory linux/drivers/scsi: 
                      </para>
                    </listitem>
                  </itemizedlist>
                </para>
              </listitem>
              <listitem>
                <para>
                  Initialization of Kernel Support for Point-to-Point Protocol 
                  : The following initialization is done by 
                  linux/drivers/net/ppp.c. 
                </para>
              </listitem>
              <listitem>
                <para>
                  Examination of Fixed Disk Arrangement : The following lines 
                  are from linux/drivers/block/genhd.c: 
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </listitem>
        <listitem>
          <para>
            Init Program (Process 1) Startup : The program /sbin/init is 
            started by the "idle" process (Process 0) code in 
            linux/init/main.c and becomes process 1. /sbin/init then completes 
            the initialization by running scripts and forking additional 
            processes as specified in /etc/inittab. It starts by printing: 
            INIT: version 2.76 booting and reads /etc/inittab. 
          </para>
        </listitem>
        <listitem>
          <para>
            The Bash Shell is Started : The bash shell, /bin/bash is then 
            started up. Bash initialization begins by executing script in 
            /etc/profile which set the system-wide environment variables: 
          </para>
        </listitem>
      </orderedlist>
    </para>
    <sect2 id="bootprocess_urls">
      <title>
        References for Boot Process 
      </title>
      <para>
        Refer to following resources : 
        <itemizedlist>
          <listitem>
            <para>
              <ulink url="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/x1440.html">
                The Linux Boot Process 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/x88.html">
                Bootdisks and Boot Process 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://ourworld.compuserve.com/homepages/KanjiFlash/SGVLUG.htm">
                Linux Boot Process - by San Gabreil LUG 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.linuxnetmag.com/en/issue4/m4boot1.html">
                Boot Process (Netmag) 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://oldfield.wattle.id.au/luv/boot.html">
                Boot Process (LUG Victoria) 
              </ulink>
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
  </sect1>
  <sect1 id="other_formats">
    <title>
      Other Formats of this Document 
    </title>
    <para>
      This section is written by 
      <ulink url="mailto:alavoor[AT]yahoo.com">
        Al Dev 
      </ulink>
      (at site 
      <ulink url="http://milkyway.has.it">
        "http://milkyway.has.it" 
      </ulink>
      and 
      <ulink url="http://www.milkywaygalaxy.freeservers.com">
        "http://www.milkywaygalaxy.freeservers.com" 
      </ulink>
      mirrors at 
      <ulink url="http://www.angelfire.com/country/aldev0">
        angelfire 
      </ulink>
      , 
      <ulink url="http://www.geocities.com/alavoor/index.html">
        geocities 
      </ulink>
      , 
      <ulink url="http://aldev0.virtualave.net">
        virtualave 
      </ulink>
      , 
      <ulink url="http://members.fortunecity.com/aldev">
        Fortunecity 
      </ulink>
      , 
      <ulink url="http://aldev.freewebsites.com">
        Freewebsites 
      </ulink>
      , 
      <ulink url="http://members.tripod.lycos.com/aldev">
        Tripod 
      </ulink>
      , 
      <ulink url="http://www.101xs.com/101xs/aldev">
        101xs 
      </ulink>
      , 
      <ulink url="http://aldev0.50megs.com">
        50megs 
      </ulink>
      ) 
    </para>
    <para>
      This document is published in 14 different formats namely - DVI, 
      Postscript, Latex, Adobe Acrobat PDF, LyX, GNU-info, HTML, RTF(Rich Text 
      Format), Plain-text, Unix man pages, single HTML file, SGML (Linuxdoc 
      format), SGML (Docbook format), MS WinHelp format. 
    </para>
    <para>
      This howto document is located at - 
      <itemizedlist>
        <listitem>
          <para>
            <ulink url="http://www.linuxdoc.org">
              "http://www.linuxdoc.org" 
            </ulink>
            and click on HOWTOs and search for howto document name using 
            CTRL+f or ALT+f within the web-browser. 
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      You can also find this document at the following mirrors sites - 
      <itemizedlist>
        <listitem>
          <para>
            <ulink url="http://www.caldera.com/LDP/HOWTO">
              "http://www.caldera.com/LDP/HOWTO" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.linux.ucla.edu/LDP">
              "http://www.linux.ucla.edu/LDP" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.cc.gatech.edu/linux/LDP">
              "http://www.cc.gatech.edu/linux/LDP" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.redhat.com/mirrors/LDP">
              "http://www.redhat.com/mirrors/LDP" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Other mirror sites near you (network-address-wise) can be found at 
            <ulink url="http://www.linuxdoc.org/mirrors.html">
              "http://www.linuxdoc.org/mirrors.html" 
            </ulink>
            select a site and go to directory /LDP/HOWTO/xxxxx-HOWTO.html 
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      <itemizedlist>
        <listitem>
          <para>
            You can get this HOWTO document as a single file tar ball in HTML, 
            DVI, Postscript or SGML formats from - 
            <ulink url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO/other-formats/">
              "ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO/other-formats/" 
            </ulink>
            and 
            <ulink url="http://www.linuxdoc.org/docs.html#howto">
              "http://www.linuxdoc.org/docs.html#howto" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Plain text format is in: 
            <ulink url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO">
              "ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO" 
            </ulink>
            and 
            <ulink url="http://www.linuxdoc.org/docs.html#howto">
              "http://www.linuxdoc.org/docs.html#howto" 
            </ulink>
          </para>
        </listitem>
        <listitem>
          <para>
            Single HTML file format is in: 
            <ulink url="http://www.linuxdoc.org/docs.html#howto">
              "http://www.linuxdoc.org/docs.html#howto" 
            </ulink>
            Single HTML file can be created with command (see man sgml2html) - 
            sgml2html -split 0 xxxxhowto.sgml 
          </para>
        </listitem>
        <listitem>
          <para>
            Translations to other languages like French, German, Spanish, 
            Chinese, Japanese are in 
            <ulink url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO">
              "ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO" 
            </ulink>
            and 
            <ulink url="http://www.linuxdoc.org/docs.html#howto">
              "http://www.linuxdoc.org/docs.html#howto" 
            </ulink>
            Any help from you to translate to other languages is welcome. 
          </para>
        </listitem>
      </itemizedlist>
      The document is written using a tool called "SGML-Tools" which can be 
      got from - 
      <ulink url="http://www.sgmltools.org">
        "http://www.sgmltools.org" 
      </ulink>
      Compiling the source you will get the following commands like 
      <itemizedlist>
        <listitem>
          <para>
            sgml2html xxxxhowto.sgml (to generate html file) 
          </para>
        </listitem>
        <listitem>
          <para>
            sgml2html -split 0 xxxxhowto.sgml (to generate a single page html 
            file) 
          </para>
        </listitem>
        <listitem>
          <para>
            sgml2rtf xxxxhowto.sgml (to generate RTF file) 
          </para>
        </listitem>
        <listitem>
          <para>
            sgml2latex xxxxhowto.sgml (to generate latex file) 
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <sect2 id="acrobatpdf">
      <title>
        Acrobat PDF format 
      </title>
      <para>
        PDF file can be generated from postscript file using either acrobat 
        <emphasis remap="bf">
          distill 
        </emphasis>
        or 
        <emphasis remap="bf">
          Ghostscript 
        </emphasis>
        . And postscript file is generated from DVI which in turn is generated 
        from LaTex file. You can download distill software from 
        <ulink url="http://www.adobe.com">
          "http://www.adobe.com" 
        </ulink>
        . Given below is a sample session: 
        <programlisting format="linespecific">
	bash$ man sgml2latex
	bash$ sgml2latex filename.sgml
	bash$ man dvips
	bash$ dvips -o filename.ps filename.dvi
	bash$ distill filename.ps
	bash$ man ghostscript
	bash$ man ps2pdf
	bash$ ps2pdf input.ps output.pdf
	bash$ acroread output.pdf &amp;
        </programlisting>
        Or you can use Ghostscript command 
        <emphasis remap="bf">
          ps2pdf 
        </emphasis>
        . ps2pdf is a work-alike for nearly all the functionality of Adobe's 
        Acrobat Distiller product: it converts PostScript files to Portable 
        Document Format (PDF) files. 
        <emphasis remap="bf">
          ps2pdf 
        </emphasis>
        is implemented as a very small command script (batch file) that 
        invokes Ghostscript, selecting a special "output device" called 
        <emphasis remap="bf">
          pdfwrite 
        </emphasis>
        . In order to use ps2pdf, the pdfwrite device must be included in the 
        makefile when Ghostscript was compiled; see the documentation on 
        building Ghostscript for details. 
      </para>
    </sect2>
    <sect2 id="linuxdoc2docbook">
      <title>
        Convert Linuxdoc to Docbook format 
      </title>
      <para>
        This document is written in linuxdoc SGML format. The Docbook SGML 
        format supercedes the linuxdoc format and has lot more features than 
        linuxdoc. The linuxdoc is very simple and is easy to use. To convert 
        linuxdoc SGML file to Docbook SGML use the program 
        <emphasis remap="bf">
          ld2db.sh 
        </emphasis>
        and some perl scripts. The ld2db output is not 100[percnt] clean and 
        you need to use the 
        <emphasis remap="bf">
          clean_ld2db.pl 
        </emphasis>
        perl script. You may need to manually correct few lines in the 
        document. 
        <itemizedlist>
          <listitem>
            <para>
              Download ld2db program from 
              <ulink url="http://www.dcs.gla.ac.uk/~rrt/docbook.html">
                "http://www.dcs.gla.ac.uk/~rrt/docbook.html" 
              </ulink>
              or from 
              <ulink url="http://milkyway.has.it">
                "http://milkyway.has.it" 
              </ulink>
              and 
              <ulink url="http://www.milkywaygalaxy.freeservers.com">
                Milkyway Galaxy site 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              Download the cleanup_ld2db.pl perl script from from 
              <ulink url="http://milkyway.has.it">
                "http://milkyway.has.it" 
              </ulink>
              and 
              <ulink url="http://www.milkywaygalaxy.freeservers.com">
                Milkyway Galaxy site 
              </ulink>
            </para>
          </listitem>
        </itemizedlist>
        The ld2db.sh is not 100[percnt] clean, you will get lot of errors when 
        you run 
        <programlisting format="linespecific">
		bash$ ld2db.sh file-linuxdoc.sgml db.sgml
		bash$ cleanup.pl db.sgml &gt; db_clean.sgml
		bash$ gvim db_clean.sgml 
		bash$ docbook2html db.sgml
        </programlisting>
        And you may have to manually edit some of the minor errors after 
        running the perl script. For e.g. you may need to put closing tag &lt; 
        /Para&gt; for each &lt; Listitem&gt; 
      </para>
    </sect2>
    <sect2 id="mswinhelp">
      <title>
        Convert to MS WinHelp format 
      </title>
      <para>
        You can convert the SGML howto document to Microsoft Windows Help 
        file, first convert the sgml to html using: 
        <programlisting format="linespecific">
		bash$ sgml2html xxxxhowto.sgml     (to generate html file)
		bash$ sgml2html -split 0   xxxxhowto.sgml (to generate a single page html file)
        </programlisting>
        Then use the tool 
        <ulink url="http://javadocs.planetmirror.com/htmltohlpe.html">
          HtmlToHlp 
        </ulink>
        . You can also use sgml2rtf and then use the RTF files for generating 
        winhelp files. 
      </para>
    </sect2>
    <sect2 id="readformats">
      <title>
        Reading various formats 
      </title>
      <para>
        In order to view the document in dvi format, use the xdvi program. The 
        xdvi program is located in tetex-xdvi*.rpm package in Redhat Linux 
        which can be located through ControlPanel [verbar] Applications 
        [verbar] Publishing [verbar] TeX menu buttons. To read dvi document 
        give the command - 
        <screen format="linespecific">
          xdvi -geometry 80x90 howto.dvi man xdvi 
        </screen>
        And resize the window with mouse. To navigate use Arrow keys, Page Up, 
        Page Down keys, also you can use 'f', 'd', 'u', 'c', 'l', 'r', 'p', 
        'n' letter keys to move up, down, center, next page, previous page 
        etc. To turn off expert menu press 'x'. 
      </para>
      <para>
        You can read postscript file using the program 'gv' (ghostview) or 
        'ghostscript'. The ghostscript program is in ghostscript*.rpm package 
        and gv program is in gv*.rpm package in Redhat Linux which can be 
        located through ControlPanel [verbar] Applications [verbar] Graphics 
        menu buttons. The gv program is much more user friendly than 
        ghostscript. Also ghostscript and gv are available on other platforms 
        like OS/2, Windows 95 and NT, you view this document even on those 
        platforms. 
      </para>
      <para>
        <itemizedlist>
          <listitem>
            <para>
              Get ghostscript for Windows 95, OS/2, and for all OSes from 
              <ulink url="http://www.cs.wisc.edu/~ghost">
                "http://www.cs.wisc.edu/~ghost" 
              </ulink>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        To read postscript document give the command - 
        <screen format="linespecific">
          gv howto.ps ghostscript howto.ps 
        </screen>
      </para>
      <para>
        You can read HTML format document using Netscape Navigator, Microsoft 
        Internet explorer, Redhat Baron Web browser or any of the 10 other web 
        browsers. 
      </para>
      <para>
        You can read the latex, LyX output using LyX a X-Windows front end to 
        latex. 
      </para>
    </sect2>
  </sect1>
  <sect1 id="create_initrd">
    <title>
      Appendix A - Creating initrd.img file 
    </title>
    <para>
      The 
      <emphasis remap="bf">
        initrd 
      </emphasis>
      is the "initial ramdisk". It is enough files stored in a ramdisk to 
      store needed drivers . You need the drivers so that the kernel can mount 
      / and kick off init. The initrd is typically used for temporarily 
      booting the hardware into a state, that the real kernel vmlinuz can than 
      take over and continue the booting. For example - you can't read the 
      kernel off the scsi hard disk until you have a scsi driver loaded in the 
      kernel. (Solution: boot an initrd kernel that can read the real kernel 
      and use initrd to fix scsi booting problems) 
    </para>
    <para>
      You can avoid this file 'initrd.img' and eliminate the need of 
      'initrd.img', if you build your scsi drivers right into the kernel, 
      instead of into modules. (Many persons recommend this). 
    </para>
    <sect2>
      <title>
        Using mkinitrd 
      </title>
      <para>
        The mkinitrd utility creates an initrd image in a single command. This 
        is command is peculiar to RedHat. There may be equivalent command of 
        mkinitrd in other distributions of Linux. This is very convenient 
        utility. 
      </para>
      <para>
        You can read the mkinitrd man page. 
      </para>
      <para>
        <programlisting format="linespecific">
	/sbin/mkinitrd --help   # Or simply type 'mkinitrd --help'
	usage: mkinitrd [--version] [-v] [-f] [--preload &lt;module&gt;]
	       [--omit-scsi-modules] [--omit-raid-modules] [--omit-lvm-modules]
	       [--with=&lt;module&gt;] [--image-version] [--fstab=&lt;fstab&gt;] [--nocompress]
	       [--builtin=&lt;module&gt;] [--nopivot] &lt;initrd-image&gt; &lt;kernel-version&gt;
	       (example: mkinitrd /boot/initrd-2.2.5-15.img 2.2.5-15)
	# Read the online manual page with .....
	man mkinitrd
	su - root
	# The command below creates the initrd image file
	mkinitrd  ./initrd-2.4.18-19.8.0custom.img   2.4.18-19.8.0custom
	ls -l initrd-2.4.18-19.8.0custom.img
	-rw-r--r--    1 root     root       127314 Mar 19 21:54 initrd-2.4.18-19.8.0custom.img
	cp  ./initrd-2.4.18-19.8.0custom.img   /boot
        </programlisting>
      </para>
      <para>
        See the following sections for the manual method of creating an initrd 
        image. 
      </para>
    </sect2>
    <sect2>
      <title>
        Kernel Docs 
      </title>
      <para>
        To create /boot/initrd.img see the documentation at 
        /usr/src/linux/Documentation/initrd.txt and see also 
        <ulink url="http://www.tldp.org/HOWTO/mini/Loopback-Root-FS-3.html#ss3.3">
          Loopback-Root-mini-HOWTO 
        </ulink>
        . 
      </para>
    </sect2>
    <sect2>
      <title>
        Linuxman Book 
      </title>
      <para>
        A cut from 
        <ulink url="http://www.linuxman.com.cy/rute/node1.html">
          "http://www.linuxman.com.cy/rute/node1.html" 
        </ulink>
        chapter 31.7. 
      </para>
      <para>
        SCSI Installation Complications and initrd 
      </para>
      <para>
        Some of the following descriptions may be difficult to understand 
        without knowledge of kernel modules explained in Chapter 42. You may 
        want to come back to it later. 
      </para>
      <para>
        Consider a system with zero IDE disks and one SCSI disk containing a 
        LINUX installation. There are BIOS interrupts to read the SCSI disk, 
        just as there were for the IDE, so LILO can happily access a kernel 
        image somewhere inside the SCSI partition. However, the kernel is 
        going to be lost without a kernel module [lsqb ]See Chapter 42. The 
        kernel doesn't support every possible kind of hardware out there all 
        by itself. It is actually divided into a main part (the kernel image 
        discussed in this chapter) and hundreds of modules (loadable parts 
        that reside in /lib/modules/) that support the many type of SCSI, 
        network, sound etc., peripheral devices.] that understands the 
        particular SCSI driver. So although the kernel can load and execute, 
        it won't be able to mount its root file system without loading a SCSI 
        module first. But the module itself resides in the root file system in 
        /lib/modules/. This is a tricky situation to solve and is done in one 
        of two ways: either (a) using a kernel with preenabled SCSI support or 
        (b) using what is known as an initrd preliminary root file system 
        image. 
      </para>
      <para>
        The first method is what I recommend. It's a straightforward (though 
        time-consuming) procedure to create a kernel with SCSI support for 
        your SCSI card built-in (and not in a separate module). Built-in SCSI 
        and network drivers will also autodetect cards most of the time, 
        allowing immediate access to the device--they will work without being 
        given any options [lsqb ]Discussed in Chapter 42.] and, most 
        importantly, without your having to read up on how to configure them. 
        This setup is known as compiled-in support for a hardware driver (as 
        opposed to module support for the driver). The resulting kernel image 
        will be larger by an amount equal to the size of module. Chapter 42 
        discusses such kernel compiles. 
      </para>
      <para>
        The second method is faster but trickier. LINUX supports what is known 
        as an initrd image ( initial rAM disk image). This is a small, +1.5 
        megabyte file system that is loaded by LILO and mounted by the kernel 
        instead of the real file system. The kernel mounts this file system as 
        a RAM disk, executes the file /linuxrc, and then only mounts the real 
        file system. 
      </para>
      <para>
        31.6 Creating an initrd Image 
      </para>
      <para>
        Start by creating a small file system. Make a directory [nbsp ]/initrd 
        and copy the following files into it. 
      </para>
      <para>
        <programlisting format="linespecific">
	drwxr-xr-x    7 root     root         1024 Sep 14 20:12 initrd/
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/bin/
	-rwxr-xr-x    1 root     root       436328 Sep 14 20:12 initrd/bin/insmod
	-rwxr-xr-x    1 root     root       424680 Sep 14 20:12 initrd/bin/sash
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/dev/
	crw-r--r--    1 root     root       5,   1 Sep 14 20:12 initrd/dev/console
	crw-r--r--    1 root     root       1,   3 Sep 14 20:12 initrd/dev/null
	brw-r--r--    1 root     root       1,   1 Sep 14 20:12 initrd/dev/ram
	crw-r--r--    1 root     root       4,   0 Sep 14 20:12 initrd/dev/systty
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty1
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty2
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty3
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty4
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/etc/
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/lib/
	-rwxr-xr-x    1 root     root           76 Sep 14 20:12 initrd/linuxrc
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/loopfs/
        </programlisting>
      </para>
      <para>
        On my system, the file initrd/bin/insmod is the statically linked 
        [lsqb ]meaning it does not require shared libraries.] version copied 
        from /sbin/insmod.static--a member of the modutils-2.3.13 package. 
        initrd/bin/sash is a statically linked shell from the sash-3.4 
        package. You can recompile insmod from source if you don't have a 
        statically linked version. Alternatively, copy the needed DLLs from 
        /lib/ to initrd/lib/. (You can get the list of required DLLs by 
        running ldd /sbin/insmod. Don't forget to also copy symlinks and run 
        strip -s {lib} to reduce the size of the DLLs.) 
      </para>
      <para>
        Now copy into the initrd/lib/ directory the SCSI modules you require. 
        For example, if we have an Adaptec AIC-7850 SCSI adapter, we would 
        require the aic7xxx.o module from 
        /lib/modules/{version}/scsi/aic7xxx.o. Then, place it in the 
        initrd/lib/ directory. 
      </para>
      <para>
        <programlisting format="linespecific">
	-rw-r--r--    1 root     root       129448 Sep 27  1999 initrd/lib/aic7xxx.o
        </programlisting>
      </para>
      <para>
        The file initrd/linuxrc should contain a script to load all the 
        modules needed for the kernel to access the SCSI partition. In this 
        case, just the aic7xxx module [lsqb ] insmod can take options such as 
        the IRQ and IO-port for the device. See Chapter 42.]: 
      </para>
      <para>
        <programlisting format="linespecific">
	#!/bin/sash
	 
	aliasall
	 
	echo "Loading aic7xxx module"
	insmod /lib/aic7xxx.o 
        </programlisting>
      </para>
      <para>
        Now double-check all your permissions and then chroot to the file 
        system for testing. 
      </para>
      <para>
        <programlisting format="linespecific">
	chroot ~/initrd /bin/sash
	/linuxrc
        </programlisting>
      </para>
      <para>
        Now, create a file system image similar to that in Section 19.9: 
        <programlisting format="linespecific">
	dd if=/dev/zero of=~/file-inird count=2500 bs=1024
	losetup /dev/loop0 ~/file-inird
	mke2fs /dev/loop0
	mkdir ~/mnt
	mount /dev/loop0 ~/mnt
	cp -a initrd/* ~/mnt/
	umount ~/mnt
	losetup -d /dev/loop0
        </programlisting>
      </para>
      <para>
        Finally, gzip the file system to an appropriately named file: 
        <programlisting format="linespecific">
	gzip -c ~/file-inird &gt; initrd-&lt;kernel-version&gt;
        </programlisting>
      </para>
      <para>
        31.7 Modifying lilo.conf for initrd 
      </para>
      <para>
        Your lilo.conf file can be changed slightly to force use of an initrd 
        file system. Simply add the initrd option. For example: 
      </para>
      <para>
        <programlisting format="linespecific">
	boot=/dev/sda
	prompt
	timeout = 50
	compact
	vga = extended
	linear
	image = /boot/vmlinuz-2.2.17
	        initrd = /boot/initrd-2.2.17
	        label = linux
	        root = /dev/sda1
	        read-only
        </programlisting>
      </para>
      <para>
        Notice the use of the linear option. This is a BIOS trick that you can 
        read about in lilo(5). It is often necessary but can make SCSI disks 
        nonportable to different BIOSs (meaning that you will have to rerun 
        lilo if you move the disk to a different computer). 
      </para>
    </sect2>
  </sect1>
  <sect1 id="liloconf">
    <title>
      Appendix B - Sample lilo.conf 
    </title>
    <sect2>
      <title>
        Resources on LILO 
      </title>
      <para>
        See also following documents: 
        <itemizedlist>
          <listitem>
            <para>
              <ulink url="http://www.tldp.org/HOWTO/mini/LILO.html">
                http://www.tldp.org/HOWTO/mini/LILO.html 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              See the documentation of Lilo on your Linux system : 
              <programlisting format="linespecific">
	# Use the kghostview, ghostview or gv command 
	kghostview /usr/share/doc/lilo-21.4.4/doc/user.ps
	  
	# To read in HTML format do this -
	mkdir $HOME/lilodocs
	cd $HOME/lilodocs
	cp /usr/share/doc/lilo-21.4.4/doc/user.tex  .
	latex2html user
	  
	# This creates the html files in user directory
      		</programlisting>
            </para>
          </listitem>
          <listitem>
            <para>
              <xref linkend="grubconf"/>
              GRUB Conf file. 
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.linuxdoc.org/HOWTO/LILO-crash-rescue-HOWTO.html">
                "http://www.linuxdoc.org/HOWTO/LILO-crash-rescue-HOWTO.html" 
              </ulink>
              . 
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
    <sect2>
      <title>
        Troubleshooting LILO 
      </title>
      <para>
        The beeper error codes : 
        <table frame="all">
          <title>
            Beeper Error Codes Table 
          </title>
          <tgroup cols='2' align='left' colsep='1' rowsep='1'>
            <colspec colname="c1"/>
            <colspec colname="c2"/>
            <thead>
              <row>
                <entry>
                  Code 
                </entry>
                <entry>
                  Description 
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  0 
                </entry>
                <entry>
                  PC-Speaker Defect 
                </entry>
              </row>
              <row>
                <entry>
                  1 
                </entry>
                <entry>
                  Refresh of DRAM defect 
                </entry>
              </row>
              <row>
                <entry>
                  2 
                </entry>
                <entry>
                  Paritykring defect 
                </entry>
              </row>
              <row>
                <entry>
                  3 
                </entry>
                <entry>
                  Error in the 64 basis RAM 
                </entry>
              </row>
              <row>
                <entry>
                  4 
                </entry>
                <entry>
                  Systeemtimer defect 
                </entry>
              </row>
              <row>
                <entry>
                  5 
                </entry>
                <entry>
                  Processor defect 
                </entry>
              </row>
              <row>
                <entry>
                  6 
                </entry>
                <entry>
                  Keyboard controller error 
                </entry>
              </row>
              <row>
                <entry>
                  7 
                </entry>
                <entry>
                  Virtuele modus error 
                </entry>
              </row>
              <row>
                <entry>
                  8 
                </entry>
                <entry>
                  Test from videomemory failed 
                </entry>
              </row>
              <row>
                <entry>
                  9 
                </entry>
                <entry>
                  ROM-BIOS checksumm error 
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </para>
      <para>
        2 short beeps : POST not correct. Error in a Harware test. 1 short 
        &amp; 2 long beeps : video error. 1) Video ROM BIOS, parity error. 2) 
        Problem with the horizontal retour from the video adapter. 1 long 
        &amp; 3 short beeps: video error. 1) videocard defect. 2) wrong 
        detection from used monitor. 3) Video RAM error. 1 long beep : POST 
        was correct If there is a posterror, there is a hardwareproblem. Check 
        the extentioncards for a bad contact 
      </para>
      <para>
        See also 
        <ulink url="http://www.preggers.easynet.be/lilo.html">
          http://www.preggers.easynet.be/lilo.html 
        </ulink>
      </para>
      <para>
        If you get problems in LILO, refer to following tips. During boot if 
        you get error "L0101010101010101 ....", then do this 
        <itemizedlist>
          <listitem>
            <para>
              Use your favorite text editor to open /etc/lilo.conf 
              <programlisting format="linespecific">
# Find the line that reads
linear
# Comment it out. Change it to read
# linear
Save and rerun lilo.
      </programlisting>
            </para>
          </listitem>
          <listitem>
            <para>
              You need to have your booting partion below the 8 gb mark. If 
              you have a program like parition magic or Mandrake's DiskDrake 
              utility you can easily fix this. 
            </para>
          </listitem>
          <listitem>
            <para>
              01 is dram refresh error. When you get the L 01 simply reboot 
              again with CTRL+ATL+DEL (but you should not power off just do 
              ctrl+alt+del). This may correct the problem. 
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </sect2>
    <sect2>
      <title>
        Sample on LILO 
      </title>
      <para>
        Always give a date extension to the filename, because it tells you 
        when you built the kernel, as shown below: 
        <programlisting format="linespecific">
	bash# man lilo
	bash# man lilo.conf
	And edit /etc/lilo.conf file and put these lines - 
		image=/boot/bzImage.myker.26mar2001 
		label=myker
		root=/dev/hda1 
		read-only 
	You can check device name for 'root=' with the command - 
		bash# df   / 
	Now give -
		bash# lilo 
		bash# lilo -q 
      </programlisting>
        You must re-run lilo even if the entry 'myker' exists, everytime you 
        create a new bzImage. 
      </para>
      <para>
        Given below is a sample /etc/lilo.conf file. You should follow the 
        naming conventions like ker2217 (for kernel 2.2.17), ker2214 (for 
        kernel 2.2.14). You can have many kernel images on the same /boot 
        system. On my machine I have something like: 
        <programlisting format="linespecific">
	boot=/dev/hda
	map=/boot/map
	install=/boot/boot.b
	prompt
	timeout=50
	default=firewall
	image=/boot/vmlinuz-2.2.14-5.0
		label=ker2214
		read-only
		root=/dev/hda9
	image=/boot/vmlinuz-2.2.17-14
		label=ker2217
		read-only
		root=/dev/hda9
	#image=/usr/src/linux/arch/i386/boot/bzImage 
	#	label=myker 
	#	root=/dev/hda7
	#	read-only 
	image=/boot/bzImage.myker.11feb2001
		label=myker11feb 
		root=/dev/hda9
		read-only 
	image=/boot/bzImage.myker.01jan2001
		label=myker01jan 
		root=/dev/hda9
		read-only 
	image=/boot/bzImage.myker-firewall.16mar2001
		label=firewall 
		root=/dev/hda9
		read-only 
      </programlisting>
      </para>
    </sect2>
  </sect1>
  <sect1 id="grubconf">
    <title>
      Appendix C - GRUB Details And A Sample grub.conf 
    </title>
    <sect2>
      <title>
        References on GRUB 
      </title>
      <para>
        See 
        <itemizedlist>
          <listitem>
            <para>
              <ulink url="http://www.tldp.org/HOWTO/Linux+Win9x+Grub-HOWTO/intro.html">
                "http://www.tldp.org/HOWTO/Linux+Win9x+Grub-HOWTO/intro.html" 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              GNU GRUB 
              <ulink url="http://www.gnu.org/software/grub">
                "http://www.gnu.org/software/grub" 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/ch-grub.html">
                Redhat Manual 
              </ulink>
              . 
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.tldp.org/HOWTO/mini/Multiboot-with-GRUB.html">
                Multiboot-with-GRUB minihowto 
              </ulink>
            </para>
          </listitem>
          <listitem>
            <para>
              <ulink url="http://www.mcc.ac.uk/grub/grub_toc.html">
                Grub Manual 
              </ulink>
            </para>
          </listitem>
        </itemizedlist>
        <programlisting format="linespecific">
	bash# man grub
	bash# man grubby   # (command line tool for configuring grub, lilo, and elilo)
	bash# man grub-install
      </programlisting>
        Edit the file /etc/grub.conf to make entries for the new kernel. See 
        the sample file below: 
      </para>
    </sect2>
    <sect2>
      <title>
        Tips On GRUB 
      </title>
      <para>
        In Redhat Linux, during grub display, just type c for command-line 
        option of GRUB: 
        <programlisting format="linespecific">
	To boot Linux do this:
    grub&gt; help
	  
    grub&gt; root
        (hd1,1): Filesystem is type ext2fs, partition type 0x83
    grub&gt; root (hd1,0)
	  
    grub&gt; kernel / &lt;Press-TAB-KEY&gt;
    This will list all files
	  
    grub&gt; kernel /boot &lt;Press-TAB-KEY&gt;
    This will list all files in /boot
	  
    grub&gt; kernel /boot/vmlinuz
	  
    grub&gt; boot
      </programlisting>
      </para>
      <para>
        See also the 
        <ulink url="http://www.gnu.org/manual/grub/html_mono/grub.html">
          GRUB Manual 
        </ulink>
        . To boot MS Windows 95/2000 etc do this: If you want to boot an 
        unsupported operating system (e.g. Windows 95), chain-load a boot 
        loader for the operating system. Normally, the boot loader is embedded 
        in the boot sector of the partition on which the operating system is 
        installed. 
        <programlisting format="linespecific">
	grub&gt; help
	grub&gt; help rootnoverify
	grub&gt; rootnoverify (hd0,0)
	grub&gt; makeactive
	grub&gt; chainloader +1
	grub&gt; boot
      </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        Sample GRUB Conf File 
      </title>
      <para>
        <programlisting format="linespecific">
	# grub.conf generated by anaconda
	#
	# Note that you do not have to rerun grub after making changes to this file
	# NOTICE:  You do not have a /boot partition.  This means that
	#          all kernel and initrd paths are relative to /, eg.
	#          root (hd0,8)
	#          kernel /boot/vmlinuz-version ro root=/dev/hda9
	#          initrd /boot/initrd-version.img
	#boot=/dev/hda
	# By default boot the second entry
	default=1
	# Fallback to the first entry.
	fallback 0
	# Boot automatically after 2 minutes
	timeout=120
	splashimage=(hd0,8)/boot/grub/splash.xpm.gz
	title Windows 2000 
	unhide (hd0,0)
	hide (hd0,1)
	hide (hd0,2)
	rootnoverify (hd0,0)
	chainloader +1
	makeactive
	title Red Hat Linux (2.4.18-19.8.0.19mar2003)
		root (hd0,8)
		kernel /boot/bzImage.2.4.18-19.8.0.19mar2003 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0custom.img.19mar03
	title Red Hat Linux (2.4.18-19.8.0custom)
		root (hd0,8)
		kernel /boot/vmlinuz-2.4.18-19.8.0custom ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0custom.img
	title Red Hat Linux (2.4.18-14)
		root (hd0,8)
		kernel /boot/vmlinuz-2.4.18-14 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-14.img
	title MyKernel.26jan03 (Red Hat Linux 2.4.18-14)
		root (hd0,8)
		kernel /boot/bzImage.myker.26jan03 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0.img
	title Windows 98
	hide (hd0,0)
	hide (hd0,1)
	unhide (hd0,2)
	rootnoverify (hd0,2)
	chainloader +1
	makeactive
	title DOS 6.22
	hide (hd0,0)
	unhide (hd0,1)
	hide (hd0,2)
	rootnoverify (hd0,1)
	chainloader +1
	makeactive
	title Partition 2 (floppy)
	hide (hd0,0)
	unhide (hd0,1)
	hide (hd0,2)
	chainloader (fd0)+1
	title Partition 3 (floppy)
	hide (hd0,0)
	hide (hd0,1)
	unhide (hd0,2)
	chainloader (fd0)+1
      </programlisting>
      </para>
    </sect2>
  </sect1>
  <sect1 id="post_kernel_building">
    <title>
      Appendix D - Post Kernel Building 
    </title>
    <para>
      After successfully building and booting the Linux kernel, you may be 
      required to do these additional steps to make some of the devices to 
      work with Linux. (The steps below were tested on Redhat Linux but should 
      work with other distributions as well.) 
    </para>
    <para>
      <emphasis remap="bf">
        Video card/Monitor configuration: 
      </emphasis>
      <itemizedlist>
        <listitem>
          <para>
            Please see the video card manual which is usually shipped with the 
            PC. You should look for a "Technical Specifications" page. 
          </para>
        </listitem>
        <listitem>
          <para>
            Please see the monitor's manual and look for a "Technical 
            Specifications" page. 
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      If you are using latest version of Linux (2.4 or later) and inside 
      KDE/GNOME desktop click on Start-&gt;"System Settings"-&gt;Display. 
    </para>
    <para>
      For older versions of Linux follow the steps below: 
    </para>
    <para>
      You can configure the Video card and monitor by using these commands: 
      <programlisting format="linespecific">
	bash$ su - root
	bash# man Xconfigurator
	bash# /usr/bin/X11/Xconfigurator --help
	bash# /usr/bin/X11/Xconfigurator 
	bash# /usr/bin/X11/Xconfigurator --expert
	See also:
	bash# man xf86config
	bash# /usr/bin/X11/xf86config
      </programlisting>
      If your card is not detected automatically, then you can use the 
      --expert option and select the "Unlisted card". If your monitor is not 
      listed then select the generic monitor type SVGA 1024x768. 
    </para>
    <para>
      <emphasis remap="bf">
        Sound card configuration: 
      </emphasis>
      <itemizedlist>
        <listitem>
          <para>
            Connect your external speakers to the sound card's audio port. 
          </para>
        </listitem>
        <listitem>
          <para>
            Connect your CDROM audio wire to sound card's audio 4-pin socket. 
            (Otherwise your cdrom drive will not play the music from your 
            music cd) 
          </para>
        </listitem>
        <listitem>
          <para>
            Refer to HOWTO docs on 'Sound' at 
            <ulink url="http://www.linuxdoc.org">
              "http://www.linuxdoc.org" 
            </ulink>
          </para>
        </listitem>
      </itemizedlist>
      If you are using latest version of Linux (2.4 or later) and inside 
      KDE/GNOME desktop click on Start-&gt;"System Settings"-&gt;Soundcard 
      Detection. 
    </para>
    <para>
      For older versions of Linux follow the steps below: 
    </para>
    <para>
      <programlisting format="linespecific">
	bash$ su - root
	bash# man sndconfig
	bash# /usr/sbin/sndconfig
      </programlisting>
      Then start X-window 'KDE desktop' with 'startx' command. Click on 'K 
      Start-&gt;ControlCenter-&gt;SoundServer-&gt;General-&gt;Test Sound'. 
      This should play the test sound. Then click on 'K 
      Start-&gt;MultiMedia-&gt;SoundMixer-&gt;SoundVolumeSlider' and adjust 
      the sound volume. 
    </para>
    <para>
      <emphasis remap="bf">
        Network card configuration: 
      </emphasis>
      If you are using latest version of Linux (2.4 or later) and inside 
      KDE/GNOME desktop click on Start-&gt;"System Settings"-&gt;Network. 
    </para>
    <para>
      For older versions of Linux follow the steps below: 
    </para>
    <para>
      <itemizedlist>
        <listitem>
          <para>
            Use /sbin/linuxconf 
          </para>
        </listitem>
        <listitem>
          <para>
            Or use KDE control panel 
          </para>
        </listitem>
        <listitem>
          <para>
            Refer to HOWTO docs on 'Networking' at 
            <ulink url="http://www.linuxdoc.org">
              "http://www.linuxdoc.org" 
            </ulink>
          </para>
        </listitem>
      </itemizedlist>
    </para>
    <para>
      <emphasis remap="bf">
        Configure Firewall and IP Masquerading : 
      </emphasis>
      For Linux kernel version 2.4 and above, the firewall and IP Masquerading 
      is implemented by NetFilter package. Hence in kernel config you should 
      enable Netfilter and run the Firewall/IPMasq script. Download the 
      scripts from 
      <ulink url="http://www.BoingWorld.com/workshops/linux/iptables-tutorial">
        Firewall-IPMasq scripts 
      </ulink>
      , main page of Netfilter is at 
      <ulink url="http://netfilter.samba.org">
        "http://netfilter.samba.org" 
      </ulink>
      . Related materials at 
      <ulink url="http://www.linuxsecurity.com/feature_stories/kernel-netfilter.html">
        firewalling-matures 
      </ulink>
      and 
      <ulink url="http://netfilter.filewatcher.org/netfilter-faq.html">
        Netfilter-FAQ 
      </ulink>
      . 
    </para>
    <para>
      For kernel version below 2.4 you should install the firewall rpms from 
      <ulink url="http://rpmfind.net/linux/rpm2html/search.php?query=firewall">
        rpmfind.net 
      </ulink>
      or 
      <ulink url="http://rpmfind.net/linux/RPM/contrib/noarch//SRPMS//firewall-2.2-3.src.html">
        firewall.src.rpm 
      </ulink>
      . 
    </para>
    <para>
      <emphasis remap="bf">
        Configuration of other devices: 
      </emphasis>
      Refer to HOWTO docs relating to your devices at 
      <ulink url="http://www.linuxdoc.org">
        "http://www.linuxdoc.org" 
      </ulink>
    </para>
  </sect1>
  <sect1 id="troubleshoot">
    <title>
      Appendix E - Troubleshoot Common Mistakes 
    </title>
    <sect2>
      <title>
        Kernel Compiles OK but make modules fail 
      </title>
      <para>
        Sympton: The kernel compiles ok producing bzImage but 'make modules' 
        fails. 
      </para>
      <para>
        Solution: This problem is most tricky - there can be many subtle 
        reasons. May be related to Linux distro or dependencies of packages 
        are not uptodate. This one is very peculiar of Redhat distribution but 
        may happen to other distributions. There are some "left over" files 
        which are hanging and causing problems. The remedy is to do 'make 
        mrproper' and 'make clean' and then do 'make modules'. But you may 
        want to copy the saved config file as shown below: 
        <programlisting format="linespecific">
bash# cd /usr/src/linux 
bash# mkdir /usr/src/kernelconfigs ;
bash# cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save;
bash# cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # ExtraSafe
bash# cp /boot/config*  /usr/src/linux/configs/  # ExtraSafe
bash# make clean
bash# make mrproper  # "MUST DO THIS mrproper", otherwise you will face hell lot of problems !!
bash# make clean
bash# cp /usr/src/kernelconfigs/.config.save .config  # In case you want to reuse the config file ??
	  	</programlisting>
      </para>
      <sect3>
        <title>
          Wrong Config File Copied 
        </title>
        <para>
          If the 'make mrproper' in above section does not fix this problem, 
          then you are trapped by some other subtle problems. May be something 
          is seriously wrong with config file. You might have started with a 
          wrong CPU config file - you might have chosen ATHLON CPU type for 
          your Pentium machine or Cyrix CPU for your Athlon machine. Start all 
          over again, if you have Athlon CPU then copy the athlon.config or if 
          you have Intel 686 CPU then copy the i686.config file. Copy from the 
          default vanilla config file from /usr/src/linux/configs 
          <programlisting format="linespecific">
	bash# cp /usr/src/linux/configs/kernel-2.4.18-i686.config  /usr/src/linux/.config
	Or for athlon processors
	bash# cp /usr/src/linux/configs/kernel-2.4.18-athlon.config  /usr/src/linux/.config
			  </programlisting>
          Now follow instructions in "Quick Steps" chapter at 
          <xref linkend="quick_steps"/>
          . 
        </para>
      </sect3>
      <sect3>
        <title>
          Packages Not In Sync 
        </title>
        <para>
          Still having problems? If above section does not fix the problems, 
          then you are trapped by some other subtle problems. Are you sure you 
          have all the dependencies of packages taken care of ?? Are all the 
          dependent packages in sync with each other? Did you install any 
          package with "--nodeps" option? You should automate the dependencies 
          with powerful tool like apt-get ( See the section "Install, Update 
          at Speed of Light" in 
          <xref linkend="apt-get"/>
          ). Manually trying to sync up hundreds of libraries and packages is 
          a heck of a work, use apt-get . Refer to the section "Install, 
          Update at Speed of Light" in 
          <xref linkend="apt-get"/>
          ). 
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>
        Compiles OK but does not boot 
      </title>
      <para>
        Sympton: If the kernel compiles ok but booting never works and it 
        always complains with a kernel panic about /sbin/modprobe. 
      </para>
      <para>
        Solution: You did not create initrd image file. See the Appendix A at 
        <xref linkend="create_initrd"/>
        . 
      </para>
      <para>
        Also, you must do 'make modules' and 'make modules_install' in 
        addition to creating the initrd image file. Even if you had run 'make 
        modules' before, try running again for the second time (does not 
        hurt). Give 'make modules' and 'make modules_install' once again to 
        make sure for certain that all the loadable modules are put in place. 
      </para>
    </sect2>
    <sect2>
      <title>
        The System Hangs at LILO 
      </title>
      <para>
        <emphasis remap="bf">
          Sympton: 
        </emphasis>
        After you build the kernel and reboot, the system hangs just before 
        LILO. 
      </para>
      <para>
        <emphasis remap="bf">
          Reason: 
        </emphasis>
        Probably you did not set the BIOS to pick up the proper Primary Master 
        IDE and Secondary Slave IDE hard disk partition. 
      </para>
      <para>
        <emphasis remap="bf">
          Solution: 
        </emphasis>
        Power on the machine and press DEL key to do setup of the BIOS (Basic 
        Input Output system). Select the IDE settings and set proper primary 
        hard disk partition and slave drives. When the system boots it looks 
        for the primary IDE hard disk and the Master Boot Record partition. It 
        reads the MBR and starts loading the Linux Kernel from the hard disk 
        partition. 
      </para>
    </sect2>
    <sect2>
      <title>
        No init found 
      </title>
      <para>
        The following mistake is commited very frequently by new users. 
      </para>
      <para>
        If your new kernel does not boot and you get - 
        <programlisting format="linespecific">
	Warning: unable to open an initial console
	Kernel panic: no init found. Try passing init= option to kernel
        </programlisting>
        The problem is that you 
        <emphasis remap="bf">
          did not 
        </emphasis>
        set the "root=" parameter properly in the /etc/lilo.conf. In my case, 
        I used root=/dev/hda1 which is having the root partition "/". You must 
        properly point the root device in your lilo.conf, it can be like 
        /dev/hdb2 or /dev/hda7. 
      </para>
      <para>
        There may be errors just before this Kernel panic. Look for and read 
        any error messages just above the like 'Kernel panic:'. The failure 
        may be due to any error messages just before this one (it is 
        cummulative effect). For example, before the 'Kernel panic' error you 
        might have got error like 'kernel-module version mismatch' or 
        'something-else-some-other-error-message'. Try to correct the FIRST 
        error reported by the system. 
      </para>
      <para>
        The kernel looks for the init command which is located in /sbin/init. 
        And /sbin directory lives on the root partition. For details see - 
        <programlisting format="linespecific">
	bash# man init
        </programlisting>
        See the 
        <xref linkend="grubconf"/>
        file and see the 
        <xref linkend="liloconf"/>
        . 
      </para>
    </sect2>
    <sect2>
      <title>
        Lot of Compile Errors 
      </title>
      <para>
        The 'make', 'make bzImage', 'make modules' or 'make modules_install' 
        gives compile problems. You should give 'make mrproper' before doing 
        make. 
        <programlisting format="linespecific">
	bash# make clean &amp;&amp; make mrproper # "MUST DO THIS mrproper", otherwise you will face hell lot of problems !!
        </programlisting>
        If this problem persists, then try menuconfig instead of xconfig. 
        Sometimes GUI version xconfig causes some problems: 
        <programlisting format="linespecific">
	bash# export TERM=VT100
	bash# make menuconfig  # Newer, uses ncurses/curses, may fail if not installed
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        The 'depmod' gives "Unresolved symbol error messages" 
      </title>
      <para>
        When you run 
        <literal moreinfo="none" remap="tt">
          depmod 
        </literal>
        it gives "Unresolved symbols". A sample error message is given here to 
        demonstrate the case: 
        <programlisting format="linespecific">
	bash$ su - root
	bash# man depmod
	bash# depmod
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/linear.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/multipath.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid0.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid1.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid5.o
        </programlisting>
      </para>
      <para>
        <emphasis remap="bf">
          Reason: 
        </emphasis>
        You did not make modules and install the modules after building the 
        new kernel with 
        <literal moreinfo="none" remap="tt">
          "make bzImage" 
        </literal>
        . 
      </para>
      <para>
        <emphasis remap="bf">
          Solution: 
        </emphasis>
        After you build the new kernel, you must do: 
        <programlisting format="linespecific">
	bash$ su - root
	bash# cd /usr/src/linux
	bash# make modules
	bash# make modules_install
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        Kernel Does Not Load Module - "Unresolved symbols" Error Messages 
      </title>
      <para>
        When you boot kernel and system tries to load any modules and you get 
        "Unresolved symbol : __some_function_name" then it means that you did 
        not clean compile the modules and kernel. It is mandatory that you 
        should do 
        <emphasis remap="bf">
          make clean 
        </emphasis>
        and make the modules. Do this - 
        <programlisting format="linespecific">
		bash# cd /usr/src/linux
		bash# make dep
		bash# make clean
		bash# make mrproper  # "MUST DO THIS mrproper", otherwise you will face hell lot of problems !!
		bash# make clean
		bash# nohup make bzImage &amp;  
		bash# tail -f nohup.out     (.... to monitor the progress) 
		bash# make modules
		bash# make modules_install
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        Kernel fails to load a module 
      </title>
      <para>
        If the kernel fails to load a module (say loadable module for network 
        card or other devices), then you may want to try to build the driver 
        for device right into the kernel. Sometimes 
        <emphasis remap="it">
          <emphasis remap="bf">
            loadable module will NOT work 
          </emphasis>
        </emphasis>
        and the driver needs to be built right inside the kernel. For example 
        - some network cards do not support loadable module feature - you MUST 
        build the driver of the network card right into linux kernel. Hence, 
        in 'make xconfig' you MUST not select loadable module for this device. 
      </para>
    </sect2>
    <sect2>
      <title>
        Loadable modules 
      </title>
      <para>
        You can install default loadable modules with - 
      </para>
      <para>
        The step given below may not be required but is needed 
        <emphasis remap="bf">
          ONLY FOR EMERGENCIES 
        </emphasis>
        where your /lib/modules files are damaged. If you already have the 
        /lib/modules directory and in case you want replace them use the 
        --force to replace the package and select appropriate cpu 
        architecture. 
      </para>
      <para>
        For new versions of linux redhat linux 6.0 and later, the kernel 
        modules are included with kernel-2.2*.rpm. Install the loadable 
        modules and the kernel with 
        <programlisting format="linespecific">
		This will list the already installed package.
	bash# rpm -qa | grep -i kernel
		
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i686.rpm
	(or)
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i586.rpm
	(or)
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i386.rpm
        </programlisting>
      </para>
      <para>
        This is only for old versions of redhat linux 5.2 and before. Boot new 
        kernel and install the loadable modules from RedHat Linux "contrib" 
        cdrom 
        <programlisting format="linespecific">
	bash# rpm -i /mnt/cdrom/contrib/kernel-modules*.rpm 
	....(For old linux systems which do not have insmod pre-installed) 
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        See Kernel Documentations 
      </title>
      <para>
        More problems. You can read the /usr/src/linux/README (at least once) 
        and also /usr/src/linux/Documentation. 
        <programlisting format="linespecific">
	bash [/] # cd /usr/src/linux/Documentation
	  
	bash [/usr/src/linux/Documentation] # ls *.txt
	  
	binfmt_misc.txt  ioctl-number.txt           nbd.txt               serial-console.txt
	cachetlb.txt     IO-mapping.txt             nfsroot.txt           sgi-visws.txt
	cciss.txt        IRQ-affinity.txt           nmi_watchdog.txt      smart-config.txt
	computone.txt    isapnp.txt                 oops-tracing.txt      smp.txt
	cpqarray.txt     java.txt                   paride.txt            sonypi.txt
	devices.txt      kernel-doc-nano-HOWTO.txt  parport-lowlevel.txt  specialix.txt
	digiboard.txt    kernel-docs.txt            parport.txt           spinlocks.txt
	digiepca.txt     kernel-parameters.txt      pci.txt               stallion.txt
	DMA-mapping.txt  kmod.txt                   pcwd-watchdog.txt     svga.txt
	dnotify.txt      locks.txt                  pm.txt                swsusp.txt
	exception.txt    logo.txt                   ramdisk.txt           sx.txt
	floppy.txt       magic-number.txt           riscom8.txt           sysrq.txt
	ftape.txt        mandatory.txt              rtc.txt               unicode.txt
	hayes-esp.txt    mca.txt                    SAK.txt               VGA-softcursor.txt
	highuid.txt      md.txt                     sched-coding.txt      watchdog-api.txt
	i810_rng.txt     memory.txt                 sched-design.txt      watchdog.txt
	ide.txt          modules.txt                scsi-generic.txt      zorro.txt
	initrd.txt       mtrr.txt                   scsi.txt
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        make clean 
      </title>
      <para>
        If your new kernel does really weird things after a routine kernel 
        upgrade, chances are you forgot to 
        <literal moreinfo="none" remap="tt">
          make clean 
        </literal>
        before compiling the new kernel. Symptoms can be anything from your 
        system outright crashing, strange I/O problems, to crummy performance. 
        Make sure you do a 
        <literal moreinfo="none" remap="tt">
          make dep 
        </literal>
        , too. 
      </para>
    </sect2>
    <sect2>
      <title>
        Huge or slow kernels 
      </title>
      <para>
        If your kernel is sucking up a lot of memory, is too large, and/or 
        just takes forever to compile even when you've got your new 
        Quadbazillium-III/4400 working on it, you've probably got lot of 
        unneeded stuff (device drivers, filesystems, etc) configured. If you 
        don't use it, don't configure it, because it does take up memory. The 
        most obvious symptom of kernel bloat is extreme swapping in and out of 
        memory to disk; if your disk is making a lot of noise and it's not one 
        of those old Fujitsu Eagles that sound like like a jet landing when 
        turned off, look over your kernel configuration. 
      </para>
      <para>
        You can find out how much memory the kernel is using by taking the 
        total amount of memory in your machine and subtracting from it the 
        amount of ``total mem'' in 
        <literal moreinfo="none" remap="tt">
          /proc/meminfo 
        </literal>
        or the output of the command ` 
        <literal moreinfo="none" remap="tt">
          free 
        </literal>
        '. 
      </para>
    </sect2>
    <sect2>
      <title>
        The parallel port doesn't work/my printer doesn't work 
      </title>
      <para>
        Configuration options for PCs are: First, under the category `General 
        Setup', select `Parallel port support' and `PC-style hardware'. Then 
        under `Character devices', select `Parallel printer support'. 
      </para>
      <para>
        Then there are the names. Linux 2.2 names the printer devices 
        differently than previous releases. The upshot of this is that if you 
        had an 
        <literal moreinfo="none" remap="tt">
          lp1 
        </literal>
        under your old kernel, it's probably an 
        <literal moreinfo="none" remap="tt">
          lp0 
        </literal>
        under your new one. Use ` 
        <literal moreinfo="none" remap="tt">
          dmesg 
        </literal>
        ' or look through the logs in 
        <literal moreinfo="none" remap="tt">
          /var/log 
        </literal>
        to find out. 
      </para>
    </sect2>
    <sect2>
      <title>
        Kernel doesn't compile 
      </title>
      <para>
        If it does not compile, then it is likely that a patch failed, or your 
        source is somehow corrupt. Your version of gcc also might not be 
        correct, or could also be corrupt (for example, the include files 
        might be in error). Make sure that the symbolic links which Linus 
        describes in the 
        <literal moreinfo="none" remap="tt">
          README 
        </literal>
        are set up correctly. In general, if a standard kernel does not 
        compile, something is seriously wrong with the system, and 
        reinstallation of certain tools is probably necessary. 
      </para>
      <para>
        In some cases, gcc can crash due to hardware problems. The error 
        message will be something like ``xxx exited with signal 15'' and it 
        will generally look very mysterious. I probably would not mention 
        this, except that it happened to me once - I had some bad cache 
        memory, and the compiler would occasionally barf at random. Try 
        reinstalling gcc first if you experience problems. You should only get 
        suspicious if your kernel compiles fine with external cache turned 
        off, a reduced amount of RAM, etc. 
      </para>
      <para>
        It tends to disturb people when it's suggested that their hardware has 
        problems. Well, I'm not making this up. There is an FAQ for it -- it's 
        at 
        <ulink url="http://www.bitwizard.nl/sig11">
          "http://www.bitwizard.nl/sig11" 
        </ulink>
        . 
      </para>
    </sect2>
    <sect2>
      <title>
        New version of the kernel doesn't seem to boot 
      </title>
      <para>
        You did not run LILO, or it is not configured correctly. One thing 
        that ``got'' me once was a problem in the config file; it said ` 
        <literal moreinfo="none" remap="tt">
          boot = /dev/hda1 
        </literal>
        ' instead of ` 
        <literal moreinfo="none" remap="tt">
          boot = /dev/hda 
        </literal>
        ' (This can be really annoying at first, but once you have a working 
        config file, you shouldn't need to change it.). 
      </para>
    </sect2>
    <sect2>
      <title>
        You forgot to run LILO, or system doesn't boot at all 
      </title>
      <para>
        Ooops! The best thing you can do here is to boot off of a floppy disk 
        or CDROM and prepare another bootable floppy (such as ` 
        <literal moreinfo="none" remap="tt">
          make zdisk 
        </literal>
        ' would do). You need to know where your root ( 
        <literal moreinfo="none" remap="tt">
          / 
        </literal>
        ) filesystem is and what type it is (e.g. second extended, minix). In 
        the example below, you also need to know what filesystem your 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux 
        </literal>
        source tree is on, its type, and where it is normally mounted. 
      </para>
      <para>
        In the following example, 
        <literal moreinfo="none" remap="tt">
          / 
        </literal>
        is 
        <literal moreinfo="none" remap="tt">
          /dev/hda1 
        </literal>
        , and the filesystem which holds 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux 
        </literal>
        is 
        <literal moreinfo="none" remap="tt">
          /dev/hda3 
        </literal>
        , normally mounted at 
        <literal moreinfo="none" remap="tt">
          /usr 
        </literal>
        . Both are second extended filesystems. The working kernel image in 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux/arch/i386/boot 
        </literal>
        is called 
        <literal moreinfo="none" remap="tt">
          bzImage 
        </literal>
        . 
      </para>
      <para>
        The idea is that if there is a functioning 
        <literal moreinfo="none" remap="tt">
          bzImage 
        </literal>
        , it is possible to use that for the new floppy. Another alternative, 
        which may or may not work better (it depends on the particular method 
        in which you messed up your system) is discussed after the example. 
      </para>
      <para>
        First, boot from a boot/root disk combo or rescue disk, and mount the 
        filesystem which contains the working kernel image: 
      </para>
      <para>
        mkdir /mnt mount -t ext2 /dev/hda3 /mnt 
      </para>
      <para>
        If 
        <literal moreinfo="none" remap="tt">
          mkdir 
        </literal>
        tells you that the directory already exists, just ignore it. Now, 
        <literal moreinfo="none" remap="tt">
          cd 
        </literal>
        to the place where the working kernel image was. Note that /mnt + 
        /usr/src/linux/arch/i386/boot - /usr = /mnt/src/linux/arch/i386/boot 
        Place a formatted disk in drive ``A:'' (not your boot or root disk!), 
        dump the image to the disk, and configure it for your root filesystem: 
      </para>
      <para>
        cd /mnt/src/linux/arch/i386/boot dd if=bzImage of=/dev/fd0 rdev 
        /dev/fd0 /dev/hda1 
      </para>
      <para>
        <literal moreinfo="none" remap="tt">
          cd 
        </literal>
        to 
        <literal moreinfo="none" remap="tt">
          / 
        </literal>
        and unmount the normal 
        <literal moreinfo="none" remap="tt">
          /usr 
        </literal>
        filesystem: 
      </para>
      <para>
        cd / umount /mnt 
      </para>
      <para>
        You should now be able to reboot your system as normal from this 
        floppy. Don't forget to run lilo (or whatever it was that you did 
        wrong) after the reboot! 
      </para>
      <para>
        As mentioned above, there is another common alternative. If you 
        happened to have a working kernel image in 
        <literal moreinfo="none" remap="tt">
          / 
        </literal>
        ( 
        <literal moreinfo="none" remap="tt">
          /vmlinuz 
        </literal>
        for example), you can use that for a boot disk. Supposing all of the 
        above conditions, and that my kernel image is 
        <literal moreinfo="none" remap="tt">
          /vmlinuz 
        </literal>
        , just make these alterations to the example above: change 
        <literal moreinfo="none" remap="tt">
          /dev/hda3 
        </literal>
        to 
        <literal moreinfo="none" remap="tt">
          /dev/hda1 
        </literal>
        (the 
        <literal moreinfo="none" remap="tt">
          / 
        </literal>
        filesystem), 
        <literal moreinfo="none" remap="tt">
          /mnt/src/linux 
        </literal>
        to 
        <literal moreinfo="none" remap="tt">
          /mnt 
        </literal>
        , and 
        <literal moreinfo="none" remap="tt">
          if=bzImage 
        </literal>
        to 
        <literal moreinfo="none" remap="tt">
          if=vmlinuz 
        </literal>
        . The note explaining how to derive 
        <literal moreinfo="none" remap="tt">
          /mnt/src/linux 
        </literal>
        may be ignored. 
      </para>
      <para>
        Using LILO with big drives (more than 1024 cylinders) can cause 
        problems. See the LILO mini-HOWTO or documentation for help on that. 
      </para>
    </sect2>
    <sect2>
      <title>
        It says `warning: bdflush not running' 
      </title>
      <para>
        This can be a severe problem. Starting with a kernel release after 
        Linux v1.0 (around 20 Apr 1994), a program called ` 
        <literal moreinfo="none" remap="tt">
          update 
        </literal>
        ' which periodically flushes out the filesystem buffers, was 
        upgraded/replaced. Get the sources to ` 
        <literal moreinfo="none" remap="tt">
          bdflush 
        </literal>
        ' (you should find it where you got your kernel source), and install 
        it (you probably want to run your system under the old kernel while 
        doing this). It installs itself as ` 
        <literal moreinfo="none" remap="tt">
          update 
        </literal>
        ' and after a reboot, the new kernel should no longer complain. 
      </para>
    </sect2>
    <sect2>
      <title>
        I can't get my IDE/ATAPI CD-ROM drive to work 
      </title>
      <para>
        Strangely enough, lot of people cannot get their ATAPI drives working, 
        probably because there are a number of things that can go wrong. 
      </para>
      <para>
        If your CD-ROM drive is the only device on a particular IDE interface, 
        it must be jumpered as ``master'' or ``single.'' Supposedly, this is 
        the most common error. 
      </para>
      <para>
        Creative Labs (for one) has put IDE interfaces on their sound cards 
        now. However, this leads to the interesting problem that while some 
        people only have one interface to being with, many have two IDE 
        interfaces built-in to their motherboards (at IRQ15, usually), so a 
        common practice is to make the soundblaster interface a third IDE port 
        (IRQ11, or so I'm told). 
      </para>
      <para>
        This causes problems with older Linux versions like 1.3 and below. in 
        that versions Linux don't support a third IDE interface. To get around 
        this, you have a few choices. 
      </para>
      <para>
        If you have a second IDE port already, chances are that you are not 
        using it or it doesn't already have two devices on it. Take the ATAPI 
        drive off the sound card and put it on the second interface. You can 
        then disable the sound card's interface, which saves an IRQ anyway. 
      </para>
      <para>
        If you don't have a second interface, jumper the sound card's 
        interface (not the sound card's sound part) as IRQ15, the second 
        interface. It should work. 
      </para>
    </sect2>
    <sect2>
      <title>
        It says weird things about obsolete routing requests 
      </title>
      <para>
        Get new versions of the 
        <literal moreinfo="none" remap="tt">
          route 
        </literal>
        program and any other programs which do route manipulation. 
        <literal moreinfo="none" remap="tt">
          /usr/include/linux/route.h 
        </literal>
        (which is actually a file in 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux 
        </literal>
        ) has changed. 
      </para>
    </sect2>
    <sect2>
      <title>
        ``Not a compressed kernel Image file'' 
      </title>
      <para>
        Don't use the 
        <literal moreinfo="none" remap="tt">
          vmlinux 
        </literal>
        file created in 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux 
        </literal>
        as your boot image; 
        <literal moreinfo="none" remap="tt">
          [..]/arch/i386/boot/bzImage 
        </literal>
        is the right one. 
      </para>
    </sect2>
    <sect2>
      <title>
        Problems with console terminal after upgrade to Linux v1.3.x 
      </title>
      <para>
        Change the word 
        <literal moreinfo="none" remap="tt">
          dumb 
        </literal>
        to 
        <literal moreinfo="none" remap="tt">
          linux 
        </literal>
        in the console termcap entry in 
        <literal moreinfo="none" remap="tt">
          /etc/termcap 
        </literal>
        . You may also have to make a terminfo entry. 
      </para>
    </sect2>
    <sect2>
      <title>
        Can't seem to compile things after kernel upgrade 
      </title>
      <para>
        The linux kernel source includes a number of include files (the things 
        that end with 
        <literal moreinfo="none" remap="tt">
          .h 
        </literal>
        ) which are referenced by the standard ones in 
        <literal moreinfo="none" remap="tt">
          /usr/include 
        </literal>
        . They are typically referenced like this (where 
        <literal moreinfo="none" remap="tt">
          xyzzy.h 
        </literal>
        would be something in 
        <literal moreinfo="none" remap="tt">
          /usr/include/linux 
        </literal>
        ): #include &lt;linux/xyzzy.h&gt; Normally, there is a link called 
        <literal moreinfo="none" remap="tt">
          linux 
        </literal>
        in 
        <literal moreinfo="none" remap="tt">
          /usr/include 
        </literal>
        to the 
        <literal moreinfo="none" remap="tt">
          include/linux 
        </literal>
        directory of your kernel source ( 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux/include/linux 
        </literal>
        in the typical system). If this link is not there, or points to the 
        wrong place, most things will not compile at all. If you decided that 
        the kernel source was taking too much room on the disk and deleted it, 
        this will obviously be a problem. Another way it might go wrong is 
        with file permissions; if your 
        <literal moreinfo="none" remap="tt">
          root 
        </literal>
        has a umask which doesn't allow other users to see its files by 
        default, and you extracted the kernel source without the 
        <literal moreinfo="none" remap="tt">
          p 
        </literal>
        (preserve filemodes) option, those users also won't be able to use the 
        C compiler. Although you could use the 
        <literal moreinfo="none" remap="tt">
          chmod 
        </literal>
        command to fix this, it is probably easier to re-extract the include 
        files. You can do this the same way you did the whole source at the 
        beginning, only with an additional argument: 
      </para>
      <para>
        blah# tar zxvpf linux.x.y.z.tar.gz linux/include Note: `` 
        <literal moreinfo="none" remap="tt">
          make config 
        </literal>
        '' will recreate the 
        <literal moreinfo="none" remap="tt">
          /usr/src/linux 
        </literal>
        link if it isn't there. 
      </para>
    </sect2>
    <sect2>
      <title>
        Increasing limits 
      </title>
      <para>
        The following few 
        <emphasis remap="it">
          example 
        </emphasis>
        commands may be helpful to those wondering how to increase certain 
        soft limits imposed by the kernel: 
        <programlisting format="linespecific">
			echo 4096 &gt; /proc/sys/kernel/file-max 
			echo 12288 &gt; /proc/sys/kernel/inode-max 
			echo 300 400 500 &gt; /proc/sys/vm/freepages 
        </programlisting>
      </para>
    </sect2>
    <sect2>
      <title>
        Where To Report Bugs? 
      </title>
      <para>
        See 'Quick Steps - Kernel Compile' in the 
        <xref linkend="reportbugs"/>
        . 
      </para>
    </sect2>
  </sect1>
</article>
