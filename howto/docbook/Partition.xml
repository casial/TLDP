<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
     "http://docbook.org/xml/4.2/docbookx.dtd" []>

<article id="index">

<articleinfo>
<title>Linux Partition HOWTO</title>
<author><firstname>Anthony</firstname><surname>Lissot</surname></author>
    <revhistory id="revhistory">
      <revision>
        <revnumber>3.5</revnumber>
        <date>26 Dec 2005</date>
        <revremark>    
      		reorganized document page ordering.
			added page on setting up swap space.
			added page of partition labels.
			updated max swap size values in section 4.
			added instructions on making ext2/3 file systems.
			broken links identified by Richard Calmbach are fixed.
			created an XML version.
        </revremark>
      </revision>        
      <revision>
        <revnumber>3.4.4</revnumber>
        <date>08 March 2004</date>
        <revremark>
				synchronized SGML version with HTML version. 
				Updated lilo placement and swap size discussion.
        </revremark>
      </revision>        
      <revision>
        <revnumber>3.3</revnumber>
        <date>04 April 2003</date>
        <revremark>synchronized SGML and HTML versions
        </revremark>
      </revision>        
      <revision>
        <revnumber>3.3</revnumber>
        <date>10 July 2001</date>
        <revremark>Corrected Section 6, calculation of cylinder numbers
        </revremark>
      </revision>        
      <revision>
        <revnumber>3.2</revnumber>
        <date>1 September 2000</date>
        <revremark>Dan Scott provides sgml conversion 2 Oct. 2000.
			Rewrote Introduction.
			Rewrote discussion on device names in Logical Devices.
			Reorganized Partition Types.
			Edited Partition Requirements.
			Added Recovering a deleted partition table.
        </revremark>
      </revision>
      <revision>
        <revnumber>3.1</revnumber>
        <date>12 June 2000</date>
        <revremark>Corrected swap size limitation in Partition
        Requirements, updated various links in Introduction, added
        submitted example in How to Partition with fdisk, added file
        system discussion in Partition Requirements. </revremark>
      </revision>
      <revision>
        <revnumber>3.0</revnumber>
        <date>1 May 2000</date>
        <revremark>
        First revision by 
        Anthony Lissot based on Linux Partition HOWTO by Kristian Koehntopp.
        </revremark>
      </revision>
      <revision>
        <revnumber>2.4</revnumber>
        <date>3 November 1997</date>
        <revremark>Last revision by Kristian Koehntopp.
        </revremark>
      </revision>
    </revhistory>

<abstract>

<para>
	This Linux Mini-HOWTO teaches you how to plan and create partitions
	on IDE and SCSI hard drives. It discusses partitioning terminology
	and considers size and location issues. Use of the fdisk
	partitioning utility for creating and recovering of partition tables
	is covered. The most recent version of this document is <ulink
	url="http://lissot.net/partition">here</ulink>. The Turkish
	translation is <ulink
	url="http://belgeler.org/howto/partition-howto.html">here</ulink>.
</para>

</abstract>

</articleinfo>

<sect1 id="intro">
<title>Introduction</title>

<sect2 id="explanation">
<title>What is a partition?</title>

<para>
	Partitioning is a means to divide a single hard drive into many
	logical drives. A partition is a contiguous set of blocks on a drive
	that are treated as an independant disk. A partition table (the
	creation of which is the topic of this HOWTO) is
	an index that relates sections of the hard drive to partitions.
</para>
<para>
Why have multiple partitions? 
<itemizedlist>
<listitem>
	<para>
		Encapsulate your data. Since file system corruption is local to
		a partition, you stand to lose only some of your data if an
		accident occurs.
	</para>
</listitem>

<listitem>
	<para>
		Increase disk space efficiency. You can format partitions with
		varying block sizes, depending on your usage. If your data is in
		a large number of small files (less than 1k) and your partition
		uses 4k sized blocks, you are wasting 3k for every file. In
		general, you waste on average one half of a block for every
		file, so matching block size to the average size of your files
		is important if you have many files.
	</para>
</listitem>

<listitem>
	<para>
		Limit data growth. Runaway processes or maniacal users can
		consume so much disk space that the operating system no longer
		has room on the hard drive for its bookkeeping operations. This
		will lead to disaster. By segregating space, you ensure that
		things other than the operating system die when allocated disk
		space is exhausted.
	</para>
</listitem>

</itemizedlist>
</para>

</sect2>



<sect2><title>Other Partitioning Software:</title>
<para>
<itemizedlist>
   <listitem><para><command>sfdisk</command>: a command-line version of fdisk</para>
</listitem>

   <listitem><para><command>cfdisk</command>: a curses-based version of fdisk</para>
</listitem>

   <listitem><para><ulink url="http://www.gnu.org/software/parted/parted.html"><command>parted</command></ulink>: Gnu partition editor</para>
</listitem>

   <listitem><para><ulink url="http://www.powerquest.com/partitionmagic/index.html"><productname>Partition Magic</productname></ulink>:
 a commercial utility to create, resize, merge and convert partitions, without destroying data.
</para>
</listitem>

   <listitem><para><ulink url="http://www.linux-mandrake.com/diskdrake"><productname>Disk Drake</productname></ulink>: a Perl/Gtk program to create, rsize, and delete partitions</para>
</listitem>
</itemizedlist>
</para>
</sect2>

<sect2 id="howtos">
<title>Related HOWTOs</title>

<para>
<table frame="all">
<title>Related HOWTOs</title>
<tgroup cols="3" colsep="1" rowsep="1">
<colspec colname="c1" />
<colspec colname="c2" />
<colspec colname="c3" />
<thead>
<row>
  <entry>Title</entry>
  <entry>Author</entry>
  <entry>Description</entry>
</row>
</thead>
<tbody>
<row>
   <entry><ulink url="http://www.tldp.org/HOWTO/Install-Strategies">
   			Dual boot install strategies</ulink>
   </entry>
   <entry>
   		<ulink url="mailto:tobbyb@usa.net">Gjoen Stein</ulink>
   	</entry>
   <entry>
   		How to estimate the various size and speed requirements for
   		different parts of the filesystem.
   	</entry>
</row>
<row>
   <entry><ulink url="http://www.nyx.net/~sgjoen/disk.html">Linux Multiple
   Disk System Tuning</ulink></entry>
   <entry><ulink url="mailto:sgjoen@mail.nyx.net">Gjoen Stein</ulink></entry>
   <entry>How to estimate the various size and speed requirements for
   different parts of the filesystem.</entry>
</row>
<row>
   <entry>
   		<ulink url="http://www.tldp.org/HOWTO/Large-Disk-HOWTO.html">
   			Linux Large Disk
   		</ulink>
   	</entry>
   <entry>
   		<ulink url="mailto:aeb@cwi.nl">
   			Andries Brouwer
   		</ulink>
   </entry>
   <entry>
   		Instructions and considerations regarding disks with more than 1024 cylinders
   	</entry>
</row>

<row>
   <entry>
	   <ulink url="http://metalab.unc.edu/mdw/HOWTO/mini/Quota.html">
			 Linux Quota
	   </ulink>
   </entry>
   <entry>
   		<ulink url="mailto:mailto:r.vdooren@snow.nl">
   			Ralf van Dooren
   		</ulink>
   </entry>
   <entry>
   		Instructions on limiting disk space usage per user (quotas)
   </entry>
</row>
<row>
   <entry>
	   <ulink url="http://www.linuxdocs.org/HOWTOs/mini/Partition-Rescue.html">
		   Partition-Rescue mini-HOWTO
	   </ulink>
   </entry>
   <entry>
	   <ulink url="mailto:jdanield@dodin.net">
		   Jean-Daniel Dodin
	   </ulink>
   </entry>
   <entry>
	   How to restore linux partitions after they have been deleted by a
	   Windows install. Does not appear to preserve data.
   </entry>
</row>
<row>
   <entry>
	   <ulink url="http://www.tldp.org/HOWTO/ADSM-Backup.html">
		   Linux ADSM Backup
	   </ulink>
   </entry>
   <entry>
	   <ulink url="mailto:Thomas.Koenig@ciw.uni-karlsruhe.de">
		   Thomas Koenig
	   </ulink>
   </entry>
   <entry>
	   Instructions on integrating Linux into an IBM ADSM backup
	   environment.
   </entry>
</row>
<row>
   <entry>
	   <ulink url="http://www.ibiblio.org/pub/Linux/docs/HOWTO/other-formats/html_single/Backup-With-MSDOS.html">
		   Linux Backup with MSDOS
	   </ulink>
   </entry>
   <entry>
	   <ulink url="mailto:neufeld@physics.utoronto.ca">
		   Christopher Neufeld
	   </ulink>
   </entry>
   <entry>
		   Information about MS-DOS driven Linux backups.
   </entry>
</row>

<row>
   <entry> Linux HOWTO Index</entry>
   <entry><ulink url="mailto:linux-howto@sunsite.unc.edu">Tim Bynum</ulink></entry>
   <entry>Instructions on writing and submitting a HOWTO document</entry>
</row>
</tbody>
</tgroup>
</table>
</para>

</sect2>

<sect2>
<title>Additional information on your system:</title>

<para>
<itemizedlist>
  <listitem>
  <para>
  <ulink url="file:/usr/src/linux/Documentation"><filename class="directory">/usr/src/linux/Documentation</filename></ulink>
  <itemizedlist>
    <listitem>
    <para>
    <ulink url="file:/usr/src/linux/Documentation/ide.txt">
    <filename>ide.txt</filename></ulink>:
    Info about your IDE drivers
    </para>
    </listitem>

    <listitem>
    <para>
    <ulink url="file:/usr/src/linux/Documentation/scsi.txt"><filename>scsi.txt</filename></ulink>:
    Info about your SCSI drivers
    </para>
    </listitem>

    </itemizedlist>
  </para>
  </listitem>
</itemizedlist>

</para>

</sect2>

</sect1>

<sect1 id="devices">
<title>Devices</title>
<para>
There is a special nomenclature that linux uses to refer to hard drive
partitions that must be understood in order to follow the discussion
on the following pages.
</para>
<para>
In Linux, partitions are represented by device files. These are phoney
files located in <filename class="directory">/dev</filename>. Here are a few entries:

<programlisting>
brw-rw----    1 root     disk       3,   0 May  5  1998 hda
brw-rw----    1 root     disk       8,   0 May  5  1998 sda
crw-------    1 root     tty        4,  64 May  5  1998 ttyS0
</programlisting>

A device file is a file with type c ( for "character" devices, devices
that do not use the buffer cache) or b (for "block" devices, which go
through the buffer cache). In Linux, all disks are represented as
block devices only.  
</para>

<sect2 id="names"><title>Device names</title>

<sect3 id="NamingConvention"><title>Naming Convention</title>
<para>
By convention, IDE drives will be given device
names <literal>/dev/hda</literal> to <literal>/dev/hdd</literal>.
<emphasis>H</emphasis>ard <emphasis>D</emphasis>rive
<emphasis>A</emphasis> (<literal>/dev/hda</literal>) is the first drive and
<emphasis>H</emphasis>ard <emphasis>D</emphasis>rive
<emphasis>C</emphasis> (<literal>/dev/hdc</literal>) is the third.


<table frame="all">
  <title>IDE controller naming convention</title>
  <tgroup cols="3" align="center" colsep="1" rowsep="1">
  <colspec colname="drive name" />
  <colspec colname="drive controller" />
  <colspec colname="drive number" />

  <tbody>
    <row>
           <entry>drive name</entry>
           <entry>drive controller</entry>
           <entry>drive number</entry>
    </row>
    <row>
           <entry>/dev/hda</entry>
           <entry>1</entry>
           <entry>1</entry>
    </row>
    <row>
           <entry>/dev/hdb</entry>
           <entry>1</entry>
           <entry>2</entry>
    </row>
    <row>
           <entry>/dev/hdc</entry>
           <entry>2</entry>
           <entry>1</entry>
    </row>
    <row>
           <entry>/dev/hdd</entry>
           <entry>2</entry>
           <entry>2</entry>
    </row>
   </tbody>
   </tgroup>
</table>
</para>
<para>
A typical PC has two IDE
controllers, each of which can have two drives connected to it. For
example, <filename>/dev/hda</filename> is the first drive (master) on the
first IDE controller and <filename>/dev/hdd</filename> is
the second (slave) drive on the second controller (the fourth IDE
drive in the computer). 
</para>
<para>
You can write to these devices directly (using <command>cat</command> or 
<command>dd</command>). However,
since these devices represent the entire disk, starting at the first
block, you can mistakenly overwrite the master boot record and the
partition table, which will render the drive unusable.
</para>
<para>
<table frame="all">
  <title>partition names</title>
  <tgroup cols="5" align="center" colsep="1" rowsep="1">
  <colspec colname="drive name" />
  <colspec colname="drive controller" />
  <colspec colname="drive number" />
  <colspec colname="partition type" />
  <colspec colname="partition number" />

  <tbody>
    <row>
           <entry>drive name</entry>
           <entry>drive controller</entry>
           <entry>drive number</entry>
           <entry>partition type</entry>
           <entry>partition number</entry>
    </row>
    <row>
           <entry>/dev/hda1</entry>
           <entry>1</entry>
           <entry>1</entry>
           <entry>primary</entry>
           <entry>1</entry>
    </row>
    <row>
           <entry>/dev/hda2</entry>
           <entry>1</entry>
           <entry>1</entry>
           <entry>primary</entry>
           <entry>2</entry>
    </row>
    <row>
           <entry>/dev/hda3</entry>
           <entry>1</entry>
           <entry>1</entry>
           <entry>primary</entry>
           <entry>3</entry>
    </row>
    <row>
           <entry>/dev/hda4</entry>
           <entry>1</entry>
           <entry>1</entry>
           <entry>swap</entry>
           <entry>NA</entry>
    </row>
    <row>
           <entry>/dev/hdb1</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>primary</entry>
           <entry>1</entry>
    </row>
    <row>
           <entry>/dev/hdb2</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>primary</entry>
           <entry>2</entry>
    </row>
    <row>
           <entry>/dev/hdb3</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>primary</entry>
           <entry>3</entry>
    </row>
    <row>
           <entry>/dev/hdb4</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>primary</entry>
           <entry>4</entry>
    </row>
   </tbody>
   </tgroup>
</table>
</para>
<para>
	Once a drive has been partitioned, the partitions will represented
	as numbers on the end of the names. For example, the second
	partition on the second drive will be
	<filename class="partition">/dev/hdb2</filename>. The partition type (primary) is
	listed in the table above for clarity, although the concept is not
	explained until <xref linkend="primary" />.
</para>

<para>
<table frame="all">
  <title>SCSI Drives</title>
  <tgroup cols="5" align="center" colsep="1" rowsep="1">
  <colspec colname="drive name" />
  <colspec colname="drive controller" />
  <colspec colname="drive number" />
  <colspec colname="partition type" />
  <colspec colname="partition number" />

  <tbody>
    <row>
           <entry>drive name</entry>
           <entry>drive controller</entry>
           <entry>drive number</entry>
           <entry>partition type</entry>
           <entry>partition number</entry>
    </row>
    <row>
           <entry>/dev/sda1</entry>
           <entry>1</entry>
           <entry>6</entry>
           <entry>primary</entry>
           <entry>1</entry>
    </row>
    <row>
           <entry>/dev/sda2</entry>
           <entry>1</entry>
           <entry>6</entry>
           <entry>primary</entry>
           <entry>2</entry>
    </row>
    <row>
           <entry>/dev/sda3</entry>
           <entry>1</entry>
           <entry>6</entry>
           <entry>primary</entry>
           <entry>3</entry>
    </row>
   </tbody>
   </tgroup>
</table>

</para>
<para>
	SCSI drives follow a similar pattern; They are represented by 'sd'
	instead of 'hd'. The first partition of the second SCSI drive would
	therefore be <filename class="partition">/dev/sdb1</filename>. In
	the table above, the drive number is arbitraily chosen to be 6 to
	introduce the idea that SCSI ID numbers do not map onto device names
	under linux.
</para>
</sect3>

<sect3><title>Name Assignment</title>
<para>
		Under (Sun) Solaris and (SGI) IRIX, the device name given to a
		SCSI drive has some relationship to where you plug it in. Under
		linux, there is only wailing and gnashing of teeth.
</para>

<para>
<emphasis>Before</emphasis>
<programlisting>
SCSI ID #2        SCSI ID #5       SCSI ID #7        SCSI ID #8
 /dev/sda          /dev/sdb         /dev/sdc          /dev/sdd
</programlisting>
</para>
<para>
<emphasis>After</emphasis>
<programlisting>
SCSI ID #2                         SCSI ID #7        SCSI ID #8
 /dev/sda                           /dev/sdb          /dev/sdc
</programlisting>
</para>
<para>
	SCSI drives have ID numbers which go from 1 through 15. Lower SCSI
	ID numbers are assigned lower-order letters. For example, if you
	have two drives numbered 2 and 5, then #2 will be
	<filename>/dev/sda</filename> and #5 will be
	<filename>/dev/sdb</filename>. If you remove either, all the higher
	numbered drives will be renamed the next time you boot up.
</para>
<para>
	If you have two SCSI controllers in your linux box, you will need to
	examine the output of <command>/bin/dmesg</command> in order to
	see what name each drive was assigned. If you remove one of two
	controllers, the remaining controller might have all its drives
	renamed. Grrr...
</para>
<para>
	There are two work-arounds; both involve using a program to put a
	label on each partition (see <xref linkend="labels" />). The label is
	persistent even when the device is physically moved. You then refer
	to the partition directly or indirectly by label.
</para>

</sect3>

<sect3><title>Logical Partitions</title>
<para>

<table frame="all">
  <title>Logical Partitions</title>
  <tgroup cols="5" align="center" colsep="1" rowsep="1">
  <colspec colname="drive name" />
  <colspec colname="drive controller" />
  <colspec colname="drive number" />
  <colspec colname="partition type" />
  <colspec colname="partition number" />

  <tbody>
    <row>
           <entry>drive name</entry>
           <entry>drive controller</entry>
           <entry>drive number</entry>
           <entry>partition type</entry>
           <entry>partition number</entry>
    </row>
    <row>
           <entry>/dev/hdb1</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>primary</entry>
           <entry>1</entry>
    </row>
    <row>
           <entry>/dev/hdb2</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>extended</entry>
           <entry>NA</entry>
    </row>
    <row>
           <entry>/dev/hda5</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>logical</entry>
           <entry>2</entry>
    </row>
    <row>
           <entry>/dev/hdb6</entry>
           <entry>1</entry>
           <entry>2</entry>
           <entry>logical</entry>
           <entry>3</entry>
    </row>
   </tbody>
   </tgroup>
</table>

</para>
<para>
	The table above illustrates a mysterious jump in the name
	assignments. This is due to the use of logical  partitions (see <xref
	linkend="logical" />, which always start with 5, for
	reasons explained later.
</para>

<para>
	This is all you have to know to deal with linux disk devices. For
	the sake of completeness, see Kristian's discussion of device
	numbers below.
</para>
</sect3>


</sect2>

<sect2 id="numbers"><title>Device numbers</title><!--Kristian 3 Nov 97-->

<para>
	The only important thing with a device file are its major and minor
	device numbers, which are shown instead of the file size:
<programlisting>
$ ls -l /dev/hda
</programlisting>
<table frame="all">
  <title>Device file attributes</title>
  <tgroup cols="8" align="center" colsep="1" rowsep="1">
  <colspec colname="c1" />
  <colspec colname="c2" />
  <colspec colname="c3" />
  <colspec colname="c4" />
  <colspec colname="c5" />
  <colspec colname="c6" />
  <colspec colname="c7" />
  <colspec colname="c8" />

  <tbody>
    <row>
           <entry>brw-rw----</entry>
           <entry>1</entry>
           <entry>root</entry>
           <entry>disk</entry>
           <entry>3,</entry>
           <entry>0</entry>
           <entry>Jul 18  1994</entry>
           <entry>/dev/hda</entry>
    </row>
    <row>
           <entry>permissions</entry>
           <entry></entry>
           <entry>owner</entry>
           <entry>group</entry>
           <entry>major device number</entry>
           <entry>minor device number</entry>
           <entry>date</entry>
           <entry>device name</entry>
    </row>
   </tbody>
   </tgroup>
</table>
</para>

<para>When accessing a device file, the major number
selects which device driver is being called to perform the
input/output operation. This call is being done with the minor number
as a parameter and it is entirely up to the driver how the minor
number is being interpreted. The driver documentation usually
describes how the driver uses minor numbers. For IDE disks, this
documentation is in 
<ulink url="file:/usr/src/linux/Documentation/ide.txt">
<filename>/usr/src/linux/Documentation/ide.txt</filename></ulink>.
For SCSI disks, one would expect such documentation in 
<ulink url="file:/usr/src/linux/Documentation/scsi.txt">
<filename>/usr/src/linux/Documentation/scsi.txt</filename></ulink>,
but it isn't there. One has to look at the driver source to be sure
(<ulink url="file:/usr/src/linux/driver/scsi/sd.c">
<filename>/usr/src/linux/driver/scsi/sd.c</filename></ulink>:184-196). 
Fortunately,
there is Peter Anvin's list of device numbers and names in 
<ulink url="file:/usr/src/linux/Documentation/devices.txt">
<filename>/usr/src/linux/Documentation/devices.txt</filename></ulink>;
see the entries for block devices, major 3, 22, 33, 34 for IDE and
major 8 for SCSI disks. The major and minor numbers are a byte each
and that is why the number of partitions per disk is limited.
</para>

</sect2>
</sect1>

<sect1 id="partition-types">
 <title>Partition Types</title>

<sect2 id="types"><title>Partition Types</title>

<para>
	A partition is labeled to host a certain kind of file system (not to
	be confused with a volume label (see <xref linkend="labels" />)).
	Such a file system could be the linux standard ext2 file system or
	linux swap space, or even foreign file systems like (Microsoft) NTFS
	or (Sun) UFS. There is a numerical code associated with each
	partition type. For example, the code for ext2 is
	<literal>0x83</literal> and linux swap is <literal>0x82</literal>.
	To see a list of partition types and their codes, execute
	<userinput><command>/sbin/sfdisk</command> -T </userinput>
</para>
</sect2>

<sect2><title>Foreign Partition Types</title>
<para>
	The partition type codes have been arbitrarily chosen (you can't
	figure out what they should be) and they are particular to a given
	operating system. Therefore, it is theoretically possible that if
	you use two operating systems with the same hard drive, the same
	code might be used to designate two different partition types. OS/2
	marks its partitions with a 0x07 type and so does Windows NT's NTFS.
	MS-DOS allocates several type codes for its various flavors of FAT
	file systems: 0x01, 0x04 and 0x06 are known. DR-DOS used 0x81 to
	indicate protected FAT partitions, creating a type clash with
	Linux/Minix at that time, but neither Linux/Minix nor DR-DOS are
	widely used any more.
</para>

<para>
<!-- Kristian 3 Nov 97-->
	 OS/2 marks its partitions with a <literal>0x07</literal> type and
	 so does Windows NT's NTFS. MS-DOS allocates several type codes for
	 its various flavors of FAT file systems: 0x01,
	 <literal>0x04</literal> and <literal>0x06</literal> are known.
	 DR-DOS used <literal>0x81</literal> to indicate protected FAT
	 partitions, creating a type clash with Linux/Minix at that time,
	 but neither Linux/Minix nor DR-DOS are widely used any more.
</para>
</sect2>

<sect2 id="primary"><title>Primary Partitions</title>
<para>
	The number of partitions on an Intel-based system was limited from
	the very beginning: The original partition table was installed as
	part of the boot sector and held space for only four partition
	entries.  These partitions are now called primary partitions.
</para>
</sect2>

<sect2 id="logical">
<title>Logical Partitions</title>
<!--Tony 1 Sep 00-->
<para>
	One primary partition of a hard drive may be subpartitioned. These
	are logical partitions. This effectively allows us to skirt the
	historical four partition limitation.
</para>

<para>
	The primary partition used to house the logical partitions is called
	an extended partition and it has its own file system type (0x05).
	Unlike primary partitions, logical partitions must be contiguous.
	Each logical partition contains a pointer to the next logical
	partition, which implies that the number of logical partitions is
	unlimited. However, linux imposes limits on the total number of any
	type of partition on a drive, so this effectively limits the number
	of logical partitions. This is at most 15 partitions total on an
	SCSI disk and 63 total on an IDE disk.
</para>
</sect2>

<sect2 id="swap-partitions"><title>Swap Partitions</title>
<para>
	Every process running on your computer is allocated a number of
	blocks of RAM. These blocks are called pages. The set of in-memory
	pages which will be referenced by the processor in the very near
	future is called a "working set." Linux tries to predict these
	memory accesses (assuming that recently used pages will be used
	again in the near future) and keeps these pages in RAM if possible.
</para>
<para>
	If you have too many processes running on a machine, the kernel will
	try to free up RAM by writing pages to disk. This is what swap space
	is for. It effectively increases the amount of memory you have
	available. However, disk I/O is about a hundred times slower than
	reading from and writing to RAM. Consider this emergency memory and
	not extra memory.
</para>
<para>
	If memory becomes so scarce that the kernel pages out from the
	working set of one process in order to page in for another, the
	machine is said to be thrashing. Some readers might have
	inadvertenly experienced this: the hard drive is grinding away like
	crazy, but the computer is slow to the point of being unusable. Swap
	space is something you need to have, but it is no substitute for
	sufficient RAM.  See the discussion in  <xref
	linkend="SwapSize" /> for tips on determining the size of swap space
	you need.
</para>
</sect2>
</sect1>

<sect1 id="requirements">
<title>Partitioning requirements</title>
<sect2 id="number"><title>What Partitions do I need?</title>
<!-- Tony, 1 May 00-->
<para>
For the Boot Drive:
If you want to boot your operating system from the drive you are about
to partition, you will need:
<itemizedlist>
  <listitem><para>A primary partition</para></listitem>
  <listitem><para>One or more swap partitions</para></listitem>
  <listitem><para>Zero or more primary/logical partitions</para></listitem>
</itemizedlist>
For any other drive:
<itemizedlist>
  <listitem><para>One or more primary/logical partitions</para></listitem>
  <listitem><para>Zero or more swap partitions</para></listitem>
</itemizedlist>
</para>
</sect2>
<sect2><title>Discussion:</title> 

<variablelist>
<varlistentry id="boot">
<term>Boot Partition:</term>
<listitem>
<para>
	Your boot partition ought to be a primary partition, not a logical
	partition. This will ease recovery in case of disaster, but it is
	not technically necessary. It must be of type
	<literal>0x83</literal> "Linux native". If you are using a version
	of <ulink
	url="http://tldp.org/HOWTO/LILO.html"><command>lilo</command></ulink
	> before 21-3 (ie, from the 1990s), your boot partition must be
	contained within the first 1024 cylinders of the drive. (Typically,
	the boot partition need only contain the kernel image.)
</para>
<para>
	If you have more than one boot partition (from other OSs, for
	example,) keep them all in the first 1024 cylinders
	(<emphasis>All</emphasis> DOS partitions must be within the first
	1024).  If you are using a modern version of lilo, or a means other
	than lilo to load your kernel (for example, a boot disk or the
	<command>LOADLIN.EXE</command> MS-DOS based Linux loader), the
	partition can be anywhere. See the <ulink
	url="http://www.tldp.org/HOWTO/Large-Disk-HOWTO.html">Large-disk</ulink> 
	HOWTO for details.
</para>
</listitem>
</varlistentry>

<varlistentry id="swap-definition">
<term>Swap Partition:</term>
<listitem>
<para>
Unless you swap to files (see <xref linkend="swapfiles" />) you will
need a dedicated swap partition. It must be of type
<literal>0x82</literal> "Linux swap". It may be positioned anywhere on
the disk (but see <xref linkend="SwapPlacement" />). Either a primary or
logical partition can be used for swap. More than one swap partition can
exist on a drive. 8 total (across drives) are permitted. See notes on
swap size below (<xref linkend="SwapSize" />).
</para>
</listitem>
</varlistentry>

<varlistentry id="logical-definition">
<term>Logical Partition:</term>
<listitem>
<para>
A single primary partition must be used as a container (extended
partition) for the logical partitions. The extended partition can go
anywhere on the disk. The logical partitions must be contiguous, but
needn't fill the extended partition.
</para>
</listitem>
</varlistentry>
</variablelist>
</sect2>

<sect2>
<title>File Systems</title>

<!-- Tony, 12 June 00-->

<sect3 id="filesystems">
<title>Which file systems need their own partitions?</title>
<para>
Everything in your linux file system can go in the same (single)
partition. However, there are circumstances when you may want to
restrict the growth of certain file systems. For example, if your mail
spool was in the same partition as your root fs and it filled the
remaining space in the partition, your computer would basically
hang.
</para>
<variablelist>
<varlistentry>
     <term><filename class="directory">/var</filename></term>
     <listitem>
     <para>This fs contains spool directories such as those for mail and 
	  printing. In addition, it contains the error log
	  directory. If your machine is a server and develops a
	  chronic error, those msgs can fill the partition. Server
	  computers ought to have /var in a different partition than
	  /.
      </para>
      </listitem>
</varlistentry>
<varlistentry>
     <term><filename class="directory">/usr</filename></term>
     <listitem>
     <para>This is where most executable binaries go. In addition, the
	  kernel source tree goes here, and much documentation. 
     </para>
     </listitem>
</varlistentry>
<varlistentry>
     <term><filename class="directory">/tmp</filename></term>
     <listitem>
     <para>Some programs write temporary data files here. Usually, they
	  are quite small. However, if you run computationally
	  intensive jobs, like science or engineering applications,
	  hundreds of megabytes could be required for brief periods of 
	  time. In this case, keep /tmp in a different partition than
	  /.
     </para>
     </listitem>
</varlistentry>
<varlistentry>
     <term><filename class="directory">/home</filename></term>
     <listitem>
     <para>This is where users home directories go. If you do not impose 
	  quotas on your users, this ought to be in its own partition.
     </para>
     </listitem>
</varlistentry>
<varlistentry>
     <term><filename class="directory">/boot</filename></term>
     <listitem>
     <para>This is where your kernel images go. See discussion above
          for placement on old systems.
     </para>
     </listitem>
</varlistentry>
</variablelist>

</sect3>

<sect3 id="backups">
<title>File lifetimes and backup cycles as partitioning criteria</title>

<para>With ext2, partitioning decisions should be governed by backup
considerations and to avoid external fragmentation <xref linkend="fragmentation" />
from different file lifetimes.
</para>
<para>Files have lifetimes. After a file has been created, it will
remain some time on the system and then be removed. File
lifetime varies greatly throughout the system and is partly
dependent on the pathname of the file. For example, files in
<filename>/bin</filename>, <filename>/sbin</filename>, <filename>/usr/sbin</filename>, <filename>/usr/bin</filename> and similar directories are
likely to have a very long lifetime: many months and above.
Files in <filename>/home</filename> are likely to have a medium lifetime: several
weeks or so. File in <filename>/var</filename> are usually short lived: Almost no
file in <filename>/var/spool/news</filename> will remain longer than a few days,
files in <filename>/var/spool/lpd</filename> measure their lifetime in minutes or
less.
</para>
<para>
	For backup it is useful if the amount of daily backup is smaller
	than the capacity of a single backup medium. A daily backup can be a
	complete backup or an incremental backup.
</para>
<para>
	You can decide to keep your partition sizes small enough that they
	fit completely onto one backup medium (choose daily full backups).
	In any case a partition should be small enough that its daily delta
	(all modified files) fits onto one backup medium (choose incremental
	backup and expect to change backup media for the weekly/monthly full
	dump - no unattended operation possible).
</para>
<para>
	Your backup strategy depends on that decision.
</para>
<para>
	When planning and buying disk space, remember to set aside a
	sufficient amount of money for backup! Unbackuped data is worthless!
	Data reproduction costs are much higher than backup costs for
	virtually everyone!
</para>
<para>
	For performance it is useful to keep files of different lifetimes on
	different partitions. This way the short lived files on the news
	partition may be fragmented very heavily. This has no impact on the
	performance of the <filename class="directory">/</filename> or
	<filename class="directory">/home</filename> partition.
</para>

</sect3>

</sect2>

<sect2 id="SwapSize">
<title>Swap Partitions</title>
<!-- Kristian 3 Nov 97-->
<!-- Tony 04 Apr 03 -->
<sect3>
<title>How large should my swap space be?</title>

<para>
Conventional wisdom creates swap space equal to the amount of RAM. </para>

<para>
	But keep in mind that this is just a rule of thumb. It is easily
	possible to create scenarios where programs have extremely large or
	extremely small working sets (see <xref linkend="swap-partitions" />). 
	For example, a simulation program with
	a large data set that is accessed in a very random fashion would
	have almost no noticeable locality of reference in its data segment,
	so its working set would be quite large.
</para>

<para>
	On the other hand, a graphics program with many simultaneously
	opened JPEGs, all but one iconified, would have a very large data
	segment. But image transformations are all done on one single image,
	most of the memory occupied by the program is not accessed. The same
	is true for an editor with many editor windows where only one window
	is being modified at a time. These programs have - if they are
	designed properly - a very high locality of reference and large
	parts of them can be kept swapped out without too severe performance
	impact. A user who never never quits programs once launched would
	want a lot of swap space for the same reason.
</para>

<para>
	Servers typically are configured with more swap space than their
	desktop counterparts. Even though a given amount of swap is
	sufficient for its operations, the server might come under transient
	heavy loads which cause it to page out at a high rate. Some
	administrators prefer this to the server crashing altogether. In
	these cases, swap might be several times the size of ram.
</para>
</sect3>

<sect3 id="max_swap_size">
<title>How large <emphasis>can</emphasis> my swap space be?</title>

<para>
		Currently, the maximum size of a swap partition is
		architecture-dependent. For i386, m68k, ARM and PowerPC, it is
		"officially" 2Gb. It is 128Gb on alpha, 1Gb on sparc, and 3Tb on
		sparc64. An opteron on the 2.6 kernel can write to a 16 Tb swap
		partition. For linux kernels 2.1 and earlier, the limit is
		128Mb. The partition may be larger than 128 MB, but excess space
		is never used. If you want more than 128 MB of swap for a 2.1
		and earlier kernel, you have to create multiple swap partitions
		(8 max). After 2.4, 32 swap areas are "officially" possible. See
		setting up swap for details.
</para>

<para><emphasis>footnote:</emphasis> 
	"official" max swap size: With kernel 2.4, the limit is 64 swap spaces at a
	maximum of 64Gb each, although this is not reflected in the man page
	for <command>mkswap</command>. With the 64 bit opteron on the 2.6 kernel, 128 swap
	areas are permitted, each a whopping 16 Tb! (thanks to Peter Chubb
	for the calculation)
</para>

</sect3>

<sect3 id="SwapPlacement">
<title>Where should I put my swap space?</title>
<para>
The short answer is anywhere is fine. However, if you are
interested in extracting as much speed as possible, there are
two basic strategies (other than buying more RAM).
</para>
<para>
<itemizedlist>
<listitem><para>Split the swap space across multiple drives, or at least on the
			    drive you write to least.
           </para>
</listitem>
<listitem><para>Put each swap partition on the outer tracks.
           </para>
</listitem>
</itemizedlist>
</para>

<para> 
	Here are the considerations:
</para>

<itemizedlist>
<listitem>
	<para>
		If you have a disk with many heads and one with less heads and
		both are identical in other parameters, the disk with many heads
		will be faster. Reading data from different heads is fast, since
		it is purely electronic. Reading data from different tracks is
		slow, since it involves physically moving the head.
	</para>
	
	<para>
		It follows then that writing swap on a separate drive will be
		faster than moving the head back and forth on a single drive.
	</para>
</listitem>

<listitem>
	<para><emphasis>Placement</emphasis>: 
		Older disks have the same number of sectors on all tracks. With
		these disks it will be fastest to put your swap in the middle of
		the disks, assuming that your disk head will move from a random
		track towards the swap area.
	</para>
</listitem>

<listitem>
	<para> 
		Newer disks use ZBR (zone bit recording). They have more sectors
		on the outer tracks. With a constant number of rpms, this yields
		a far greater performance on the outer tracks than on the inner
		ones. Put your swap on the fast tracks. (In general,
		low-numbered cylinders are associated low partition numbers.
		However, see Kristian's more recent <ulink
		url="http://lissot.net/partition/mapping.html">comments</ulink>
		on this issue. -Tony)
	</para>
</listitem>

<listitem>
	<para> <emphasis>Usage</emphasis>: 
		Of course your disk head will not move randomly. If you have swap
		space in the middle of a disk between a constantly busy home
		partition and an almost unused archive partition, you would be
		better of if your swap were near the home partition for
		even shorter head movements. You would be even better off, if you
		had your swap on another otherwise unused disk, though.
	</para>
</listitem>

<listitem>
	<para> <emphasis>Striping</emphasis>: 
		Speed can be increased by writing to multiple swap areas
		simultaneously. Swap spaces with the same priority will be
		written to like a RAID. See <xref linkend="multiple_swap_areas" />.
</para>
</listitem>
</itemizedlist>

<para><emphasis>Summary:</emphasis> 
	Put your swap on a fast disk with many heads that is not busy doing
	other things. If you have multiple disks: Split swap and scatter it
	over all your disks or even different controllers.
</para>

</sect3>

</sect2>
</sect1>




<!-- _________________________________________________________________ -->

<sect1 id="fdisk_partitioning">
 <title>Partitioning with fdisk</title>

<para>
This section shows you how to actually partition your hard drive with
the <command>fdisk</command> utility. Linux allows only 4 primary
partitions. You can have a much larger number of logical partitions by
sub-dividing one of the primary partitions. Only one of the primary
partitions can be sub-divided.
</para>

<para>
<emphasis>Examples:</emphasis>
<orderedlist>
   <listitem>
	   <para>
	   		Four primary partitions (see <xref linkend="primary-example" />)
	   </para>
   </listitem>
   <listitem>
	   <para>
	  		 Mixed primary and logical partitions (see <xref linkend="mixed" />)
	   </para>
   </listitem>
</orderedlist>
</para>

<sect2 id="fdisk">
<title>fdisk usage</title>
<para>
	<command>fdisk</command> is started by typing (as root)
	<userinput><command>fdisk</command>
	<replaceable>device</replaceable></userinput> at the command prompt.
	<replaceable>device</replaceable> might be something like <filename
	class="devicefile">/dev/hda</filename> or <filename
	class="devicefile">/dev/sda</filename> (see <xref
	linkend="NamingConvention"/>). The basic
	<command>fdisk</command> commands you need are:
</para>
<para>
	<userinput>p</userinput>
	print the partition table
</para>
<para>
	<userinput>n</userinput>
	create a new partition
</para>
<para>
        <userinput>d</userinput>
        delete a partition
</para>
<para>
	<userinput>q</userinput>
	quit without saving changes
</para>
<para>
	<userinput>w</userinput>
	write the new partition table and exit
</para>

<para>
Changes you make to the partition table do not take effect until you issue the write (w) command.
Here is a sample partition table:
<programlisting>
Disk /dev/hdb: 64 heads, 63 sectors, 621 cylinders
Units = cylinders of 4032 * 512 bytes
 
   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1   *         1       184    370912+  83  Linux
/dev/hdb2           185       368    370944   83  Linux
/dev/hdb3           369       552    370944   83  Linux
/dev/hdb4           553       621    139104   82  Linux swap
</programlisting>

The first line shows the geometry of your hard drive. It may not be
physically accurate, but you can accept it as though it were. The hard
drive in this example is made of 32 double-sided platters with one
head on each side (probably not true). Each platter has 621 concentric
tracks. A 3-dimensional track (the same track on all disks) is called
a cylinder. Each track is divided into 63 sectors. Each sector
contains 512 bytes of data. Therefore the block size in the partition
table is 64 heads * 63 sectors * 512 bytes er...divided by 1024. (See
<xref linkend="BlockSize" /> for discussion on
problems with this calculation.) The start and end values are cylinders.
</para>

</sect2>


<sect2 id="primary-example">
<title>Four primary partitions</title>

<para>
	<emphasis>The overview:</emphasis> 
</para>
<para>
	Decide on the size of your swap space (see <xref linkend="SwapSize"
	/>) and where it ought to go (see <xref linkend="SwapPlacement" />).
	Divide up the remaining space for the three other partitions.
</para>
<para>
Example:
</para>
<para>
I start fdisk from the shell prompt:
<programlisting>
# <userinput><command>fdisk</command> <filename class="devicefile">/dev/hdb</filename></userinput> 
</programlisting>

which indicates that I am using the second drive on my IDE controller.
(See <xref linkend="names" />.) When I print the (empty) partition table,
I just get configuration information.

<programlisting>
Command (m for help): <userinput>p</userinput>

Disk /dev/hdb: 64 heads, 63 sectors, 621 cylinders
Units = cylinders of 4032 * 512 bytes
</programlisting>
I knew that I had a 1.2Gb drive, but now I really know: 64 * 63 * 512
* 621 = 1281982464 bytes. I decide to reserve 128Mb of that space for
swap, leaving 1153982464. If I use one of my primary partitions for
swap, that means I have three left for ext2 partitions. Divided
equally, that makes for 384Mb per partition. Now I get to work.

<programlisting>
Command (m for help): <userinput>n</userinput>
Command action
   e   extended
   p   primary partition (1-4)
<userinput>p</userinput>
Partition number (1-4): <userinput>1</userinput>
First cylinder (1-621, default 1):<userinput>&lt;RETURN&gt;</userinput>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-621, default 621): <userinput>+384M</userinput>
</programlisting>

Next, I set up the partition I want to use for swap:

<programlisting>
Command (m for help): <userinput>n</userinput>
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): <userinput>2</userinput>
First cylinder (197-621, default 197):<userinput>&lt;RETURN&gt;</userinput>
Using default value 197
Last cylinder or +size or +sizeM or +sizeK (197-621, default 621): <userinput>+128M</userinput>
</programlisting>

Now the partition table looks like this:

<programlisting>
   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1             1       196    395104   83  Linux
/dev/hdb2           197       262    133056   83  Linux
</programlisting>

I set up the remaining two partitions the same way I did the first.
Finally, I make the first partition bootable:

<programlisting>
Command (m for help): <userinput>a</userinput>
Partition number (1-4): <userinput>1</userinput>
</programlisting>

And I make the second partition of type swap:

<programlisting>
Command (m for help): <userinput>t</userinput>
Partition number (1-4): <userinput>2</userinput>
Hex code (type L to list codes): <userinput>82</userinput>
Changed system type of partition 2 to 82 (Linux swap)      
Command (m for help): <userinput>p</userinput>
</programlisting>

The end result:

<programlisting>
Disk /dev/hdb: 64 heads, 63 sectors, 621 cylinders
Units = cylinders of 4032 * 512 bytes
 
   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1   *         1       196    395104+  83  Linux
/dev/hdb2           197       262    133056   82  Linux swap
/dev/hdb3           263       458    395136   83  Linux
/dev/hdb4           459       621    328608   83  Linux          
</programlisting>

Finally, I issue the write command (w) to write the table on the disk.
</para>
<para>
Side topics:
<itemizedlist>
  <listitem><para><xref linkend="swap" /></para></listitem>
  <listitem><para><xref linkend="formating" /></para></listitem>
  <listitem><para><xref linkend="mounting" /></para></listitem>
</itemizedlist>

</para>
</sect2>

<sect2 id="mixed">
<title>Mixed primary and logical partitions</title>

<para>
<emphasis>The overview:</emphasis> create one use one of the primary
partitions to house all the extra partitions. Then create logical
partitions within it. Create the other primary partitions before or
after creating the logical partitions.
</para>
<para>
Example:
</para>
<para>
I start fdisk from the shell prompt:

<programlisting>
# fdisk /dev/sda
</programlisting>

which indicates that I am using the first drive on my SCSI chain. 
(See <xref linkend="names" />.)
</para>

<para>
First I figure out how many partitions I want. I know my drive has a
183Gb capacity and I want 26Gb partitions (because I happen to have
back-up tapes that are about that size).
</para>
<para>
	<literal>183Gb / 26Gb = ~7</literal>
</para>
<para>
so I will need 7 partitions. Even though fdisk accepts partition sizes
expressed in Mb and Kb, I decide to calculate the number of cylinders
that will end up in each partition because fdisk reports start and
stop points in cylinders.  I see when I enter fdisk that I have 22800
cylinders.

<programlisting>
&gt; The number of cylinders for this disk is set to 22800.  There is
&gt; nothing wrong with that, but this is larger than 1024, and could in
&gt; certain setups cause problems with: 1) software that runs at boot
&gt; time (e.g., LILO) 2) booting and partitioning software from other
&gt; OSs  (e.g., DOS FDISK, OS/2 FDISK)
</programlisting>

So, 22800 total cylinders divided by seven partitions is 3258
cylinders. Each partition will be about 3258 cylinders long. I ignore
the warning msg because this is not my boot drive (<xref linkend="requirements" />).
</para>
<para>
 Since I have 4 primary partitions, 3 of them can be 3258
long. The extended partition will have to be (4 * 3258), or 13032,
cylinders long in order to contain the 4 logical partitions.
</para>
<para>
I enter the following commands to set up the first of the 3 primary
partitions (stuff I type is bold ):

<programlisting>
Command (m for help): <userinput>n</userinput>
Command action
   e   extended
   p   primary partition (1-4)
<userinput>p</userinput>
Partition number (1-4): <userinput>1</userinput>
First cylinder (1-22800, default 1): <userinput>&lt;RETURN&gt;</userinput>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-22800, default 22800): <userinput>3258</userinput>
</programlisting>

The last partition is the extended partition:

<programlisting>
Partition number (1-4): <userinput>4</userinput>
First cylinder (9775-22800, default 9775): <userinput>&lt;RETURN&gt;</userinput>
Using default value 9775
Last cylinder or +size or +sizeM or +sizeK (9775-22800, default 22800): <userinput>&lt;RETURN&gt;</userinput>
Using default value 22800
</programlisting>

 The result, when I issue the print table command is:

<programlisting>
/dev/sda1             1      3258  26169853+  83  Linux
/dev/sda2          3259      6516  26169885   83  Linux
/dev/sda3          6517      9774  26169885   83  Linux
/dev/sda4          9775     22800 104631345    5  Extended
</programlisting>

Next I segment the extended partition into 4 logical partitions,
starting with the first logical partition, into 3258-cylinder
segments.  The logical partitions automatically start from /dev/sda5.

<programlisting>
Command (m for help):  <userinput>n</userinput>
First cylinder (9775-22800, default 9775): <userinput>&lt;RETURN&gt;</userinput>
Using default value 9775
Last cylinder or +size or +sizeM or +sizeK (9775-22800, default 22800): 13032
</programlisting>

The end result is:

<programlisting>
   Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1      3258  26169853+  83  Linux
/dev/sda2          3259      6516  26169885   83  Linux
/dev/sda3          6517      9774  26169885   83  Linux
/dev/sda4          9775     22800 104631345    5  Extended
/dev/sda5          9775     13032  26169853+  83  Linux
/dev/sda6         13033     16290  26169853+  83  Linux
/dev/sda7         16291     19584  26459023+  83  Linux
/dev/sda8         19585     22800  25832488+  83  Linux
</programlisting>

Finally, I issue the write command (w) to write the table on the disk.
To make the partitions usable, I will have to format (<xref linkend="formating" />)
each partition and then mount (<xref linkend="mounting" />) it.
</para>
</sect2>

<sect2 id="submitted">
<title>Submitted Examples</title>
<para>
 I'd like to submit my partition layout, because it works well with
any distribution of Linux (even big RPM based ones).

I have one hard drive that ... is 10 gigs, exactly. Windows 
can't see above 9.3 gigs of it, but Linux can see it all, and use it 
all. It also has much more than 1024 cylenders.

<table frame="all">
  <title>Partition layout example</title>
<tgroup cols="3">
  <colspec colname="c1" />
  <colspec colname="c2" />
  <colspec colname="c3" />
<thead>
  <row>
    <entry>Partition</entry>
    <entry>Mount point</entry>
    <entry>Size</entry>
  </row>
</thead>
<tbody>
  <row>
    <entry>/dev/hda1</entry>
    <entry>/boot</entry>
    <entry>(15 megs)</entry>
  </row>
  <row>
    <entry>/dev/hda2</entry>
    <entry>windows 98 partition</entry>
    <entry>(2 gigs)</entry>
  </row>
  <row>
    <entry>/dev/hda3</entry>
    <entry>extended</entry>
    <entry>(N/A)</entry>
  </row>
  <row>
    <entry>/dev/hda5</entry>
    <entry>swap space</entry>
    <entry>(64 megs)</entry>
  </row>
  <row>
    <entry>/dev/hda6</entry>
    <entry>/tmp</entry>
    <entry>(50 megs)</entry>
  </row>
  <row>
    <entry>/dev/hda7</entry>
    <entry>/</entry>
    <entry>(150 megs)</entry>
  </row>
  <row>
    <entry>/dev/hda8</entry>
    <entry>/usr</entry>
    <entry>(1.5 gigs)</entry>
  </row>
  <row>
    <entry>/dev/hda9</entry>
    <entry>/home</entry>
    <entry>(rest of drive)</entry>
  </row>
</tbody>
</tgroup>
</table>

I test new kernels for the USB mass storage, so that explains the large 
/boot partition.  I install LILO into the MBR, and by default I boot 
windows (I'm not the only one to use this computer).
</para>
<para>
I also noticed that you don't have any REAL examples of partition 
tables, and for newbies I HIGHLY suggest putting quite a few up. I'm 
freshly out of the newbie stage, and partitioning was what messed me up 
the most.
</para>
<para>
 <ulink url="mailto:valkor@qx.net">Valkor</ulink>
</para>
<!--
<para>
Another sample partition table listing:
<programlisting>
   Device Boot    Start       End    Blocks   Id  System
/dev/hdb1   *         1       128   1028128+  83  Linux
/dev/hdb2           129       524   3180870    5  Extended
/dev/hdb5           129       256   1028128+  83  Linux
/dev/hdb6           257       289    265041   82  Linux swap
/dev/hdb7           290       302    104391   83  Linux
/dev/hdb8           303       524   1783183+  83  Linux
</programlisting>
</para>
-->

</sect2>
</sect1>




<!-- _____________________________________________________________ -->


<sect1 id="labels">
<title>Labels</title>
<para>
	In linux, hard drives are referred to as devices, and devices are
	pseudo files in <filename class="directory">/dev</filename>. For
	example, the first partition of the second lowest numbered SCSI
	drive is <filename>/dev/sdb1</filename>. If the drive referred to as
	<filename>/dev/sda</filename> is removed from the chain, then the
	latter partition is automatically renamed
	<filename>/dev/sda1</filename> at reboot.
</para>

<sect2 id="volumelabels"><title>Volume Labels</title>
<para>
	Volume labels make it possible for partitions to retain a consistent
	name regardless of where they are connected, and regardless of
	whatever else is connected. Labels are not mandatory for a linux
	volume. Each can be a maximum of 16 characters long.
</para>

<para>
	There are three tools to make volume labels: mke2fs, tune2fs and e2label.
</para>

<sect3 id="labelinvocation"><title>Simple Invocation</title>
<para>
	<command>e2label</command> <filename class="devicefile">/dev/hdb1</filename> <filename class="directory">pubsw</filename>
</para>
<para>
	<command>tune2fs</command> -L <filename class="directory">pubsw</filename> <filename class="devicefile">/dev/hdb1</filename> 
</para>
<para>
	Either of thse two commands will label the first partition of the
	second drive "pubsw". That label stays with that particular
	partition, even if the drive is moved to another controller or even
	another computer.
</para>

<para>
	<command>mke2fs</command>	<filename class="directory">pubsw</filename> 
			<filename class="devicefile">/dev/hdb1</filename> 
</para>
<para>
	<command>mke2fs</command> -L	<filename class="directory">pubsw</filename> 
				<filename class="devicefile">/dev/hdb1</filename> 
</para>
<para>
	will do the same thing as the first two commands - after they make
	the file system. This means that either of these last two commands
	will delete any existing data in the partition.
</para>


</sect3>


<sect3 id="howtousevolumelabels"><title>How to Use</title>
<para>
	Here is a sample fstab. This is a text file located in /etc, which
	is usually set up during the installation of the operating system.
	it describes where each partition wil be mounted, and how it will be
	mounted. It can be modified by you, either through a utility or
	manually, when you add/remove devices.
</para>

<para>
<programlisting>
LABEL=/        /                    ext3    defaults        1 1
LABEL=/boot    /boot                ext2    defaults        1 2
none           /dev/pts             devpts  gid=5,mode=620  0 0
none           /dev/shm             tmpfs   defaults        0 0
LABEL=HOME     /home                ext3    defaults        1 2
none           /proc                proc    defaults        0 0
none           /sys                 sysfs   defaults        0 0
LABEL=/usr     /usr                 ext3    defaults        1 2
/dev/hdc1      /k-space             ext3    defaults        1 2
/dev/hda6      swap                 swap    defaults        0 0
/dev/hdd       /media/cdrecorder    auto    pamconsole,ro,exec,noauto,managed 0 0
/dev/fd0       /media/floppy        auto    pamconsole,exec,noauto,managed 0 0
</programlisting>
</para>

<para>
	The leftmost column lists devices and the second column lists mount
	points. This example contains a mixture of devices and labels. The
	master drive of the second controller is always mounted on <filename
	class="directory">/k-space</filename>.
	The partition labeled "HOME" is always mounted on <filename
	class="directory">/home</filename>, regardless
	of which drive it is on or which partition number it has. Notice
	that it is permissible to use mount points as labels, such as "/usr"
</para>


</sect3>
</sect2>


<sect2 id="devicelabels"><title>Device Labels</title>
<para>
	<command>devlabel</command> is a script which creates symbolic links to devices. For
	example,
</para>
<para>
	<command>devlabel</command> -d <filename class="devicefile">/dev/hdb1</filename>
			 -s <filename class="directory">/dev/home</filename>
</para>
<para>
	will create a link from <filename
	class="devicefile">/dev/hdb1</filename> to <filename
	class="directory">/dev/home</filename>. Crucially, it stores a
	unique identifier for the hardware that was on <filename
	class="devicefile">/dev/hdb1</filename> and stores that identifier along with
	the link name that you specified in /etc/sysconfig/devlabel. If the
	hardware is later moved to <filename class="directory">/dev/hdc1</filename>,
	its unique identifier will be queried (using
	/usr/bin/partition_uuid), matched to its entry in
	/etc/sysconfig/devlabel, and again linked to <filename
	class="directory">/dev/home</filename>.
</para>

</sect2>

</sect1>



<!-- _____________________________________________________-->


<sect1 id="formatting">
<title>Formatting an ext2/3 partition</title>
<para>
	When a hard drive is partitioned, it is mapped into sections, but
	the sections are empty. It is like a newly constructed library;
	shelves, signs, and a card catalogue system must be put in place
	before the books are put away.</para>

<para>
	The organizational structure inside a partition is called a file
	system. With Linux, the standard file system is ext2 and ext3. The
	ext3 file system is ext2, plus a log of disk writes called a
	journal. The journal allows the system to recover quickly from
	accidental power outages, among other things.
</para>

<para>
	The principal tool for making an ext2/3 file system in a partition
	is <command>mke2fs</command>. It is usually found in <filename
	class="directory">/sbin</filename>. <command>mkfs.ext2</command> and
	<command>mkfs.ext3</command> are frontends which pass specific
	options to <command>mke2fs</command>.
</para>

<sect2 id="formatting-invocation"><title>Simple Invocation</title>
<para>
	<command>mke2fs</command> <filename class="partition">/dev/hdb1</filename> 
</para>
<para>
	<command>mkfs.ext2</command> <filename class="partition">/dev/hdb1</filename> 
</para>
<para>
	both of which make an ext2 file system on the first partition of the second drive, and
</para>

<para>
	<command>mke2fs</command>	-j <filename class="partition">/dev/hdb1</filename> 
</para>
<para>
	<command>mkfs.ext3</command> <filename class="partition">/dev/hdb1</filename> 
</para>
<para>
	make an ext3 file system.
</para>


</sect2>


<sect2 id="reservedblocks"><title>Reserved blocks</title>
<para>
	The -m option is probably the one of most use to non-experts. If the
	file system becomes filled and there is no more space to write, it
	is basically unusable because the operating system is constantly
	writing to disk. By default, five percent of the partition is
	reserved for use by the root user. This allows root to conduct
	administrative activities on the partition and perhaps move some
	data off. However, this is most critical when the partition contains
	/ or home directories. For pure data partitions, this is just lost
	space. Five percent of a 250Gb partition is 12.5 Gb. Especially in
	the case of large partitions, it is safe to set the reserved space
	to the minimum, which is one percent.
</para>

<para>
	<command>mkfs.ext3</command> -m 1<filename class="devicefile">/dev/hdb1</filename> 
</para>

<para>
	creates a file system with only 1% of its space reserved for the
	root user. tune2fs -m can be used to adjust the reserved blocks
	after data is loaded on the partition.
</para>


</sect2>




</sect1>


<!-- ______________________________________________________ -->

<sect1 id="recovering">
<title>Recovering a Deleted Partition Table</title>
<!--Tony, 1 Sept 00--> 

<para>
	Below are instructions for manually recovering a deleted partition
	table. There are utilities such as <ulink
	url="http://www.stud.uni-hannover.de/user/76201/gpart">gpart</ulink>
	or <ulink
	url="http://www.cgsecurity.org/index.html?testdisk.html">TestDisk
	</ulink > which can make this task considerably easier. If you are
	reading this, however, because you have run out of luck, this is
	what you will have to do:
</para>

<para>     
<orderedlist>

  <listitem>
  <para>Make a partition that is at least as big as your first partition
  was. You can make it larger than the original partition by any
  amount. If you underestimate, there will be much wailing and
  gnashing of teeth.
<programlisting>
Command (m for help): <userinput>n</userinput>
Command action
   e   extended
   p   primary partition (1-4)
<userinput>p</userinput>
Partition number (1-4): <userinput>1</userinput>
First cylinder (1-23361, default 1): <userinput>&lt;RETURN&gt;</userinput>
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-22800, default 22800): <userinput>13032</userinput>

Command (m for help): <userinput>w</userinput>
</programlisting>
  </para>
  </listitem>

  <listitem>
  <para>
  Run <command>dumpe2fs</command> on the first partition and grep out the block count.
  </para>
  <para>
  Example:
      <programlisting>
           % dumpe2fs /dev/sda1 | grep "Block count:"
           Block count:              41270953
      </programlisting>
      If you are uncertain about this value, repeat Step 1 with a
      bigger partition size. If the block count changes, then you
      underestimated the size of the original partition. Repeat Step
      1 until you get a stable block count.
  </para>
  </listitem>

  <listitem>
  <para>
  Remove the partition you just created
      <programlisting>
         Command (m for help): <userinput>d</userinput>
         Partition number (1-4): <userinput>1</userinput>
      </programlisting>
  </para>
  </listitem>

  <listitem id="BlockSize">
  <para>Make a new partition with the exact size you got from the block
  count. Since you cannot enter block size in fdisk, you need to
  figure out how many cylinders to request. Here is the formula:
</para>
<para>
<programlisting>
  (number of needed cylinders) = (number of blocks) / (block size)

  (block size) = (unit size) / 1024

  (unit size) = (number of heads) * (number of sectors/cylinder) * (number of bytes/sector)
</programlisting>

</para>
<para>
    Consider the following example, where a hard drive has been partitioned into four primary
       partitions of 1, 2, 4, and 8 cylinders.

<programlisting>
disk /dev/sda: 16 heads, 63 sectors, 23361 cylinders
Units = cylinders of 1008 * 512 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/sda1             1         2       976+  83  Linux
/dev/sda2             3         5      1512   83  Linux
/dev/sda3             6        10      2520   83  Linux
/dev/sda4            11        19      4536   83  Linux
</programlisting>

<command>fdisk</command> provides the configuration information I need in the head of the output.

       The unit size is <userinput>516096</userinput> ( <userinput>16</userinput> heads * <userinput>63</userinput> sectors/cyl * <userinput>512</userinput> bytes/sector ). 

       The block size is <userinput>504</userinput> ( <userinput>516096 / 1024</userinput> ). 

       The number of needed cylinders for the second partition is therefore <userinput>3</userinput> ( <userinput>1512</userinput> blocks <userinput>/
       504</userinput> ). 

       The partition table shows that this is indeed the case: the first cylinder is <userinput>3</userinput>, the second <userinput>4</userinput>, and
       the last is <userinput>5</userinput>, for a total of three cylinders. 

       The number of needed cylinders for the third partition is calculated similarly: <userinput>2520</userinput> blocks
       <userinput>/ 504 = 5</userinput>, which corresponds to blocks <userinput>6,7,8,9,10</userinput> 
       . 

       Notice that this calculation does not work for the first partition because the block count is
       wrong ( <userinput>976</userinput> instead of <userinput>1008</userinput> ). The plus sign indicates that not all the blocks are included in
       the fdisk value. When you try the calculation ( <userinput>976 / 504</userinput> ) you get <userinput>1.937</userinput>. Knowing that
       the number of cylinders must be an integer, you can simply round up. 
  </para>
  
  </listitem>

  <listitem>
  <para>Run <command>e2fsck</command> on it to verify that you can read the new partition.
  </para>
  </listitem>

  <listitem>
  <para>
  Repeat Steps 1-5 on remaining partitions.
  </para>
  </listitem>

</orderedlist>

Remount your partitions. Amazingly, all of your data will be there.
</para>
<para>
Credit goes to: Mike Vevea, jedi sys admin, for providing the basic strategy.
</para>
</sect1>

<!-- _________________________________________________________________ -->

<sect1 id="setting_up_swap">
<title>Setting Up Swap Space</title>

<sect2 id="swap_partitions">
<title>Swap Files</title> 
<para>
	Normally, there are only two steps to setting up swap space,
	creating the partition and adding it to /etc/fstab. A typical fstab
	entry for a swap partition at /dev/hda6 would look like this:
</para>
<programlisting>
/dev/hda6	swap	swap	defaults	0	0
</programlisting>
<para>
	The next time you reboot, the initialization scripts will activate
	it automatically and there's nothing more to be done.
</para>
<para>
	However, if you want to make use of it right away, you'll need to
	activate it maually. As root, type:
</para>

<programlisting>
<userinput><command>mkswap</command> -f <filename class="partition">/dev/hda6</filename></userinput>
<userinput><command>swapon</command> <filename class="partition">/dev/hda6</filename></userinput>
</programlisting>
</sect2>


<sect2 id="swapfiles">
<title>Swap Files</title> 
<para>
	There might be times when you've run out of swap space and it is not
	practical to repartition a drive or add a new one. In this case, you
	can use a regular file in an ordinary partition. All you have to do
	is create a file of the size you want
</para>
<para>

<userinput><command>dd</command> if=/dev/zero of=/var/my_swap bs=1024 count=131072</userinput>
</para>

<para>
	and activate it
</para>

<programlisting>
	<userinput><command>mkswap</command> -f /var/my_swap</userinput>
	<userinput><command>swapon</command> /var/my_swap</userinput>
</programlisting>

<para>
	This invocation creates a file called <filename>my_swap</filename>
	in <filename class="directory">/var</filename>. It is 128 Mb long
	(128 x 1024 = 131072). Initially, it is filled with zeros. However,
	<command>mkswap</command> marks it as swap space and <command>swapon</command> tells
	the kernel to start using it as swap space. When you are done with
	it,
</para>
<programlisting>
<userinput><command>swapoff</command> /var/my_swap</userinput>
<userinput><command>rm</command> /var/my_swap</userinput>
</programlisting>

</sect2>


<sect2 id="multiple_swap_areas">
<title>Multiple Swap Areas</title> 
<para>
	More than one swap partition can be used on the same system.
	Consider an example fstab where there is a single swap partition:
</para>
<programlisting>
/dev/hda5   /        ext3   defaults        1	1
/dev/hda1   /boot    ext2   defaults        1	2
none        /dev/pts devpts gid=5,mode=620  0	0
none        /proc    proc   defaults        0	0
/dev/hda7   /usr     ext3   defaults        1	2
/dev/hda6   swap     swap   defaults        0	0
</programlisting>

<para>
	Imagine replacing the entry for the swap partition with these three lines:
</para>
<programlisting>
/dev/hda6   none    swap    sw,pri=3    0	0
/dev/hdb2   none    swap    sw,pri=2    0	0
/dev/hdc2   none    swap    sw,pri=1    0	0
</programlisting>
<para>
	This configuration would cause the kernel to use /dev/hda6 first. it
	has the highest priority assigned to it (pri=3). The maximum
	priority can be 32767 and the lowest 0. If that space were to max
	out, the kernel would start using /dev/hdb2, and on to /dev/hdc2
	after that. Why such a configuration? Imagine that the newest
	(fastest) drives are given the highest priority. This will minimize
	speed loss as swap space usage grows.
</para>
<para>
	It is possible to write to all three simulataneously. If each has
	the same priority, the kernel will write to them much like a RAID,
	with commensurate speed increases.
</para>

<programlisting>
/dev/hda6   none   swap   sw,pri=3   0   0
/dev/hdb2   none   swap   sw,pri=3   0   0
/dev/hdc2   none   swap   sw,pri=3   0   0
</programlisting>

<para>
	Notice that these three partitions are on separate drives, which is
	ideal in terms of speed enhancement.
</para>
</sect2>
</sect1>

<!-- _________________________________________________________________ -->

<sect1 id="appendix">
<title>Appendix</title> 

<sect2 id="formating">
<title>Formating Partitions</title> 
<!--Tony, 1 May 00--> 
<para>
At the shell prompt, I begin making the file systems on my
partitions.  Continuing with the example in (see <xref linkend="mixed" />),
this is:

<programlisting>
# mke2fs /dev/sda1
</programlisting>
</para>

<para>
I need to do this for each of my partitions, but not for <filename
class="partition">/dev/sda4</filename> (my extended partition).

Linux supports types of file systems other than ext2. You can find out
what kinds your kernel supports by looking in: 
<filename class="headerfile">/usr/src/linux/include/linux/fs.h</filename>
</para>

<para>
	The most common file systems can be made with programs in <filename
	class="directory">/sbin</filename> that start with "mk" like
	<command>mkfs.msdos</command> and <command>mke2fs</command>.
</para>
</sect2>


<sect2 id="swap">
<title>Activating Swap Space</title>
<para>
<!--Tony, 1 May 00-->
To set up a swap partition:

<programlisting>
# mkswap -f /dev/hda5
</programlisting>

To activate the swap area:

<programlisting>
# swapon  /dev/hda5
</programlisting>

Normally, the swap area is activated by the initialization scripts at 
boot time.
</para>

</sect2>

<sect2 id="mounting">
<title>Mounting Partitions</title>
<para>
<!--Tony, 1 May 00-->
Mounting a partition means attaching it to the linux file system. To
mount a linux partition:

<programlisting>
# mount -t ext2 /dev/sda1 /opt
</programlisting>

<variablelist>
  <varlistentry>
    <term>-t ext2</term>
    <listitem>
    <para>
    File system type. Other types you are likely to use are:
      <itemizedlist>
	 <listitem><para>ext3 (journaling sile system based on ext2)</para></listitem>
	 <listitem><para>msdos (DOS)</para></listitem>
	 <listitem><para>hfs (mac)</para></listitem>
	 <listitem><para>iso9660 (CDROM)</para></listitem>
	 <listitem><para>nfs (network file system)</para></listitem>
      </itemizedlist>
    </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>/dev/sda1</term>
    <listitem>
    <para>
    Device name. Other device names you are likely to use:
      <itemizedlist>
	 <listitem><para><filename class="partition">/dev/hdb2</filename> (second partition in second IDE drive)</para></listitem>
	 <listitem><para><filename class="devicefile">/dev/fd0</filename>  (floppy drive A)</para></listitem>
	 <listitem><para><filename class="devicefile">/dev/cdrom</filename>  (CDROM)</para></listitem>
      </itemizedlist>
    </para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>/opt</term>
    <listitem>
    <para>
		mount point. This is where you want to "see" your partition.
		When you type <userinput>ls /opt</userinput>, you can see what
		is in <filename class="partition">/dev/sda1</filename>. If there
		are already some directories and/or files under <filename
		class="partition">/opt</filename>, they will be invisible after
		this mount command.
    </para>
    </listitem>
  </varlistentry>
</variablelist>
</para>

</sect2>

<sect2 id="fragmentation">
<title>Some facts about file systems and fragmentation</title>

<para>
Disk space is administered by the operating system in units of
blocks and fragments of blocks. In ext2, fragments and blocks
have to be of the same size, so we can limit our discussion to
blocks.
</para>
<para>
Files come in any size. They don't end on block boundaries.  So
with every file a part of the last block of every file is
wasted. Assuming that file sizes are random, there is
approximately a half block of waste for each file on your disk.
Tanenbaum calls this "internal fragmentation" in his book
"Operating Systems".
</para>
<para>
You can guess the number of files on your disk by the number of
allocated inodes on a disk. On my disk
<programlisting>
# df -i
Filesystem           Inodes   IUsed   IFree  %IUsed Mounted on
/dev/hda3              64256   12234   52022    19%  /
/dev/hda5              96000   43058   52942    45%  /var
</programlisting>

	there are about 12000 files on <filename
	class="directory">/</filename> and about 44000 files on <filename
	class="directory">/var</filename>.  At a block size of 1 KB, about
	6+22 = 28 MB of disk space are lost in the tail blocks of files. Had
	I chosen a block size of 4 KB, I had lost 4 times this space.
</para>
<para>
	Data transfer is faster for large contiguous chunks of data, though.
	That's why ext2 tries to preallocate space in units of 8 contigous
	blocks for growing files. Unused preallocation is released when the
	file is closed, so no space is wasted.
</para>
<para>
	Noncontiguous placement of blocks in a file is bad for performance,
	since files are often accessed in a sequential manner. It forces the
	operating system to split a disk access and the disk to move the
	head. This is called "external fragmentation" or simply
	"fragmentation" and is a common problem with MS-DOS file systems. In
	conjunction with the abysmal buffer cache used by MS-DOS, the
	effects of file fragmentation on performance are very noticeable.
	DOS users are accustomed to defragging their disks every few weeks
	and some have even developed some ritualistic beliefs regarding
	defragmentation.
</para>
<para>
	None of these habits should be carried over to Linux and ext2. Linux
	native file systems do not need defragmentation under normal use and
	this includes any condition with at least 5% of free space on a
	disk. There is a defragmentation tool for ext2 called defrag, but
	users are cautioned against casual use. A power outage during such
	an operation can trash your file system. Since you need to back up
	your data anyway, simply writing back from your copy will do the
	job.
</para>
<para>
	The MS-DOS file system is also known to lose large amounts of disk
	space due to internal fragmentation. For partitions larger than 256
	MB, DOS block sizes grow so large that they are no longer useful
	(This has been corrected to some extent with FAT32). Ext2 does not
	force you to choose large blocks for large file systems, except for
	very large file systems in the 0.5 TB range (that's terabytes with 1
	TB equaling 1024 GB) and above, where small block sizes become
	inefficient. So unlike DOS there is no need to split up large disks
	into multiple partitions to keep block size down.
</para>
<para>
	Use a 1Kb block size if you have many small files. For large
	partitions, 4Kb blocks are fine.
</para>
</sect2>
</sect1>
</article>
