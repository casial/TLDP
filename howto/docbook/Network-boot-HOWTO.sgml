<!doctype article public "-//OASIS//DTD DocBook V3.1//EN"
[
  <!entity bbpmail "bbp@via.ecp.fr">

  <!entity logilab "Logilab">
  <!entity logilaburl "http://www.logilab.org">

  <!entity etb "etherboot">
  <!entity etburl "http://etherboot.sourceforge.net">

  <!entity ltsp "linux terminal server project">
  <!entity ltspurl "http://www.ltsp.org">

  <!entity vmware "VMWare">
  <!entity vmwareurl "http://www.vmware.com">

  <!entity plex86 "plex86">
  <!entity plex86url "http://www.plex86.org">

  <!entity imggenurl "http://www.ltsp.org/contrib/">

  <!entity disklesshowtourl "http://www.linuxdoc.org/HOWTO/Diskless-HOWTO.html">

  <!entity disklessrootnfshowtourl "http://www.linuxdoc.org/HOWTO/Diskless-root-NFS-HOWTO.html">

  <!entity bootdiskhowtourl "http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html">

  <!entity powerup2bashurl "http://www.linuxdoc.org/HOWTO/From-PowerUp-to-bash-prompt-HOWTO.html">

  <!entity thinclienturl "http://www.linuxdoc.org/HOWTO/Thin-Client-HOWTO.html">

  <!entity cdwritingurl "http://www.linuxdoc.org/HOWTO/CD-Writing-HOWTO.html">

  <!entity ntb "netboot">
  <!entity ntburl "http://netboot.sourceforge.net">

  <!entity clusternfs "clusternfs">
  <!entity clusternfsurl "http://clusternfs.sourceforge.net">

  <!entity grub "GRUB">
  <!entity gruburl "http://www.gnu.org/software/grub/">

  <!entity clientsrootbuilding "Clients setup, creation of the root filesystem">

  <!entity plume "plume">
  <!entity plumeurl "http://plume.sourceforge.net">

]>

<article>

<artheader>

  <title>Network Boot and Exotic Root HOWTO</title>

  <authorgroup>
    <author>
      <firstname>Brieuc</firstname>
      <surname>Jeunhomme</surname>
      <affiliation>
        <orgname>frtest</orgname>
        <address>
          <email>bbp@via.ecp.fr</email>
        </address>
      </affiliation>
    </author>
    <corpauthor>Logilab S.A.</corpauthor>
  </authorgroup>

  <abstract>

    <para>This document explains how to quickly setup a linux server to provide what diskless linux clients require to get up and running, using an IP network. It includes data and partly rewritten text from the Diskless-HOWTO, the Diskless-root-NFS-HOWTO, the linux kernel documentation, the &etb; project's documentation, the &ltsp;'s homepage, and the author's personal experience, acquired when working for &logilab;. Eventually this document may end up deprecating the Diskless-HOWTO and Diskless-root-NFS-HOWTO. Please note that you'll also find useful information in the From-PowerUp-to-bash-prompt-HOWTO and the Thin-Client-HOWTO, and the Claus-Justus Heine's page about NFS swapping.</para>

  </abstract>

  <revhistory>

    <revision>
      <revnumber>0.3</revnumber>
      <date>2002-04-28</date>
      <authorinitials>bej</authorinitials>
      <revremark>Many feedback inclusions, added links to several projects</revremark>
    </revision>

    <revision>
      <revnumber>0.2.2</revnumber>
      <date>2001-12-08</date>
      <authorinitials>dcm</authorinitials>
      <revremark>Licensed GFDL</revremark>
    </revision>

    <revision>
      <revnumber>0.2.1</revnumber>
      <date>2001-05-21</date>
      <authorinitials>logilab</authorinitials>
      <revremark>Fixed bibliography and artheader</revremark>
    </revision>

    <revision>
      <revnumber>0.2</revnumber>
      <date>2001-05-19</date>
      <authorinitials>bej</authorinitials>
      <revremark>Many improvements and included Ken Yap's feedback.</revremark>
    </revision>

    <revision>
      <revnumber>0.1.1</revnumber>
      <date>2001-04-09</date>
      <authorinitials>logilab</authorinitials>
      <revremark>First public draft.</revremark>
    </revision>

    <revision>
      <revnumber>0.1</revnumber>
      <date>2000-12-09</date>
      <authorinitials>bej</authorinitials>
      <revremark>Initial draft.</revremark>
    </revision>
  </revhistory>

</artheader>

<sect1>

  <title>Introduction</title>

  <sect2>

    <title>What is this all about?</title>

    <para>Recent linux kernels offer the possibility to boot a linux box entirely from network, by loading its kernel and root filesystem from a server. In that case, the client may use several ways to get the first instructions it has to execute when booting: home made eproms, special network cards implementing the RARP, BOOTP or DHCP protocols, cdroms, or bootloaders loaded from a boot floppy or a local hard drive.</para>

  </sect2>

  <sect2>

    <title>Thanks</title>

    <para>&logilab; sponsored this HOWTO. Check their <ulink url="&logilaburl;">website</ulink> for new versions of this document.  I also thank the &etb;, &ntb;, &plume; and &ltsp; developers and webmasters, who made it really possible to boot a Linux worstation over a network.</para>

    <para>Very special thanks go to Ken Yap, member of the &etb; project, whose comments greatly helped to improve the quality of this document.</para>

    <para>I also thank Jerome Warnier, main developer of the &plume; project, Pierre Mondi&eacute;, Kyle Bateman, Peter T. Breuer, Charles Howes, and Thomas Marteau for their comments and contributions.</para>

  </sect2>

  <sect2>

    <title>Diskless booting advocacy</title>

    <sect3>

      <title>Buying is cheaper than building</title>

      <para>Sometimes, buying a diskless linux computer will be cheaper than building! Checkout the list of commercial sites given in appendix, which are selling diskless linux network cards and diskless computers. These companies do mass production of linux diskless computers selling millions of units and thereby reducing the cost per unit.</para>

    </sect3>

    <sect3>

      <title>Advantages of diskless computers</title>

      <para>Diskless computers will become more and more popular in the next years. They will be very successful because of the availability of very high-speed network cards at very low prices. Today 100 Megabit per second (12.5&nbsp;MB per sec transfer rate) network cards are common and in about 1 to 2 years 1000&nbsp;MBit (125&nbsp;MB per sec transfer rate) network cards will become very cheap and will be the standard.</para>

      <para>In near future, monitor manufacturers will place the CPU, NIC, RAM right inside the monitor to form a diskless computer. This eliminates the diskless computer box and saves space. The monitor will have outlet for mouse, keyboard, network RJ45 and power supply.</para>

      <para>The following are benefits of using diskless computers:</para>

        <itemizedlist mark="opencircle">

          <listitem>
            <para>Total cost of ownership is very low in case of diskless computers. Total cost of ownership is cost of initial purchasing&nbsp;+ cost of maintenance. The cost of maintenance is usually 3 to 5 times the cost of initial computer purchase and this cost is recurring year after year. In case of diskless computers, the cost of maintenance is completely eliminated.
            </para>
          </listitem>

          <listitem>
            <para>All the backups are centralized at one single main server.
            </para>
          </listitem>

          <listitem>
            <para>No need of UPS battery, air-conditioning, dust proof environment for diskless clients, only server needs UPS battery, A/C and dust proof environment.
            </para>
          </listitem>

          <listitem>
            <para>A better protection from virus attack&nbsp;- Some computer virus cannot attack diskless computers as they do not have any hard disk. This kind of virus cannot do any damage to diskless computers. Only one single server box needs to be protected against virus attack. This saves millions of dollars for the company by avoiding installation of vaccines and cleaning the hard disks.
            </para>
          </listitem>

          <listitem>
            <para>Servers can have large powerful/high performance hard disks, can optimize the usage of disk space via sharing by many diskless computer users. Fault tolerance of hard disk failure is possible by using RAID on main server.
            </para>
          </listitem>

          <listitem>
            <para>On some installations: sharing of central server RAM memory by many diskless computer users. For example, if many users are running a web browser remotely on a server, then there will be only one copy of this web browser in its RAM.
            </para>
          </listitem>

          <listitem>
            <para>Very few system administrators required to maintain central server.</para>
          </listitem>

          <listitem>
            <para>Zero administration at diskless client side. Diskless computers are absolutely maintenance free and troublefree.
            </para>
          </listitem>

          <listitem>
            <para>Long life of diskless clients.
            </para>
          </listitem>

          <listitem>
            <para>Eliminates install/upgrade of hardware, software on diskless client side.
            </para>
          </listitem>

          <listitem>
            <para>Eliminates cost of cdrom, floppy, tape drive, modem, UPS battery, printer parallel ports, serial ports etc...
            </para>
          </listitem>

          <listitem>
            <para>Can operate in places like factory floor where a hard disk might be too fragile.
            </para>
          </listitem>

        </itemizedlist>

    </sect3>

  </sect2>

  <sect2>

    <title>Requirements</title>

    <sect3>

      <title>Hardware requirements</title>

      <para>The most important thing in order to boot from network is to have an equipment which enables the stations to execute a bootloader, which will get the kernel on the server and launch it. Another solution is to use a device which will load a local kernel, which will mount the root filesystem on the server. There are several solutions: home made eproms containing the first instructions to execute when booting the station, boot with BOOTP/DHCP capable network adapters, or a local floppy, a tiny hard drive, or a cdrom to load the kernel. Note that some vendors also sell network booting capable stations: for instance, some Sun stations implement the BOOTP protocol.</para>

      <para>Other hardware requirements depend on the configuration you plan to use: on some sites, every application run by the stations is executed remotely on the server, this implies that a very high-performance server is required, but only light stations are required: depending on what they will have to do, 80486 CPUs with 16&nbsp;MB of RAM may be enough. On the other side, if application programs are really executed locally on the stations, the requirements for the stations depend completely on these applications. In that case, only a small server is required. A 80486 CPU with 32&nbsp;MB of RAM will be sufficient for a small number of stations, but more memory will be necessary in very large installations with hundreds or thousands of machines. Note the server's CPU does not really matter for such an installation.</para>

    </sect3>

    <sect3>

      <title>Software requirements</title>

      <para>Linux kernel version 2.0 or above sources are required. All tools required to build a linux kernel are also necessary (see the linux kernel documentation for more information on this).</para>

      <para>A BOOTP daemon (a DHCP daemon may also do fine, but I won't explain how to configure this), a NFS daemon (if you want to mount the root filesystem on a remote server), are also required. We will also need a TFTP daemon if you plan to load the kernel remotely. At last, the mknbi utility provided with the <ulink url="&etburl;">&etb; distribution</ulink>, and, if you use LanWorks EPROMs, like those included in the 3c905 3com ethernet adapter, you will also need the imggen utility, available at <ulink url="&imggenurl;">&imggenurl;</ulink>.</para>

    </sect3>

  </sect2>

  <sect2>

    <title>Acknowledgements and related documentation</title>

    <para>This documentation has been written for experimented system administrators, who are already aware of linux fundamentals, like the use of grep, sed, and awk, basic shell programming, the init process and the boot scripts, kernel compilation, and NFS server configuration. Experience of kernel arguments passing should also help. Information on these subjects can be found respectively in the grep, sed, awk, and bash man/info pages, in the Bootdisk-HOWTO, the From-PowerUp-To-Bash-Prompt-HOWTO, the Kernel-HOWTO, the BootPrompt-HOWTO, the bootparam man page, the rdev man page, the NFS-HOWTO, and the exports manual page.</para>

    <para>There are many sources of information on network booting, but, and this is why I wrote this HOWTO, none describes all the existing ways of booting over a network, and much of them are specific to a way of operating. The most useful to me has been the documentation provided by the <ulink url="&ltspurl;">&ltsp;</ulink>, although I did not use the packages they recommend, and I have chosen to describe here how to proceed without these packages, because they configure things so that every application program is executed remotely on a server. Useful information can also be found on the <ulink url="&etburl;">&etb; project's homepage</ulink>.</para>

    <para>At last, you can also find useful but succinct information in the kernel's source tree, in <filename class="directory">/usr/src/linux/Documentation</filename>, assuming your kernel source tree resides in <filename class="directory">/usr/src/linux</filename>.</para>

  </sect2>

  <sect2>

    <title>Feedback</title>

    <para>I will highly appreciate any feedback about this document. Please feel free to mail me at <email>&bbpmail;</email> if you have any comment, correction, or suggestion. You may also use <email>contact@logilab.fr</email>.</para>

  </sect2>

  <sect2 id="copyright">
   <title>Copyright Information</title>

   <para>
    This document is copyrighted (c) 2001 and 
    is distributed under the terms of the GNU Free Documentation License.
    You should have received a copy along with it. If not, it is available from
    <ulink url="http://www.fsf.org/licenses/fdl.html">http://www.fsf.org/licenses/fdl.html</ulink>.
   </para>
  </sect2>

</sect1>

<sect1>

  <title>Diskless booting operation overview</title>

  <para>Hey, you think it's time to start with the real stuff, right? Here we go.</para>

  <sect2>

    <title>Obtaining IP parameters</title>

    <para>One could wonder how a station may boot over an IP network if it doesn't even know its own IP address. In fact, three protocols enable the client to obtain this information and some additional configuration parameters:

      <itemizedlist mark="opencircle">

        <listitem>
          <para>RARP: this is the simplest of these protocols. However I guess it does not enable the server to specify how the client should download the kernel, so we won't use it (In fact, there is a convention that uses the IP address of the workstation as filename, e.g. a client getting the address 192.168.42.12 by RARP might ask for <filename>/tftpboot/192.168.42.12</filename> by TFTP, as the linux kernel does. The filename might also be the hex form of the IP address, this is implementation dependant, and is not mandatory.).</para>
        </listitem>

        <listitem>
          <para>BOOTP: this protocol allows a server to provide the client (identified by its hardware MAC address) with much information, in particular its IP address, subnet mask, broadcast address, network address, gateway address, host name, and kernel loading path. This is the one we will use.</para>
        </listitem>

        <listitem>
          <para>DHCP: this is an extension of BOOTP.</para>
        </listitem>

      </itemizedlist>
    </para>

  </sect2>

  <sect2>

    <title>Loading the kernel</title>

    <para>When the client has got its IP parameters, if the kernel is not on a local support (like a floppy, a cdrom, or a hard drive), the client will start to download it via TFTP. Its location is given by the BOOTP/DHCP server. A server (not necessarily the BOOTP/DHCP server) will also have to run a TFTP daemon for non local kernels. The kernel one obtains after compilation can not be used "as is" for BOOTP/DHCP operation, its binary image has to be modified with the <command>mknbi</command> utility (and then modified again with the <command>imggen</command> utility if you use LanWorks EPROMs). The <command>mknbi</command> utility should also be used to modify kernels that will be written in a ROM.</para>

  </sect2>

  <sect2>

    <title>Mounting the root filesystem</title>

    <para>After the kernel has started, it will try to mount its root filesystem. The location of this filesystem is also obtained through BOOTP/DHCP, and it is mounted via NFS. It means a client may use BOOTP twice for booting: the first time to get its kernel, and the second time to learn the location of the root filesystem (which may be on a third server).</para>

    <para>Another solution is to use a ramdisk as root filesystem. In this case, the ramdisk image is obtained with the kernel via TFTP.</para>

  </sect2>

  <sect2>

    <title>Terminating the boot process</title>

    <para>When the root filesystem is mounted, you can start breathing: you can at least use your swiss army knife with its sh, sed, and awk blades. In fact, you will have to customize the initialization scripts of the client's filesystem: for instance, you will have to remove all hard drive, floppy or cdrom related stuff from <filename>/etc/fstab</filename> (when your stations are not equipped with these devices), you may also have to inhibit swap partitions activation (note there is a way to swap over NFS or network block devices). You also will have to automagically generate all network configuration files at boot time if several clients use the same remote root filesystem.</para>

  </sect2>

</sect1>

<sect1>

  <title>Building the kernel</title>

  <para>First of all, build a kernel for the clients. I suggest you build it on the server, this will be useful later for modules installation. Use a zImage to reduce its size. Include everything you need, but try to use as many modules as possible, because many BOOTP client implementations are unable to load very large kernels (at least on intel x86 architectures). Also include iramdisk support, NFS protocol support, root filesystem on NFS support, support for your NIC, kernel level IP autoconfiguration via BOOTP; <emphasis>do not use modules for these!</emphasis> Then, if you plan to use the same remote root filesystem for several clients, add support for ext2fs or some other filesystem and ramdisks (16 Megabytes ramdisks will do fine on most systems). You can then modify the kernel arguments as usual (see the BootPrompt-HOWTO for information on this topic), but you will have another opportunity to modify kernel arguments later.</para>

  <para>Then, if you plan to use BOOTP, copy the kernel zImage on the server. We will assume it resides in <filename class="directory">/tftpboot</filename>, its name is zImage, the name of the image you want to create from this zImage for BOOTP operation is kernel, and the nfs root filesystem will reside in <filename class="directory">/nfsroot</filename>.</para>

  <para>Issue the following commands on the server (the mknbi package should be installed):

    <programlisting>
      <prompt># </prompt>cd /tftpboot
      <prompt># </prompt>chmod 0555 zImage
      <prompt># </prompt>chown root:root zImage
      <prompt># </prompt>mknbi-linux zImage --output=kernel --rootdir=/nfsroot
    </programlisting>

  </para>

  <para>If you are using LanWorks EPROMs, also issue the following commands (you need the imggen utility):

    <programlisting>
      <prompt># </prompt>mv -f kernel tmpkernel
      <prompt># </prompt>imggen -a tmpkernel kernel
      <prompt># </prompt>rm -f tmpkernel
    </programlisting>

  </para>

  <para>Your kernel is ready for BOOTP/DHCP/ROM operation. You of course don't need to do this if you plan to use a local drive.</para> 

  <sect2>

    <title>When the root filesystem is on a ramdisk</title>

    <para>It is possible to use a ramdisk for the root filesystem. In this case, the command used to modify the kernel's binary image is slightly different. If you choose to do so, you have to enable support for initial ramdisk (initrd), and you probably don't need NFS support, or you probably can compile it as a module.</para>

    <para>Its time to give an overview of what happens when you use initrd. The full documentation for this is in your kernel source tree, in the <filename>Documentation/initrd.txt</filename> file. I have to warn you I did never try this&nbsp;:).</para>

    <para>When initrd is enabled, the boot loader first loads the kernel and the inital ramdisk into memory. Then, the ramdisk is mounted read-write as root filesystem. The kernel looks for a <filename>/linuxrc</filename> file (a binary executable or a script beginning with #!). When <filename>/linuxrc</filename> terminates, the traditionnal root filesystem is mounted as <filename>/</filename>, and the usual boot sequence is performed. So, if you want to run your box entirely from ramdisk, you just have to create a link from <filename>/linuxrc</filename> to <filename>/sbin/init</filename>, or to write there a shell script to perform any action you like, and then shutdown the computer.</para>

    <para>After the kernel has been compiled, you have to build a root filesystem for your installation. This is explained in the "&clientsrootbuilding;" section. I will assume here that this is already done and that the root filesystem for your clients temporarily resides in <filename class="directory">/tmp/rootfs</filename>. You now have to create a ramdisk image. A simple way to do so is the following:

      <itemizedlist mark="opencircle">

        <listitem>
	  <para>Make sure the computer you are working on has support for ramdisks and has such a device (<filename>/dev/ram0</filename>).</para>
	</listitem>

        <listitem>
	  <para>Create an empty filesystem with the appropriate size on this ramdisk:
	    <programlisting>
	      <prompt># </prompt>mke2fs -m0 /dev/ram0 300
	    </programlisting>
	  </para>
	</listitem>

        <listitem>
	  <para>Mount it somewhere:
	    <programlisting>
	      <prompt># </prompt>mount -t ext2 /dev/ram0 /mnt
	    </programlisting>
	  </para>
	</listitem>

        <listitem>
	  <para>Copy what you need for your new root filesystem, and create your future <filename>/linuxrc</filename> if you did not create it in <filename>/tmp/rootfs/linuxrc</filename>:
	    <programlisting>
	      <prompt># </prompt>cp -a /tmp/rootfs/* /mnt
	    </programlisting>
	  </para>
	</listitem>

        <listitem>
	  <para>Unmount the ramdisk:
	    <programlisting>
	      <prompt># </prompt>umount /mnt
	    </programlisting>
	  </para>
	</listitem>

        <listitem>
	  <para>Save the ramdisk image to some file and free it:
	    <programlisting>
	      <prompt># </prompt>dd if=/dev/ram0 of=initrd bs=1024 count=300
	      <prompt># </prompt>freeramdisk /dev/ram0
	    </programlisting>
	  </para>
	</listitem>

      </itemizedlist>

      What was toled above about LanWorks PROMs is also true if you use initrd.

    </para>

    <para>Then, you have to modify the kernel image, as was told above, with the <command>mknbi-linux</command> utility. Its invocation will slightly differ from the above, though (I will assume your just compiled zImage resides in <filename>/tftpboot/zImage</filename> and your initial ramdisk image resides in <filename>/tmp/initrd</filename>):

      <programlisting>
        <prompt># </prompt>cd /tftpboot
        <prompt># </prompt>chmod 0555 zImage
        <prompt># </prompt>chown root:root zImage
	<prompt># </prompt>rdev zImage /dev/ram0
        <prompt># </prompt>mknbi-linux zImage --output=kernel --rootdir=/dev/ram0 /tmp/initrd
      </programlisting>

    </para>

  </sect2>

</sect1>

<sect1>

  <title>Daemons setup</title>

  <sect2>

    <title>NFS daemon</title>

    <para>Just export the directory in which the client's root filesystem will reside (see the exports manpage for more information about this topic). The simplest is to export it no_root_squash and rw, but a perfect setup would export most of the root filesystem root_squash and ro, and have separate lines in the <filename>/etc/exports</filename> for directories which really require no_root_squash and/or rw. Just start with everything rw and no_root_squash, the fine tuning will be done later.</para>

    <para>Of course, you don't need any NFS server at all if you plan to run your clients entirely from ramdisk.</para>

  </sect2>

  <sect2>

    <title>BOOTP daemon</title>

    <para>I assume you have installed the bootpd package. The default configuration file is <filename>/etc/bootptab</filename>, and its syntax is detailed in the bootptab manpage. Let's create it.</para>

    <para>First, open as root your favourite text editor. It is vim. Yes, it is. If it is not, it has to become. Now, enter the following lines (they are the default attributes). All the attributes you give here and do not override in a machine's specific attributes list will be given to clients):

      <programlisting>
        .default\
                :sm=your subnet mask\
                :ds=the IP address of your DNS server\
                :ht=ethernet\
                :dn=your domain name\
                :gw=the IP address of your gateway\
                :sa=the IP address of the TFTP server\
                :bf=path to find the kernel image\
                :rp=path of the root filesystem\
                :hn
      </programlisting>

    Of course, not all these parameters are required, this depends on your network configuration and BOOTP implementations, but these will work in most cases.</para>

    <para>Then, add an entry per client in your network. An entry should look like this:

      <programlisting>
        dns of the client\
                :ha=MAC address of the client\
                :ip=IP address of the client
      </programlisting>

    The MAC address above is the hexadecimal hardware address of the client without the ':' characters.</para>

    <para>Here is a sample <filename>/etc/bootptab</filename> file:

      <programlisting>
              .default\
                      :sm=255.255.0.0\
                      :ds=192.168.0.2\
                      :ht=ethernet\
                      :dn=frtest.org\
                      :gw=192.168.0.1\
                      :sa=192.168.0.2\
                      :bf=/tftpboot/kernel\
                      :rp=/nfsroot\
                      :hn

              foo\
                      :ha=001122334455\
                      :ip=192.168.2.12

              bar\
                      :ha=00FFEEDDCCBB\
                      :ip=192.168.12.42\
                      :ds=192.168.2.42
      </programlisting>

    </para>

    <para>Then, run the bootpd daemon with the bootpd&nbsp;-s command (it is also a good idea to add it to your startup scripts), or add the following line to your <filename>/etc/inetd.conf</filename>:

      <programlisting>
        bootps dgram udp wait root /usr/sbin/tcpd&nbsp;bootpd -i -t 120
      </programlisting>

    </para>

    <para>If you want to test the BOOTP server, add an entry to your <filename>/etc/bootptab</filename> and use the bootptest program.</para>

  </sect2>

  <sect2>

    <title>TFTP</title>

    <para>Setting up the TFTP daemon is not the hard part: just install the tftpd package if you have one, and add the following line to your <filename>/etc/inetd.conf</filename> (again, I assume <filename class="directory">/tftpboot</filename> is the directory where the kernel image resides):

      <programlisting>
        tftp dgram udp wait root /usr/sbin/tcpd in.tftpd /tftpboot
      </programlisting>

    Don't forget to chmod&nbsp;555 the <filename class="directory">/tftpboot</filename> directory, as most TFTP servers won't send the files if they are not world readable.</para>

    <para>You should be aware of the limitations implied by running the TFTP daemon from the inetd. Most inetd's will shutdown a service if it is spawned to frequently. So if you have many clients, you should look for another inetd like xinetd, or run a standalone TFTP daemon.</para>

    <para>Now you have properly setup all daemons, you can restart the inetd and take a coffee. Don't forget to tell everyone the server setup is over, so you think you're a hero before you start building the root filesystem for the clients.</para>

  </sect2>

</sect1>

<sect1>

  <title>&clientsrootbuilding;</title>

  <para>Tired? No you're not. Remember you're a hero. Here comes the tricky part. We will (err... <emphasis>you</emphasis> will) build the client's root filesystem. This shouldn't be very hard, but you probably will have to use trial and error.</para>

  <para>The simplest way to create a root filesystem is to use an already working filesystem and customize it for the needs of diskless operation. Of course, you can also build one by hand (like in the good old times) if you like:=), but I won't explain this here.</para>

  <sect2>

    <title>Creating the first files and directories</title>

    <para>First, <command>cd</command> to your future station's root directory. You can safely create the future <filename class="directory">/home</filename> directory with the <command>mkdir</command> command, or by copying it from anywhere you want (you can use <command>cp&nbsp;-a</command> to do a recursive copy preserving owners, groups, symlinks, and permissions). Same thing for the future <filename class="directory">/mnt</filename>, <filename class="directory">/root</filename>, <filename class="directory">/tmp</filename> (don't forget to <command>chmod&nbsp;0</command> it, this is only a mount point for the actual <filename class="directory">/tmp</filename> we will use, because each workstation needs to have its own <filename class="directory">/tmp</filename>). Then, copy some existing <filename class="directory">/bin</filename>, <filename class="directory">/sbin</filename>, <filename class="directory">/boot</filename>, and <filename class="directory">/usr</filename> into this future root directory (use <command>cp&nbsp;-a</command>). You can create the <filename class="directory">/proc</filename> directory with mkdir, and <command>chmod&nbsp;0</command> it. Note some applications need write access to their user's home directory.</para>

    <para>The <filename class="directory">/lib</filename> directory can be safely copied from somewhere else, but you will have to put the proper modules in it. To do so, use the following commands (assuming you have compiled the kernel for your clients on the server in <filename class="directory">/usr/src/linux</filename>, and the root filesystem will reside in <filename class="directory">/nfsroot</filename>):

      <programlisting>
        <prompt># </prompt>cd /usr/src/linux
        <prompt># </prompt>make modules_install INSTALL_MOD_PATH=/nfsroot
      </programlisting>

    </para>

    <para>Don't forget to put the <filename>System.map</filename> file in <filename class="directory">/nfsroot/boot</filename>. A first problem we will have to fix is that, depending on your configuration, your system may try to run fsck on the root filesystem at boot time. It shouldn't if there is no hard drive in the box. Most distributions will also skip this fsck if they find a <filename>fastboot</filename> file in the root directory. So, issue the following commands if you do not plan to mount any hard drive:

      <programlisting>
        <prompt># </prompt>cd /nfsroot
        <prompt># </prompt>touch fastboot
        <prompt># </prompt>chmod 0 fastboot
      </programlisting>

    Another method is tell <command>fsck</command> that checking a NFS filesystem always succeeds:

    <programlisting>
      <prompt># </prompt>cd /nfsroot/sbin
      <prompt># </prompt>ln -s ../bin/true fsck.nfs
    </programlisting>

    </para>

    <para>The <filename class="directory">/dev</filename> directory can also be safely copied from another place into <filename class="directory">/nfsroot</filename>. But permissions and symlinks have to be preserved, so use <command>cp&nbsp;-a</command>. Another solution is to use kernel 2.2.x devfs feature, which will reduce memory consumption and improve performance, but the drawback of this method is that all symlinks created in <filename class="directory">/dev</filename> will be lost. The point to remember is that each workstation needs to have its own <filename class="directory">/dev</filename>, so you will have to copy it on a ramdisk if you plan to use several clients and not to use devfs.</para>

  </sect2>

  <sect2>

    <title>The <filename class="directory">/var</filename> and <filename class="directory">/etc</filename> directories</title>

    <para>We will use ramdisks for these directories, because each client needs to have its own one. But we still need them at the beginning to create their standard structure. Note you are not required to do so if you use a single client. So copy these directories (<command>cp -a</command>) from another place into <filename class="directory">/nfsroot</filename>. Then you can make some cleanup in <filename class="directory">/var</filename>: you can remove everything in <filename class="directory">/nfsroot/var/log</filename> and <filename class="directory">/nfsroot/var/run</filename>. You also probably can remove everything in <filename class="directory">/nfsroot/var/spool/mail</filename>, if you plan to export it via NFS. You also will have to remove the files containing host specific information in /nfsroot/etc to build them on the fly during the boot process.</para>

    <para>The startup scripts will have to be customized in order to mount some
    parts of the filesystem: the <filename class="directory">/dev</filename> directory, if you don't use devfs, the <filename class="directory">/tmp</filename>, the <filename class="directory">/var</filename>, and the <filename class="directory">/etc</filename> directories. Here is some code which will achieve this:

      <programlisting>
        # this part only if you don't use devfs
        mke2fs -q -i 1024 /dev/ram0 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram0 /dev
        # this part for everyone
        mke2fs -q -i 1024 /dev/ram1 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram1 /tmp
        chmod 1777 /tmp
        cp -a /etc /tmp
        mke2fs -q -i 1024 /dev/ram2 16384
        mount -n -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram2 /etc
        find /tmp/etc -maxdepth 1 -exec cp -a '{}' /etc ';'
        mount -f -t ext2 -o rw,suid,dev,exec, \
            async,nocheck,remount /dev/ram2 /etc
        mount -f -o remount /
        cp -a /var /tmp
        mke2fs -q -i 1024 /dev/ram3 16384
        mount -t ext2 -o rw,suid,dev,exec, \
            async,nocheck /dev/ram3 /var
        find /tmp/var -maxdepth 1 -exec cp -a '{}' /var ';'
      </programlisting>

    </para>

    <para>If you plan to use more than a single client, you will also have to change files dynamically at boot time in <filename class="directory">/etc</filename>: the files which contain the IP and hostname of the client. These files depend on your distribution, but you will easily find them with a few greps. Just remove client-specific information from them, and add code into your startup files to generate this information again at boot time <emphasis>but only once the new <filename class="directory">/etc</filename> has been mounted on the ramdisk!</emphasis> A way to obtain your IP address and hostname at bootup is the following (if you have the bootpc package installed on the workstations'filesystem):

      <programlisting>
        IPADDR="$(bootpc | awk '/IPADDR/ \
                                {
                                  match($0,"[A-Za-z]+")
                                  s=substr($0,RSTART+RLENGTH)
                                  match(s,"[0-9.]+")
                                  print substr(s,RSTART,RLENGTH)
                                }
                               ')"

        HOST="$(bootpc | awk '/HOSTNAME/ \
                              {
                                match($0,"[A-Za-z]+")
                                s=substr($0,RSTART+RLENGTH)
                                match(s,"[A-Za-z0-9-]+")
                                print substr(s,RSTART,RLENGTH)
                              }')"

        DOMAIN="$(bootpc | awk '/DOMAIN/ \
                                {
                                  match($0,"[A-Za-z]+")
                                  s=substr($0,RSTART+RLENGTH)
                                  match(s,"[A-Za-z0-9-.]+")
                                  print substr(s,RSTART,RLENGTH)
                                }')"
      </programlisting>

    This is a complicated solution, but I guess it should work on most sites. The IP address can alternatively be obtained with the output of <command>ifconfig</command> and the hostname can be obtained from the output of the host command, but this is not portable, because these outputs differ from system to system depending on the distribution you are using, and the locales settings.</para>

    <para>Then, the hostname should be set with the <command>hostname&nbsp;$HOSTNAME</command> command. When this is done, it is time to generate on the fly the configuration files which contain the IP address or the hostname of the client.</para>

  </sect2>

  <sect2>

    <title>Last details</title>

    <para>Now, it's time to do the fine tuning of the client. As <filename class="directory">/var</filename> will be mounted on a ramdisk (unless you have a single client), you will have to send the logs to a logs server if you want to keep them. One way to do that is to delete the <filename>/nfsroot/etc/syslog.conf</filename> file and replacing it by the following file (see man syslog.conf for details):

      <programlisting>
        *.*     /dev/tty12
        *.*     @dns or IP of the logs server
      </programlisting>

    If you do so, the logs server will have to run <command>syslogd</command> with the -r option (see the syslogd manual page).</para>

    <para>If you use <command>logrotate</command> and you have done the preceding operation, you should replace the <command>logrotate</command> configuration file (<filename>/etc/logrotate.conf</filename> on most boxes) by an empty file:

      <programlisting>
        <prompt># </prompt>rm -f /etc/logrotate.conf
        <prompt># </prompt>touch /etc/logrotate.conf
      </programlisting>

    If you don't use it, just remove the logs rotation scripts from the crontab, and as you no longer have log files in <filename>/var/log</filename>, put an <command>exit&nbsp;0</command> at the beginning of your logs rotation scripts.</para>

    <para>In the <filename>/nfsroot/etc/fstab</filename> file, remove anything related to the hard drive, floppy disk reader, or cdrom if you don't have such devices on your workstations. Add an entry for the <filename class="directory">/var/spool/mail</filename> directory, which should be exported by the server through NFS or any other network filesystem. You probably also want to put an entry for the <filename class="directory">/home</filename> directory in this file.</para>

    <para>You can also comment the lines running newaliases, activating swap, and running depmod&nbsp;-a and remove the <filename>/nfsroot/etc/mtab</filename> file. Comment out the line(s) removing <filename>/fastboot</filename>, <filename>/fsckoptions</filename>, and <filename>/forcefsck</filename> in your startup scripts. Also remove or comment any line in the startup scripts that would try to write on the root filesystem except for really necessary writes, which should all be redirected to some ramdisk location if you use several clients.</para>

  </sect2>

  <sect2>

    <title>Trial...</title>

    <para>Time has come for a small trial. MAKE A BACKUP OF YOUR NEWLY CREATED
    <filename class="directory">/nfsroot</filename>. tar&nbsp;-cvvIf should do
    fine. Take a minute to verify we didn't forget anything. Try to boot a
    client.</para>

  </sect2>

  <sect2>

    <title>And Error!</title>

    <para>Look carefully at the client's screen during the boot process. Oh, I didn't tell you to connect a screen... Run, forest! Run an get one. You will probably see some error messages. Fix the problems, and make frequent backups of your <filename class="directory">/nfsroot</filename>. One day, the client will boot properly. This day, you will have to fix errors occurring during shutdown;=P.</para>

  </sect2>

</sect1>

<sect1>

  <title>Several ways of obtaining the kernel</title>

  <para>We have spoken so far about the client and server's configuration for operation after the BOOTP request has been issued by the client, but the first problem is that most computers are not able to behave as BOOTP clients by default. We will see in this section how to fix this.</para>

  <sect2>

    <title>BOOTP or DHCP capable NICs</title>

    <para>This is the most simple case: some network cards provide a supplement to the BIOS, containing a BOOTP or DHCP client, so just setup them for BOOTP or DHCP operation in the BIOS, and you're done.</para>

  </sect2>

  <sect2>

    <title>Kernel on a local floppy or hard drive</title>

    <para>These cases are also quite simple: the kernel is loaded from a local drive, and all the kernel has to do is to obtain its network parameters from BOOTP, and mount its root filesystem over NFS; this should not cause any problem. By the way, a local hard drive is a good place to leave a <filename class="directory">/var</filename>, <filename class="directory">/tmp</filename>, and a <filename class="directory">/dev</filename>...</para>

    <para>If you have a local hard drive, all you have to do is to use lilo or your favourite boot loader as usual. If you use a floppy, you can use a bootloader or simply write the kernel on the floppy: a kernel is directly bootable.This enables you to use a command like the following:
    
    <programlisting>
      <prompt># </prompt>dd if=zImage of=/dev/fd0 bs=8192
    </programlisting>

    </para>

    <para>However, Alan Cox told in a linux-kernel thread that this feature of the linux kernel will be removed sooner or later, you thus will have to use a bootloader even on floppies some day. I know this still works with 2.4.11 kernels, but support seems to have been removed in the 2.4.13 version. See the sixth chapter of the <ulink url="&bootdiskhowtourl;">boot-disk-HOWTO</ulink> for this topic.

    </para>

  </sect2>

  <sect2>

    <title>Bootloader without kernel on a local floppy or hard drive</title>

    <para>Certain bootloaders are network aware, you may thus use them to download the kernel image from the network. Some of them are listed below:</para>

    <itemizedlist mark="opencircle">

      <listitem>
        <para><ulink url="&ntburl;">&ntb;</ulink>, a bootloader dedicated to network boot.</para>
      </listitem>

      <listitem>
        <para><ulink url="&gruburl;">&grub;</ulink>, the GNU project's GRand Unified Bootloader, which is a very general purpose bootloader.</para>
      </listitem>

    </itemizedlist>

  </sect2>

  <sect2>

    <title>Creating ROMs for the clients</title>

    <para>Many network cards include a slot in which one can insert an EPROM with additional BIOS code. This enables one to add, for instance, BOOTP capabilities to the BI0S. To do so, you will first have to find how to enable the EPROM socket. You may need a jumper or a special software to do so. Some cards like the 3Com 905B have slots for EEPROMs which enable one to change the software in the EEPROM in place. In appendix, you'll find the information about EPROM and various types of memory chips.</para>

    <para>For a list of EPROM burner manufacturers visit the Yahoo site and go to <ulink url="http://dir.yahoo.com/Business_and_Economy/Companies/Computers/Hardware/Peripherals/Device_Programmers/">economy->company->Hardware->Peripherals->Device programmers</ulink> or check out the old Diskless-HOWTO <emphasis>List of EPROM burner manufacturers</emphasis> section.</para>

    <para>If you choose to create your own ROMS, you will have to load a BOOTP or DHCP capable software in the ROM, and then, you will be in the case of BOOTP or DHCP capable NICs described above.</para>

    <para>You will also need to find the proper EPROM size and speed for your NIC. Some methods to do so are provided in appendix, because the NICs manufacturers often do not provide this information.</para>

    <sect3>

      <title>LanWorks BootWare PROMs</title>

      <para>This information may save you time. In order to make LanWorks BootWare(tm) PROMs to correctly start up a linux kernel image, the "bootsector" part of the image must be modified so as to enable the boot prom to jump right into the image start address. The net-bootable image format created by &ntb;/&etb;'s `mknbi-linux' tool differs and will not run if used with BootWare PROMs.</para>

      <para>A modified bootsector together with a Makefile to create a BootWare-bootable image after kernel compilation can be found at:

        <itemizedlist mark="opencircle">

          <listitem>
            <para>Bwimage package: <ulink url="ftp://ftp.ipp.mpg.de/pub/ipp/wls/linux/bwimage-0.1.tgz">ftp://ftp.ipp.mpg.de/pub/ipp/wls/linux/bwimage-0.1.tgz</ulink></para>
          </listitem>

          <listitem>
            <para>See also <ulink url="http://www.patoche.org/LTT/net/00000096.html">http://www.patoche.org/LTT/net/00000096.html</ulink></para>
          </listitem>

          <listitem>
            <para>LanWorks BootWare Boot ROMs: <ulink url="http://www.3com.com/lanworks">http://www.3com.com/lanworks</ulink></para>
          </listitem>

        </itemizedlist>

      </para>

      <para>Refer to the README file for installation details. Currently, only "zImage"-type kernels are supported. Unfortunately, kernel parameters are ignored.</para>

      <para>This section was initially written by Jochen Kmietsch for the Diskless-HOWTO, email to: <email>jochen.kmietsch@tu-clausthal.de</email> for any questions.</para>

    </sect3>

  </sect2>

  <sect2>

    <title>Local CDROM</title>

    <para>This section was originally written by Hans de Goede <email>j.w.r.degoede@et.tudelft.nl</email> for the Diskless-root-NFS-HOWTO. I modified it slightly in order to reflect some differences between this document and the Diskless-root-NFS-HOWTO.</para>

    <para>Much of the above also goes for booting from cdrom. Why would one want to boot a machine from cdrom? Booting from cdrom is interesting everywhere one wants to run a very specific application, like a kiosk, a library database program or an internet cafe, and one doesn't have a network or a server to use a root over nfs setup.</para>

    <sect3>

      <title>Creating a test setup</title>

      <para>Now that we know what we want to do and how, it's time to create a test setup:

        <itemizedlist mark="opencircle">

          <listitem>
            <para>For starters just take one of the machines which you want to use and put in a big disk and a cd burner.</para>
          </listitem>

          <listitem>
            <para>Install your linux of choice on this machine, and leave a 650&nbsp;MB partition free for the test setup. This install will be used to make the iso image and to burn the cd's from, so install the necessary tools. It will also be used to restore any booboo's which leave the test setup unbootable.</para>
          </listitem>

          <listitem>
            <para>On the 650 mb partition install your linux of choice with the setup you want to have on the cd, this will be the test setup.</para>
          </listitem>

          <listitem>
            <para>Boot the test setup.</para>
          </listitem>

          <listitem>
            <para>Compile a kernel with isofs and cdrom support compiled in.</para>
          </listitem>

          <listitem>
            <para>Configure the test setup as described above with the root filesystem mounted read only.</para>
          </listitem>

          <listitem>
            <para>Verify that the test setup automagically boots and everything works.</para>
          </listitem>

          <listitem>
            <para>Boot the main install and mount the 650&nbsp;MB partition on <filename class="directory">/test</filename> of the main install.</para>
          </listitem>

          <listitem>
            <para>Put the following in a file called <filename>/test/etc/rc.d/rc.iso</filename>, this file will be sourced at the beginning of <filename>rc.sysinit</filename> to create <filename class="directory">/var</filename>:

              <programlisting>
                #/var
                echo Creating /var ...
                mke2fs -q -i 1024 /dev/ram1 16384
                mount /dev/ram1 /var -o defaults,rw
                cp -a /lib/var /
              </programlisting>
            </para>
          </listitem>

          <listitem>
            <para>Edit <filename>/test/etc/rc.sysinit</filename>, comment the lines where the root is remounted rw, and add the following 2 lines directly after setting the PATH:

              <programlisting>
                #to boot from cdrom
                . /etc/rc.d/rc.iso
              </programlisting>
            </para>
          </listitem>

          <listitem>
            <para>Copy the following to a script and execute it to make a template for <filename class="directory">/var</filename> and create <filename class="directory">/tmp</filename> and <filename>/etc/mtab</filename> links.

              <programlisting>

                #!/bin/sh
                echo tmp
                rm -fR /test/tmp
                ln -s var/tmp /test/tmp

                ###
                echo mtab
                touch /test/proc/mounts
                rm /test/etc/mtab
                ln -s /proc/mounts /test/etc/mtab

                ###
                echo var
                mv /test/var/lib /test/lib/var-lib
                mv /test/var /test/lib
                mkdir /test/var
                ln -s /lib/var-lib /test/lib/var/lib
                rm -fR /test/lib/var/catman
                rm -fR /test/lib/var/log/httpd
                rm -f /test/lib/var/log/samba/*
                for i in `find /test/lib/var/log -type f`; do
                  cat /dev/null > $i;
                done
                rm `find /test/lib/var/lock -type f`
                rm `find /test/lib/var/run -type f`

              </programlisting>

            </para>
          </listitem>

          <listitem>
            <para>Remove the creation of <filename>/etc/issue*</filename> from <filename>/test/etc/rc.local</filename>: it will only fail.</para>
          </listitem>

          <listitem>
            <para>Now boot the test partition again, it will be read only just like a cdrom. If something doesn't work reboot to the working partition fix it, try again etc. Or you could remount <filename class="directory">/</filename> rw, fix it, then reboot straight into to test partition again. To remount <filename class="directory">/</filename> rw type:

              <programlisting>
                <prompt># </prompt>mount -o remount,rw /
              </programlisting>

            </para>
          </listitem>

        </itemizedlist>

      </para>

    </sect3>

    <sect3>

      <title>Creating the CD</title>

      <para>If you need more information than you can find below, please refer to the CD-Writing-HOWTO.</para>

      <sect4>

        <title>Creating a boot image</title>

        <para>First of all, boot into the working partition. To create a bootable cd we'll need an image of a bootable floppy. Just dd-ing a zImage doesn't work since the loader at the beginning of the zimage doesn't seem to like the fake floppydrive a bootable cd creates. So we'll use syslinux instead.

        <itemizedlist mark="opencircle">

          <listitem>
            <para>Get boot.img from a redhat cd.</para>
          </listitem>

          <listitem>
            <para>Mount boot.img somewhere through loopback by typing:

              <programlisting>
                <prompt># </prompt>mount boot.img somewhere -o loop -t vfat
              </programlisting>
            </para>
          </listitem>

          <listitem>
            <para>Remove everything from boot.img except for ldlinux.sys and
            syslinux.cfg.</para>
          </listitem>

          <listitem>
            <para>Cp the kernel-image from the test partition to boot.img.</para>
          </listitem>

          <listitem>
            <para>Edit <filename>syslinux.cfg</filename> so that it contains the following, of course replace <filename>zImage</filename> by the appropriate image name:

              <programlisting>

                default linux 

                label linux
                kernel zImage
                append root=/dev/&lt;insert your cdrom device here&gt;

              </programlisting>

            </para>

          </listitem>

          <listitem>
            <para>Umount boot.img:

              <programlisting>
                <prompt># </prompt>umount somewhere
              </programlisting>
            </para>
          </listitem>

          <listitem>
            <para>If your <filename>/etc/mtab</filename> is a link to <filename>/proc/mounts</filename>, umount won't automagically free <filename>/dev/loop0</filename> so free it by typing:

              <programlisting>
                <prompt># </prompt>losetup -d /dev/loop0
              </programlisting>
            </para>
          </listitem>

        </itemizedlist>

        </para>

      </sect4>

      <sect4>

        <title>Creating the iso image</title>

        <para>Now that we have the boot image and an install that can boot from a readonly mount it's time to create an iso image of the cd:

          <itemizedlist mark="opencircle">

            <listitem>
              <para>Copy boot.img to <filename class="directory">/test</filename></para>
            </listitem>

            <listitem>
              <para>Cd to the directory where you want to store the image and make sure it's on a partition with enough free space.</para>
            </listitem>

            <listitem>
              <para>Now generate the image by typing:

                <programlisting>
                  <prompt># </prompt>mkisofs -R -b boot.img -c boot.catalog -o boot.iso /test
                </programlisting>
              </para>
            </listitem>

          </itemizedlist>

        </para>

      </sect4>

      <sect4>

        <title>Verifying the iso image</title>

        <para>
          <itemizedlist mark="opencircle">

            <listitem>
              <para>Mounting the image through the loopbackdevice by typing:

                <programlisting>
                  <prompt># </prompt>mount boot.iso somewhere -o loop -t iso9660
                </programlisting>
              </para>
            </listitem>

            <listitem>
              <para>Umount boot.iso:

                <programlisting>
                  <prompt># </prompt>umount somewhere
                </programlisting>
              </para>
            </listitem>

            <listitem>
              <para>If your <filename>/etc/mtab</filename> is a link to <filename>/proc/mounts</filename> umount won't automagically free <filename>/dev/loop0</filename> so free it by typing:

              <programlisting>
                <prompt># </prompt>losetup -d /dev/loop0
              </programlisting>
              </para>
            </listitem>

          </itemizedlist>

        </para>

      </sect4>

      <sect4>

        <title>Writing the actual CD</title>

        <para>Assuming that you've got <command>cdrecord</command> installed and configured for your cd-writer type:

          <programlisting>
            <prompt># </prompt>cdrecord -v speed=&lt;desired writing speed&gt; dev=&lt;path to your writers generic scsi device&gt; boot.iso
          </programlisting>
        </para>

      </sect4>

    </sect3>

    <sect3>

      <title>Boot the cd and test it</title>

      <para>Well the title of this paragraph says it all;)</para>

    </sect3>

  </sect2>

</sect1>

<sect1>

  <title>How to create diskless MS-Windows stations?</title>

  <para>Since MS-Windows does not support diskless booting, a simple workaround is presented here: the solution is to use software like <ulink url="&vmwareurl;">&vmware;</ulink> or its free alternative, <ulink url="&plex86url;">&plex86;</ulink>. Although the &plex86; seems to have been abandonned, one can still boot certain versions of MS-Windows using this software. These enable MS-Windows to be executed transparently on the linux box.</para>

</sect1>

<sect1>

  <title>Troubleshooting, tips, tricks, and useful links</title>

  <sect2>

    <title>Transparently handling workstations'specific files</title>

    <para>

      The previous sections discussed a simple way to handle workstations'specific files and directories like <filename class="directory">/var</filename>. Most of them are simply build on the fly and put on ramdisks, you may however prefer to deal with this problem on the NFS server. The &clusternfs; project provides a network filesystem server that can serve different files based on several criteria including the client's IP address or host name. The basic idea is that if the client whose IP address is 10.2.12.42 requests a file named, for instance, <filename>myfile</filename>, the server will look for a file named <filename>myfile$$IP=10.2.12.42$$</filename> and serve this file instead of <filename>myfile</filename> if it is available.

    </para>

  </sect2>

  <sect2>

    <title>Reducing diskless workstations'memory usage</title>

    <para>One simple way to reduce memory consumption is to put several dynamically created directories on the same ramdisk. For instance, let's say the first ramdisk will contain the <filename class="directory">/tmp</filename> directory. Then, one may move the <filename class="directory">/var/tmp</filename> directory on that ramdisk with the following commands issued on the server:

      <programlisting>
        <prompt># </prompt>mkdir /nfsroot/tmp/var
        <prompt># </prompt>chmod 0 /nfsroot/tmp/var
        <prompt># </prompt>ln -s /tmp/var /nfsroot/var/tmp
      </programlisting>

    </para>

    <para>Another good way to reduce memory consumption if you don't have local hard drives and do not swap over a network block device is to disable the <command>Swapping to block devices</command> option during kernel compilation.</para>

  </sect2>

  <sect2>

    <title>Swapping over NFS</title>

    <para>If your stations do not have enough memory and do not have local drives, you may want to swap over NFS. You have to be warned the cod eto do so is still under development and this method is generally quite slow. The full documentation for this can be found at <ulink url="http://www.instmath.rwth-aachen.de/~heine/nfs-swap/">http://www.instmath.rwth-aachen.de/~heine/nfs-swap/</ulink>.</para>

    <para>The first thing to do if you want to apply this solution is to patch your kernel (you need a kernel version 2.2 or above). First download the patch at the above url, and cd to <filename class="directory">/usr/src/linux</filename>. I assume the patch is in <filename>/usr/src/patch</filename>. Then issue the following command:

      <programlisting>
        <prompt># </prompt>cat ../patch | patch -p1 -l -s
      </programlisting>

      Then, compile your kernel normally and enable the <command>Swapping via network sockets (EXPERIMENTAL)</command> and <command>Swapping via NFS (EXPERIMENTAL)</command> options.

    </para>

    <para>Then export a directory read-write and no_root_squash from the NFS server. Setup the clients so that they will mount it somewhere (say on <filename class="directory">/mnt/swap</filename>). It should be mounted with a rsize and wsize smaller than the page size used by the kernel (ie. 4 kilobytes on Intel architectures), otherwise your machine may run out of memory due to memory fragmentation; see the nfs manual page for details about rsize and wsize. Now, to create a 20&nbsp;MB swap file, issue the following commands (which should be placed in the clients'initialization scripts):

      <programlisting>
        <prompt># </prompt>dd if=/dev/zero of=/mnt/swap/swapfile bs=1k count=20480
	<prompt># </prompt>mkswap /mnt/swap/swapfile
	<prompt># </prompt>swapon /mnt/swap/swapfile
      </programlisting>

      Of course, this was just for an example, because if you have several workstations, you will have to change the swap file name or directory, or all your workstations will use the same swap file for their swap...

    </para>

    <para>Let's say a word about the drawbacks of NFS swapping: the first drawback is that it is generally slow, except you have specially fast network cards. Then, this possibility has not been very well tested yet. At last, this is not secure at all: anyone on the network is able to read the swapped data.</para>

  </sect2>

  <sect2>

    <title>Swapping over network block devices</title>

    <para>Although I have never tried it personally, I got report that the trick described below works, at least with recent kernels.</para>

    <para>The general principle for swapping over network block devices is the same than to swap over NFS. The good point is you won't have to patch the kernel. But most of the same drawbacks also apply to the NBD method.</para>

    <para>To create a 20&nbsp;MB swap file, you will have to first create it on the server, export it to the client, and do an <command>mkswap</command> on the file. Note that the <command>mkswap</command> must be done on the server, because mkswap uses system calls which are not handled by NBD. Moreover, this command must be issued after the server starts exporting the file, because the data on the file may be destroyed when the server starts exporting it. If we assume the server's name is NBDserver, the client's name is NBDclient, and the TCP port used for the export is 1024, the commands to issue on the server are the following:

      <programlisting>
        <prompt># </prompt>dd if=/dev/zero of=/swap/swapfile bs=1k count=20480
	<prompt># </prompt>nbd-server NBDclient 1024 /swap/swapfile
	<prompt># </prompt>mkswap /swap/swapfile
      </programlisting>

    Now, the client should use the following command:

      <programlisting>
        <prompt># </prompt>swapon /dev/nd0
      </programlisting>

    </para>

    <para>Again, this was just to show the general principle. The files'names should also be dependant on the workstations'names or IPs.</para>

    <para>Another solution to swap over a network block device is to create an ext2 filesystem on the NBD, then create a regular file on this filesystem, and at last, use <command>mkswap</command> and <command>swapon</command> to start swapping on this file. This second method method is closer to the swap over NFS method than the first solution.</para>

  </sect2>

  <sect2>

    <title>Getting rid of error messages about <filename>/etc/mtab</filename> or unmounted directories on shutdown</title>

    <para>The following commands, issued on the server may solve the problem:

      <programlisting>
        <prompt># </prompt>ln -s /proc/mounts /nfsroot/etc/mtab
        <prompt># </prompt>touch /nfsroot/proc/mounts
      </programlisting>
    </para>

  </sect2>

  <sect2>

    <title>Installing new packages on workstations</title>

    <para>A simple way to do so is to use, on the server, a chroot and then execute your favourite installation commands normally. To chroot to the appropriate place, use the following command:

      <programlisting>
        <prompt># </prompt>chroot /nfsroot
      </programlisting>
    </para>

    <para>Debian users will be particularly interested in the --root option of dpkg, which simply tells dpkg where the root of the target system is.
    </para>

  </sect2>

</sect1>

<appendix>

  <title>Non-Volatile Memory chips</title>

  <para>Here is a brief descriptions of memory chips and their types:

    <itemizedlist mark="opencircle">

      <listitem>
        <para>PROM: Pronounced prom, an acronym for programmable read-only memory. A PROM is a memory chip on which data can be written only once. Once a program has been written onto a PROM, it remains there forever. Unlike RAM, PROMs retain their contents when the computer is turned off. The difference between a PROM and a ROM (read-only memory) is that a PROM is manufactured as blank memory, whereas a ROM is programmed during the manufacturing process. To write data onto a PROM chip, you need a special device called a PROM programmer or PROM burner. The process of programming a PROM is sometimes called burning the PROM. An EPROM (erasable programmable read-only memory) is a special type of PROM that can be erased by exposing it to ultraviolet light. Once it is erased, it can be reprogrammed. An EEPROM is similar to a PROM, but requires only electricity to be erased.</para>
      </listitem>

      <listitem>
        <para>EPROM: Acronym for erasable programmable read-only memory, and pronounced e-prom, EPROM is a special type of memory that retains its contents until it is exposed to ultraviolet light. The ultraviolet light clears its contents, making it possible to reprogram the memory. To write to and erase an EPROM, you need a special device called a PROM programmer or PROM burner. An EPROM differs from a PROM in that a PROM can be written to only once and cannot be erased. EPROMs are used widely in personal computers because they enable the manufacturer to change the contents of the PROM before the computer is actually shipped. This means that bugs can be removed and new versions installed shortly before delivery. A note on EPROM technology: The bits of an EPROM are programmed by injecting electrons with an elevated voltage into the floating gate of a field-effect transistor where a 0 bit is desired. The electrons trapped there cause that transistor to conduct, reading as 0. To erase the EPROM, the trapped electrons are given enough energy to escape the floating gate by bombarding the chip with ultraviolet radiation through the quartz window. To prevent slow erasure over a period of years from sunlight and fluorescent lights, this quartz window is covered with an opaque label in normal use.</para>
      </listitem>

      <listitem>
        <para>EEPROM: Acronym for electrically erasable programmable read-only memory. Pronounced double-e-prom or e-e-prom, an EEPROM is a special type of PROM that can be erased by exposing it to an electrical charge. Like other types of PROM, EEPROM retains its contents even when the power is turned off. Also like other types of ROM, EEPROM is not as fast as RAM. EEPROM is similar to flash memory (sometimes called flash EEPROM). The principal difference is that EEPROM requires data to be written or erased one byte at a time whereas flash memory allows data to be written or erased in blocks. This makes flash memory faster.</para>
      </listitem>

      <listitem>
        <para>FRAM: Short for Ferroelectric Random Access Memory, a type of non-volatile memory developed by Ramtron International Corporation. FRAM combines the access speed of DRAM and SRAM with the non-volatility of ROM. Because of its high speed, it is replacing EEPROM in many devices. The term FRAM itself is a trademark of Ramtron.</para>
      </listitem>

      <listitem>
        <para>NVRAM: Abbreviation of Non-Volatile Random Access Memory, a type of memory that retains its contents when power is turned off. One type of NVRAM is SRAM that is made non-volatile by connecting it to a constant power source such as a battery. Another type of NVRAM uses EEPROM chips to save its contents when power is turned off. In this case, NVRAM is composed of a combination of SRAM and EEPROM chips.</para>
      </listitem>

      <listitem>
        <para>Bubble Memory: A type of non-volatile memory composed of a thin layer of material that can be easily magnetized in only one direction. When a magnetic field is applied to circular area of this substance that is not magnetized in the same direction, the area is reduced to a smaller circle, or bubble. It was once widely believed that bubble memory would become one of the leading memory technologies, but these promises have not been fulfilled. Other non-volatile memory types, such as EEPROM, are both faster and less expensive than bubble memory.</para>
      </listitem>

      <listitem>
        <para>Flash Memory: A special type of EEPROM that can be erased and reprogrammed in blocks instead of one byte at a time. Many modern PCs have their BIOS stored on a flash memory chip so that it can easily be updated if necessary. Such a BIOS is sometimes called a flash BIOS. Flash memory is also popular in modems because it enables the modem manufacturer to support new protocols as they become standardized.</para>
      </listitem>

    </itemizedlist>

  </para>
</appendix>

<appendix>

  <title>Determining the size and speed of EPROMs to plug in a NIC</title>

  <para>This section comes from the &etb; project's documentation version 5.0. It provides tips to determine the size and speed of EPROMs  to use with a particular NIC</para>

  <para>The smallest EPROM that is accepted by network cards is an 8k&nbsp;EPROM (2764). 16&nbsp;kB (27128) or 32&nbsp;kB (27256) are the norm. Some cards will even go up to 64&nbsp;kB EPROMs (27512). (You will often see a C after the 27, e.g. 27C256. This indicates a CMOS EPROM, which is equivalent to the non-C version and is a good thing because of lower power consumption.) You want to use the smallest EPROM you can so that you don't take up more of the upper memory area than needed as other extensions BIOSes may need the space. However you also want to get a good price for the EPROM. Currently the 32&nbsp;kB and 64&nbsp;kB EPROMs (27256 and 27512) seem to be the cheapest per unit. Smaller EPROMs appear to be more expensive because they are out of mainstream production.</para>

  <para>If you cannot find out from the documentation what capacity of EPROM your card takes, for ISA NICs only, you could do it by trial and error. (PCI NICs do not enable the EPROM until the BIOS tells the NIC to.) Take a ROM with some data on it (say a character generator ROM) and plug it into the socket. Be careful not to use an extension BIOS for this test because it may be detected and activated and prevent you from booting your computer. Using the debug program under DOS, dump various regions of the memory space. Say you discover that you can see the data in a memory window from CC00:0 to CC00:3FFF (=&nbsp;4000 hex&nbsp;=&nbsp;16384 decimal locations). This indicates that a 16&nbsp;kB EPROM is needed. However if you see an alias in parts of the memory space, say the region from CC00:0 to CC00:1FFF is duplicated in CC00:2000 to CC00:3FFF, then you have put an 8&nbsp;kB EPROM into a 16&nbsp;kB slot and you need to try a larger EPROM.</para>

  <para>Note that because pinouts for 28 pin EPROMs are upward compatible after a fashion, you can probably use a larger capacity EPROM in a slot intended for a smaller one. The higher address lines will probably be held high so you will need to program the image in the upper half or upper quarter of the larger EPROM, as the case may be. However you should double check the voltages on the pins armed with data sheet and a meter because CMOS EPROMs don't like floating pins.</para>

  <para>If the ROM is larger than the size of the image, for example, a 32&nbsp;kB ROM containing a 16&nbsp;kB image, then you can put the image in either half of the ROM. You will sometimes see advice to put two copies of the image in the ROM. This will work but is not recommended because the ROM will be activated twice if it's a legacy ROM and may not work at all if it's a PCI/PnP ROM. It is tolerated by Etherboot because the code checks to see if it's been activated already and the second activation will do nothing. The recommended method is to fill the unused half with blank data. All ones data is recommended because it is the natural state of the EPROM and involves less work for the PROM programmer. Here is a Unix command line that will generate 16384 bytes of 0xFF and combine it with a 16&nbsp;kB ROM into a 32&nbsp;kB image for your PROM programmer.

    <programlisting>
      <prompt># </prompt>(perl -e 'print "\xFF" x 16384'; cat bin32/3c509.lzrom) > 32kbimage
    </programlisting>

  </para>

  <para>The speed of the EPROM needed depends on how it is connected to the computer bus. If the EPROM is directly connected to the computer bus, as in the case of many cheap NE2000 clones, then you will probably have to get an EPROM that is at least as fast as the ROMs used for the main BIOS. This is typically 120-150 ns. Some network cards mediate access to the EPROM via circuitry and this may insert wait states so that slower EPROMs can be used. Incidentally the slowness of the EPROM doesn't affect Etherboot execution speed much because Etherboot copies itself to RAM before executing. I'm told Netboot does the same thing.</para>

  <para>If you have your own EPROM programming hardware, there is a nice collection of EPROM file format conversion utilities at <ulink url="http://www.canb.auug.org.au/~millerp/srecord.html">http://www.canb.auug.org.au/~millerp/srecord.html</ulink>. The files produced by the Etherboot build process are plain binary. A simple binary to Intel hex format converter can be found at the Etherboot web site at <ulink url="http://etherboot.sourceforge.net/bin2intelhex.c">http://etherboot.sourceforge.net/bin2intelhex.c</ulink>. You may alternatively use the objcopy utility, included in the binutils package:

    <programlisting>
      <prompt># </prompt>objcopy --input-target binary --output-target ihex binary.file intelhex.file
      <prompt># </prompt>objcopy --input-target ihex --output-target binary intelhex.file binary.file
    </programlisting>

  </para>

  <para>Etherboot is believed to make PnP compliant ROMs for PCI NICs. A long-standing bug in the headers has been tracked down. However some faulty old BIOSes are out there so I have written a Perl script swapdevids.pl to switch the header around if necessary. You'll have to experiment with it both ways to find out which works. Or you could dump a ROM image that works (e.g. RPL, PXE ROM) using the Perl script disrom.pl. The fields to look at are Device (base, sub, interface) Type. It should be 02 00 00, but some BIOSes want 00 00 02 due to ambiguity in the original specification.</para>

</appendix>

<appendix>

  <title>Companies selling diskless computers</title>

  <para>The original Diskless-HOWTO mentions the names of the following vendors of diskless computers:

    <itemizedlist mark="opencircle">

      <listitem>
        <para>Linux Systems Labs Inc., USA <ulink url="http://www.lsl.com">http://www.lsl.com</ulink>. Click on "Shop On-line" and then click on "HardWare" where all the diskless computers will be listed. Phone 1-888-LINUX-88.</para>
      </listitem>

      <listitem>
        <para>Diskless Workstations Corporation, USA <ulink url="http://www.disklessworkstations.com">http://www.disklessworkstations.com</ulink>.</para> </listitem>

      <listitem>
        <para>Unique Systems of Holland Inc., Ohio, USA <ulink url="http://www.uniqsys.com">http://www.uniqsys.com</ulink></para> </listitem>

    </itemizedlist>
  </para>

</appendix>

<bibliography>

  <title>References</title>

  <biblioentry xreflabel="Diskless-HOWTO">
    <title>Diskless-HOWTO</title>
    <address>&disklesshowtourl;</address>
  </biblioentry>

  <biblioentry xreflabel="Diskless-root-NFS-HOWTO">
    <title>Diskless-root-NFS-HOWTO</title>
    <address>&disklessrootnfshowtourl;</address>
  </biblioentry>

  <biblioentry xreflabel="Bootdisk-HOWTO">
    <title>Boot-disk-HOWTO</title>
    <address>&bootdiskhowtourl;</address>
  </biblioentry>

  <biblioentry xreflabel="ltsp">
    <title>&ltsp;</title>
    <abstract>
      <simpara>A set of utilities and documentation for diskless stations, based on the red hat distribution.</simpara>
    </abstract>
    <address>&ltspurl;</address>
  </biblioentry>

  <biblioentry xreflabel="&plume;">
    <title>&plume;</title>
    <abstract>
      <simpara>A beginning project whose goal is to provide a set of utilities for diskless stations and associated servers, based on the debian distribution.</simpara>
    </abstract>
    <address>&plumeurl;</address>
  </biblioentry>

  <biblioentry xreflabel="logilab">
    <title>Logilab.org web site</title>
    <address>&logilaburl;</address>
  </biblioentry>

  <biblioentry xreflabel="PowerUp2Bash">
    <title>From-PowerUp-to-bash-prompt-HOWTO</title>
    <address>&powerup2bashurl;</address>
  </biblioentry>

  <biblioentry xreflabel="ThinClient">
    <title>Thin-Client-HOWTO</title>
    <address>&thinclienturl;</address>
  </biblioentry>

  <biblioentry xreflabel="cdwriting">
    <title>CD-Writing-HOWTO</title>
    <address>&cdwritingurl;</address>
  </biblioentry>

  <biblioentry xreflabel="etb">
    <title>&etb; project</title>
    <address>&etburl;</address>
  </biblioentry>

  <biblioentry xreflabel="&vmware;">
    <title>&vmware;</title>
    <abstract>
      <simpara>A non free virtual machine software.</simpara>
    </abstract>
    <address>&vmwareurl;</address>
  </biblioentry>

  <biblioentry xreflabel="&plex86;">
    <title>&plex86;</title>
    <abstract>
      <simpara>A free virtual machine software.</simpara>
    </abstract>
    <address>&plex86url;</address>
  </biblioentry>

</bibliography>

</article>
