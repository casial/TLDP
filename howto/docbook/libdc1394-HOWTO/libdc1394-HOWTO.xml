<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article id="libdc1394-HOWTO">
   <articleinfo>
      <title>Libdc1394 Library Support for IEEE 1394 Cameras HOWTO</title>
      <author>
         <firstname>Rohit</firstname>
         <surname>Agarwal</surname>
         <affiliation>
            <address>
<email><ulink url="mailto:rohdimp_24@rediffmail.com">rohdimp_24@rediffmail.com</ulink></email>
            </address>
         </affiliation>
      </author>
      <author>
         <firstname>Vikram</firstname>
         <surname>B</surname>
         <affiliation>
            <address>
<email><ulink url="mailto:vickys_box@rediffmail.com">vickys_box@rediffmail.com</ulink></email>
            </address>
         </affiliation>
      </author>
      <pubdate>2006-01-23</pubdate>
      <revhistory id="revhistory">
        <revision>
          <revnumber>1.2</revnumber>
          <date>2007-04-14</date>
          <authorinitials>RA</authorinitials>
          <revdescription><para>Addition of DMA related section contributed by Ian Peikon <email><ulink url="mailto:idp2@duke.edu">idp2@duke.edu</ulink></email>and Tim Hanson <email><ulink url="mailto:tim@hardcarve.com">tim@hardcarve.com</ulink></email></para></revdescription>
        </revision>
        <revision>
          <revnumber>1.0</revnumber>
          <date>2006-01-23</date>
          <authorinitials>TMM</authorinitials>
          <revremark>Initial release, reviewed by TLDP</revremark>
        </revision>
        <revision>
	  <revnumber>0.4</revnumber>
	  <date>2005-12-18</date>
	  <authorinitials>TMM</authorinitials>
	  <revremark>Correction of markup</revremark>
	</revision>
        <revision>
          <revnumber>0.3</revnumber>
          <date>2005-11-27</date>
          <authorinitials>TMM</authorinitials>
          <revremark>Conversion to DocBook XML</revremark>
        </revision>
	<revision>
          <revnumber>0.2</revnumber>
          <date>2005-10-15</date>
          <authorinitials>VB</authorinitials>
          <revremark>Minor fixes.</revremark>
        </revision>
	<revision>
          <revnumber>0.1</revnumber>
          <date>2005-10-10</date>
          <authorinitials>RA &amp; VB</authorinitials>
          <revremark>Initial draft.</revremark>
        </revision>
      </revhistory>
      <abstract>
        <para>This document discusses how to set up the libdc1394 library on Linux for support of IEEE 1394 (FireWire) cameras.</para>
      </abstract>
   </articleinfo>
<sect1 id="intro">
  <title>Introduction</title>
  <para>We felt a HOWTO on this topic was required since very little
  documentation is available for the libdc1394 library. Moreover, the IEEE1394 cameras are gaining popularity, which will lead to many people using this library to develop applications for cameras on Linux. This HOWTO is an outcome of our experience working with the Point Grey Dragonfly IEEE1394 camera on Linux.</para>
  <para>We have given the overview of the library in layman's terms, so anybody who has some programming experience will easily understand the contents.</para>
</sect1>

<sect1 id="req">
  <title>Requirements</title>
  <para>Various libraries and modules required are:</para>
    <itemizedlist>
      <listitem><para>Library: libdc1394-1.1.0</para></listitem>
      <listitem><para>Supporting Library: libraw1394-1.2.0</para></listitem>
      <listitem><para>Supporting Modules: ieee1394, raw1394, ohci1394, video1394</para></listitem>
      <listitem><para>Linux Kernel: 2.6.10 or above</para></listitem>
    </itemizedlist>
</sect1>

<sect1 id="install">
  <title>Installation</title>
  <para>Prerequisite: Make sure that the kernel is compiled with IEEE1394 built-in support. This is critical!</para>
  <para>You can add support for the IEEE1394 devices by compiling the kernel again. Don't panic! Here are the steps to compile the kernel:</para>
  <para>Go to the directory where your kernel source code is
  present. Normally it is in <filename
  class="directory">/usr/src</filename>. We suggest that you download
  a fresh copy of the kernel source code (2.6.10) from <ulink url="http://www.kernel.org/">www.kernel.org</ulink>.</para>
  <para>Thus, <command>cd /usr/src/kernel-2.6.10</command> (<filename>kernel-2.6.10</filename> is the name of the source code directory. It can vary from system to system.)</para>
  <orderedlist>
   <listitem><para><command>make menuconfig</command></para></listitem>
   <listitem><para>The menu will come up. Select <guimenuitem>Device Drivers</guimenuitem></para></listitem>
   <listitem><para>The <guimenu>Device Drivers</guimenu> menu will
   come up. Select <guimenuitem>IEEE1394 (Firewire) Support</guimenuitem></para></listitem>
   <listitem><para>Mark the following as &lt;M&gt; in the menu that is shown:</para>
    <orderedlist>
     <listitem><para>OHCI-1394 support</para></listitem>
     <listitem><para>OHCI-1394 Video Support</para></listitem>
     <listitem><para>OHCI-1394 DVI/O Support</para></listitem>
     <listitem><para>RAW IEEE1394 I/O Support</para></listitem>
    </orderedlist>
   </listitem>
   <listitem><para>Press <keycap>ESC</keycap> to come out of the menu</para></listitem>
   <listitem><para>Save the configuration</para></listitem>
  </orderedlist>
   <orderedlist>
    <title>Install libraw1394-1.2.0</title>
     <para>The following steps are required to successfully install
     the library (libdc1394). As a rule of thumb, the installation has
     to be done as the <envar>root</envar> user.</para>
     <para>We already had this library installed in our Linux, so we skipped this step. If you do not have this library installed, make sure you install it before moving further. Here are the steps for the installation: </para>
      <listitem><para><command>su root</command></para></listitem>
      <listitem><para><command>tar -xvzf libraw1394-1.2.0.tar.gz</command></para></listitem>
      <listitem><para><command>cd libraw1394-1.2.0</command></para></listitem>
      <listitem><para><command>./configure</command></para></listitem>
      <listitem><para><command>make</command></para></listitem>
      <listitem><para><command>make install</command></para></listitem>
   </orderedlist>
   <orderedlist>
    <title>Install libdc1394-1.1.0</title>
     <listitem><para><command>su root</command> (if you haven't already)</para></listitem>
     <listitem><para><command>tar -xvzf libdc1394-1.1.0.tar.gz</command></para></listitem>
     <listitem><para><command>cd libdc1394-1.1.0</command> </para></listitem>
     <listitem><para><command>./configure</command></para></listitem>
     <listitem><para><command>cd libdc1394</command></para></listitem>
     <listitem><para><command>make</command></para></listitem>
     <listitem><para><command>make install</command></para></listitem>
   </orderedlist>
   <orderedlist>
    <title>Install the modules</title>
      <listitem><para><command>modprobe ohci1394</command></para></listitem>
      <listitem><para><command>modprobe video 1394</command></para></listitem>
      <listitem><para><command>modprobe ieee1394</command></para></listitem>
      <listitem><para><command>modprobe raw1394</command></para></listitem>
      <listitem><para><command>lsmod</command> to view that all the modules (ieee1394, raw1394, ohci1394 and video1394) are now installed.</para></listitem></orderedlist>
     <note>
      <title>Note on dependencies:</title>
       <para>The modules have some dependencies:
        <itemizedlist>
         <listitem><para>ohci1394 to video1394</para></listitem>
         <listitem><para>ieee1394 to video1394, ohci1394, and raw1394</para></listitem>
        </itemizedlist>
       So if you are installing modules with <command>insmod</command>, video1394 and raw1394 have to be installed first, followed by ohci1394 and ieee1394.</para>
     </note>
   <orderedlist>
    <title>Create proper 1394 devices</title>
      <listitem><para><command>cd /dev</command></para></listitem>
      <listitem><para><command>mknod raw1394 c 171 0</command></para></listitem>
      <listitem><para><command>chmod 666 /dev/raw1394</command></para></listitem>
      <listitem><para><command>mkdir video1394</command></para></listitem>
      <listitem><para><command>cd video1394</command></para></listitem>
      <listitem><para><command>mknod 0 c 171 16</command></para></listitem>
      <listitem><para><command>mknod 1 c 171 17</command></para></listitem>
      <listitem><para><command>chmod 666 /dev/video1394/*</command></para></listitem></orderedlist>
     <note>
      <title>Note on automating module start-up:</title>
       <para>Every time the system is restarted, the nodes are destroyed and the modules are removed automatically. So we wrote a script to automate this installation task at start-up, to undo all the damage done during rebooting!</para>
     </note>
     <orderedlist>
      <title>Set user paths</title>
       <listitem><para><command>su user</command></para></listitem>
       <listitem><para>Check for the
       <envar>LD_LIBRARY_PATH</envar>. It should contain <filename
       class="directory">/usr/local/lib</filename>.  This is necessary
       to run the applications with the help of the shared
       <filename>libdc1394_cotrol.so.13</filename> object
       file.</para></listitem>
     </orderedlist>
      <note>
       <title>Note on setting path:</title>
        <para>You can also set the path by adding <filename
        class="directory">/usr/local/lib</filename> in <filename>/etc/ld.so.conf</filename>.</para>
      </note>
  <para>This completes the installation phase.</para>
  <para>In order to make sure the installation is correct, connect the
  camera to the IEEE1394 card (assuming that the IEEE1394 card is
  already installed on the system) and just run <command>testlibraw</command>:</para>
  <para><userinput>$ testlibraw</userinput></para>
  <para>This tests for the presence of the host card, camera and other related parameters. Below is a typical output from testlibraw:</para>
<screen>
Successfully got handle
current generation number: 17
1 card(s) found
nodes on bus: 2, card name: ohci1394 
using first card found: 2 nodes on bus, local ID is 0, IRM is 1

doing transactions with custom tag handler 
trying to send read request to node 0... completed with value 0x23127bac
trying to send read request to node 1... completed with value 0x60217dac

using standard tag handler and synchronous calls
trying to read from node 0... completed with value 0x04477dac
trying to read from node 1... completed with value 0xd37380ac

testing FCP monitoring on local node
got fcp command from node 0 of 8 bytes: 01 23 45 67 89 ab cd ef
got fcp response from node 0 of 8 bytes: 01 23 45 67 89 ab cd ef

polling for leftover messages
</screen>
  <para>The <filename>libdc1394-1.1.0</filename> library comes with
  some example programs which are very helpful in understanding how
  the programs are to be written. There is a Makefile available in the
  <filename class="directory">examples</filename> folder of the tar file. To compile and execute the programs:</para>
  <para><userinput>cd libdc1394-1.1.0/examples</userinput></para>
  <para><userinput>make</userinput></para>
  <para>You can get programs exclusively written for the Point Grey
  cameras at <ulink
  url="http://www.ptgrey.com/support/kb/data/grabdma.tgz">http://www.ptgrey.com/support/kb/data/grabdma.tgz</ulink>.</para>
  <para>Fortunately, we have an open source graphical application
  developed for the IEEE1394 cameras, known as <application><command>Coriander</command></application> that provides a nice Graphical User
  Interface for libdc1394 to help the user work with the camera more
  efficiently. Later we will discuss how <application>Coriander</application> helped us in debugging. Next,
  we briefly explain how to install <application>Coriander</application>.</para>
  <orderedlist>
   <title>Installation of <application>Coriander</application></title>
    <listitem><para>Make sure that you have libdc1394 and the Gnome
    libraries (<application>Coriander</application> uses
    <filename>gnome.h</filename>) installed on your Linux
    machine. For more details regarding the requirements, look into the user
    manual provided by <application>Coriander</application>:  <ulink
    url="http://damien.douxchamps.net/ieee1394/coriander/manual.php">http://damien.douxchamps.net/ieee1394/coriander/manual.php</ulink>.</para></listitem>
    <listitem><para>Download the following tar file from sourceforge.net:
    <filename>coriander-1.0.1.tar.gz</filename>, then proceed as shown below:</para>
      <orderedlist>
       <listitem><para><command>su root</command></para></listitem>
       <listitem><para><command>tar -xvzf coriander-1.0.1.tar.gz</command></para></listitem>
       <listitem><para><command>cd coriander-1.0.1</command></para></listitem>
       <listitem><para><command>./configure</command></para></listitem>
       <listitem><para><command>cd src</command></para></listitem>
       <listitem><para><command>make</command></para></listitem>
       <listitem><para><command>make install</command></para></listitem>
      </orderedlist></listitem>   
    <listitem><para>Run <application>Coriander</application> as follows:
<screen>
cd coriander-1.0.1/coriander-1.0.1/src
./coriander
</screen></para>
    <para>Fortunately, the installation of the libdc1394 and related modules is simple and does not pose any major problems. Some minor problems you may face are due to mistakes such as not installing it as root or not changing the permissions of the newly created IEEE1394 devices.</para></listitem>
  </orderedlist>
</sect1>

<sect1 id="concepts">
  <title>Concepts and Basic Programs </title>
   <para>At present, the documents that are available for understanding libdc1394 are very few. Among the available documents are a FAQ, which only talks about the general concept of the camera and a few forums where people have posted their queries.</para>
   <para>We had to read the libdc1394 source code to understand how to grab a frame from the camera. The extreme need for a complete explanation on this topic encouraged us to write this HOWTO. </para>
   <para>On the basis of what we understood by exploring the source code of the camera, we are presenting our insights on the library.</para>
   <para>We encourage you to keep referring following files while reading through the next section: </para>
   <orderedlist>
    <listitem><para><filename>dc1394_control.h</filename></para></listitem>
    <listitem><para><filename>dc1394_control.c</filename></para></listitem>
    <listitem><para><filename>dc1394_capture.c</filename></para></listitem>
    <listitem><para><filename>dc1394_format7.c</filename></para></listitem>
   </orderedlist>
   <para>The <filename>dc1394_control.h</filename> file is the most important, as it contains the declaration of various functions and data structures. It should be read to understand the features supported by IEEE1394 cameras and the functions which access and control various features of camera.</para>
  <para>The dc1394 library works closely with raw1394 since all the functions make use of functions of raw1394 (raw1394_read() and raw1394_write()) in order to retrieve or modify the values of various parameters of the camera.  This is one of the reasons why raw1394 must be installed before installing libdc1394.</para>
  <para>To understand how the functions provided by the library work, we need to understand few technical aspects of the IEEE1394 camera:</para>
  <orderedlist>
   <listitem><para>There can be more than one camera connected to the host card at any time, hence one need to uniquely identify the camera node.</para></listitem>
   <listitem><para>The camera has some control registers to set camera features.</para></listitem>
   <listitem><para>According to IEEE specifications, the camera can grab images in different formats. The image formats are defined by two parameters: format and mode. Five modes are defined:
     <orderedlist>
      <listitem><para>Format_0 contains low resolution mode up to 640x480</para></listitem>
      <listitem><para>Format_1 contains medium resolution modes: 800x600 and 1024x768</para></listitem>
      <listitem><para>Format_2 contains mega pixel modes: 1280x960 and 1600x1200</para></listitem>
      <listitem><para>Format_7 is the scalable image format. With this, you can change the image size, color coding and other parameters</para></listitem>
     </orderedlist>
     It may be possible that a camera does not support some modes, so we need to be careful during the setup. You use setup to set various parameters like data speed, image mode, framerate that are necessary to make the camera ready to grab the image. We will shortly discuss setup functions.</para></listitem>
   <listitem><para>In order to set or get the values of the parameters/features of the camera, the library functions will modify or read the register values.</para></listitem>
   <listitem><para>The camera can work with or without DMA. We are greatful to Ian Peikon and Tim Hanson for contributing a section on IEEE1394 camera using DMA support </para></listitem>
  </orderedlist>
  <para>With the above background, we begin our discussion about the
  various functions, data structures and other miscellaneous features
  available in the <filename>dc1394_control.h</filename> file.</para>
  <para>We would like to mention one important aspect of the <filename>dc1394_control.h</filename> file, which is that it lists out the values that can be set for the data speeds, frame rates, camera modes and image formats. All the values are in the form of enumerations to help you write readable code.  For example, enumeration for speed indicates that the data speed can be set only as 100, 200, 400, 800, 1600 or 3200. </para>
  <para>The <filename>dc1394_control.h</filename> also lists the features (brightness, hue, sharpness, saturation, etc.) supported for your camera.</para>

 <sect2 id="imp_data_structs">
  <title>Important Data Structures</title>
  <para>The library provides some structures which are useful in
  storing camera and image related information. They have been
  declared in the <filename>dc1394_control.h</filename> file.</para>
<informaltable frame="all">
<tgroup cols="2"><tbody>
<row>
<entry><para>Structure</para></entry>
<entry><para>Use</para></entry>
</row>
<row>
<entry><para>dc1394_camerainfo</para></entry>
<entry><para>Helps in accessing the information about the camera model, vendor, ccr_offset (used to access the registers).</para></entry>
</row>
<row>
<entry><para>dc1394_cameracapture</para></entry>
<entry><para>Contains various parameters that are to be manipulated
while the camera setup. It also declares a buffer of <varname>int</varname> type that will be used to store the grabbed frame.</para></entry>
</row>
<row>
<entry><para>dc1394_misc_info</para></entry>
<entry><para>Contains the information about the ISO channel id, iso-channel speed, memory channel number.</para></entry>
</row>
<row>
<entry><para>dc1394_feature_info</para></entry>
<entry><para>Contains the information about a particular feature (brightness, hue, gamma, white balance, etc.,) for example the availability and values for it.</para></entry>
</row></tbody></tgroup>
</informaltable>
<para>We will be largely concerned with the dc1394_cameracapture structure.</para>
 </sect2>

 <sect2 id="function_types">
  <title>Types of functions</title>
   <para>We have categorized the functions provided by the library
   into 6 types. (The categorization is purely done on our own for the
   ease of discussion). Each of these functions has been declared in
   <filename>dc1394_control.h</filename>. We suggest you to keep a copy of the file on hand while going through the subsequent section.</para>
   <orderedlist>
    <listitem><para>Get/Query Functions</para></listitem>
    <listitem><para>Set Functions</para></listitem>
    <listitem><para>Print Functions</para></listitem>
    <listitem><para>Setup Functions </para></listitem>
    <listitem><para>Format7 Functions</para></listitem>
    <listitem><para>Release Functions </para></listitem>
   </orderedlist>
  <sect3 id="get-query">
   <title>Get/Query Functions</title>
    <para>These functions are used to get the value of various
    features of the camera, the information about the ISO channel,
    trigger mode, frame rate, format and mode. The functions contain
   <varname>get</varname> or <varname>query</varname> in their names.</para>
    <para>For example, 
<screen>
int dc1394_get_gamma (raw1394handle_t handle, node_t node, unsigned
int *gamma)
</screen> 
gets the value of the gamma attribute for the camera.</para>
    <para>Most of the <varname>get</varname> functions take a minimum of three parameters: </para>
     <orderedlist>
      <listitem><para>Both the <function>raw1394handle_t</function>
      and <function>node_t</function> nodes: these two together identify the camera</para></listitem>
      <listitem><para>A pointer to obtain the value, for example,
      <userinput>int * gamma</userinput></para></listitem>
     </orderedlist>

    <para>If we try to trace the flow of the function call, we can understand what actually happens:</para>
<figure><title>Flow of get function call</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig1.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig1.eps" format="EPS"></imagedata>
</imageobject>
<textobject><phrase>Get Function Call</phrase></textobject>
    </mediaobject>
</figure>
    <para>In case the <varname>get</varname> function you called is
    meant to retrieve the value of a camera feature (the value for the
    parameters listed in feature enumeration), that
    <varname>get</varname> function will call another
    <varname>get</varname> function (<function>GetFeatureValue</function>), which takes the enumeration value of the feature as input. For example, in the
    case of gamma value, the function passes 422 as the value (this
    value can be calculated from the enumeration given in the
    <filename>dc1394_control.h</filename> file).</para>
    <para>Ultimately, the
    <function>GetCameraControlRegister</function> function, whose task is
    to get the value from the appropriate control registers, is
    called. This functions takes the offset value (<function>octlet_t
    offset</function>), which is the offset from the base register as
    the input to its call. The function prototype is declared in <filename>dc1394_internal.h</filename>.</para>
    <para>
<screen>
GetCameraControlRegister (raw1394handle_t handle, nodeid_t node,
                         octlet_t offset, quadlet_t *value)
</screen></para>
    <para>The above will store the final result in the <varname>value</varname>.</para>
    <note>
     <title>Note on data types:</title>
      <para>The library makes use of typedefed data types
<varname>octlet_t</varname> and <varname>quadlet_t</varname> very frequently . These are defined in <filename>dc1394_internal.h</filename> and stand for 8-byte and 4-byte data types.</para>
    </note>
    <para>The <function>GetCameraControlRegister</function> function
    will in turn call <function>dc1394_get_camera_info()</function> to get the address of the base register:</para>
    <para>
<screen>
camera-&gt;ccr_base = CONFIG_ROM_BASE + info-&gt;ccr_offset;
</screen></para>
    <para>Once the base register and the offset is known,
<function>raw1394_read()</function> is called by <function>GetCameraControlRegister</function> to read the actual values.</para>
    <para>Now the <varname>get</varname> function
(<function>dc1394_get_gamma</function>) uses the value returned by the <function>GetCameraControlRegister</function> to modify the parameter gamma.</para>
    <para>
<screen>
int dc1394_get_gamma (raw1394handle_t handle, node_t node , unsigned int *gamma )
</screen></para>
    <para>In this way, the user obtains the value of the camera parameter he queried for.</para>
   </sect3>

   <sect3 id="set_functions">
    <title>Set Functions</title>
     <para>These functions are used to set the values of various
     camera features. There is a corresponding set function for almost
     each get function. You can recognize these functions by searching
     for <varname>set</varname> string.</para>
     <para>For example,</para>
     <para>
<screen>dc1394_set_gamma (raw1394handle_t handle, nodeid_t node, int
gamma)
</screen></para>
     <para>Like the <function>get</function> function, this function needs
<function>raw1394handle_t</function> and <function>nodeid_t</function> for camera identification.</para>
    <para>The other parameter, <parameter>gamma</parameter>, is the user-specified value for the gamma parameter.</para>
    <para>The flow of the function call is quite helpful in
     understanding what is actually happening. The flow is exactly
     same as that of the <varname>get</varname> function. The only
     difference is this time all the intermediate functions are also
     <varname>set</varname> functions, and instead of
    <function>raw1394_read()</function>, it uses <function>raw1394_write()</function> to write the value of the camera parameter on to the registers.</para>
<figure><title>Flow of set function call</title>
     <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig2.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig2.eps" format="EPS"></imagedata>
</imageobject>
    </mediaobject>
</figure>
   </sect3>

   <sect3 id="print_functions">
    <title>Print Functions</title>
     <para>There are three print functions available:</para>
     <orderedlist>
      <listitem><para><function>dc1394_print_camera_info</function>:
      This function is used to print the values stored in the
      dc1394camera_info structure. The print function is usually
      called after <function>dc1394_get_camera_info()</function> to ensure that the dc1394camera_info structure is not NULL. </para></listitem>
      <listitem><para><function>dc1394_print_feature</function>: This function is used to print the value of any feature. It takes as an input the pointer to dc1394_feature_info structure.</para></listitem>
      <listitem><para><function>dc1394_print_feature_set</function>: This function is used to print the values of all features present in the camera. It takes as an input the pointer to dc1394_feature_set structure. The function call basically calls dc1394_print_feature repeatedly in a <emphasis>for</emphasis> loop.</para></listitem>
     </orderedlist>
   </sect3>

   <sect3 id="setup_functions">
    <title>Setup Functions</title>
     <para>As the name suggests, these functions are used to prepare
     the camera to start grabbing the images. In order to setup the
     camera, some parameters must be passed to the function. The
     number and the type of parameters are specific to the setup
     function, but essentially three parameters must be passed in
     all the setup functions: <parameter>raw1394handle_t</parameter>,
     <parameter>nodeid_t</parameter> and the pointer to the dc1394_cameracapture structure (this is to provide the buffer for grabbed images and keep attributes, like height and width of frame).</para>
     <para>As mentioned previously, <parameter>raw1394handle_t</parameter> and <parameter>nodeid_t</parameter> uniquely define the camera, while the pointer to dc1394_cameracapture provides the buffer for the image frame to be grabbed. It also stores information about the width and height of the frame which is useful at the time of image processing.</para>
     <para>Other parameters that are passed are data speed, frame rate, image format, image mode and ISO channel number. </para>
     <para>In case the camera uses DMA, the number of <varname>DMA buffers</varname> and <varname>drop frames</varname> is to be provided. In most applications you will want to set the number of DMA buffers relatively low(i.e. 1) this ensures that you are viewing frames in near real time. Drop frames is also important for real time as it causes the capture function to throw away the frames buffered in the DMA ring buffer except fot the last. We will discuss about DMA functions in the later part of this HowTo</para>
     <para>The various setup functions are:</para>
      <orderedlist>
       <listitem><para><function>dc1394_dma_setup_capture</function></para></listitem>
       <listitem><para><function>dc1394_setup_capture</function></para></listitem>
       <listitem><para><function>dc1394_setup_format7_capture</function></para></listitem>
       <listitem><para><function>dc1394_dma_setup_format7_capture</function></para></listitem>
      </orderedlist>
     <para>These setup functions have been defined in <filename>dc1394_capture.c</filename>.</para>
     <para>You have a choice while passing the values for the
     parameters, like data-speed, format, mode, and channel. Instead
     of providing the value yourself, you may instruct the function to
     take the value from the camera. This can be done by passing
     <envar>QUERY_FROM_CAMERA</envar> in place of the actual value for that function parameter.</para>
     <para>The basic flow of control is easy to understand:</para>
<figure><title>Flow of the setup function call</title>
     <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig3.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig3.eps" format="EPS"></imagedata>
</imageobject>
    </mediaobject>
</figure>
     <para>As shown in Figure 3, the Setup function in turn calls various set functions to set the parameter values to the camera registers. In the case of DMA setup, after the set functions have been called the ioctl system call is called to allocate memory for the DMA buffers and returns a pointer <parameter>capture_buffer</parameter> in user space.</para>
<para>The ioctl system calls will fail if the DMA is not setup correctly</para>
     <para>The setup functions also allocate memory for the camera _capture buffer:</para>
     <para>
<screen>camera-&gt;capture_buffer=(int*)malloc(camera-&gt;quadlets_per_frame*4);
</screen></para>
   </sect3>
    <sect3 id="format7_functions">
    <title>Format7 Functions</title>
     <para>These functions are used only if the camera is set for Format7. This format is preferred since this allows the user to define the size of the image to be captured according to his need. By default the size is 1024x768; you can set it to different dimensions, say 960x720.</para>
     <para>All Format7 functions have <varname>format7</varname> in
     their function names, and the functions have been defined in a
     separate file, <filename>dc1394_format7.c</filename>.</para>
     <para>The setup function for Format7 has a minor difference from the normal setup since it also asks for the size of the frame, while you don't have to pass the format parameter as the setup function, as it is meant only for a particular format, for example Format7. The function call flow remains the same as discussed in the previous section.</para>
     <para>The Format7 <varname>get</varname> functions are called
     query functions. The mechanism is different from the normal
     get/query functions: they don't call
     <function>GetCameraControlRegister</function>; instead, they call <function>GetCameraFormat7Register()</function>.</para>

     <para>The following flowchart will make the differences evident:</para>
<figure><title>Flow of the Format7 query function call</title>
     <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig4.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig4.eps" format="EPS"></imagedata>
</imageobject>
    </mediaobject>
</figure>
    <para>The Format7 query function will call
     <function>GetCameraFormat7Register</function>, which is supposed
     to read the values from the control and status registers of the
     camera. This function in turn will call the
     <function>QueryFormat</function> and
     <function>CSROffset</function> to know the offset for the
     particular information that has been queried. After getting the offset, <function>raw1394_read</function> is used to actually read the values.</para>
     <para>The Format7 set functions also follow the same logic with
     the obvious difference that the reading functions are replaced by
     writing functions, for example, <function>SetCameraFormat7Register</function> and <function>raw1394_write()</function>.</para>
   </sect3>

   <sect3 id="release_functions">
    <title>Release Functions</title>
     <para>These are the final set of functions identified by us. The basic job of these functions is to release the memory allocated to the capture buffer by the setup routine. This is essential to save the system from memory leaks.</para>     <para>These functions are defined in <filename>dc1394_capture.c:</filename></para>
      <para>
<screen>dc1394_release_camera()</screen></para>
       <para>This function in turn calls <function>free (camera -&gt; capture_buffer)</function>, which frees the memory.</para>
       <para>Similarly, the release function is available for DMA setup.</para>
   </sect3>
  </sect2>

  <sect2 id="coriander_app">
   <title><application>Coriander</application>: A GUI for the libdc1394 library</title>
    <para><application>Coriander</application> helps in easy handling
    of the IEEE1394 cameras. It uses the above discussed functions and
    libraries and provides a GUI for them. The main advantage of <application>Coriander</application> is that it saves time that is
    normally wasted in camera setup.  Also, <application>Coriander</application> shows only those features and
    attributes that are present on the camera and hence you can judge
    how useful the camera will be for your application
    development. The most important feature of <application>Coriander</application> is its ability to display the captured image at run-time. </para>
    <para><application>Coriander</application> also allows the user to
    convert a BGGR image to RGB. We will discuss the meaning of these
    types of images in detail in later sections. Some files that can be
    useful in understanding the functionality of <application>Coriander</application> are:</para>
    <orderedlist>
     <listitem><para><filename>thread_iso.c</filename></para></listitem>
     <listitem><para><filename>Camera.c</filename></para></listitem>
     <listitem><para><filename>main.c</filename></para></listitem>
    </orderedlist>
    <para>The <application>Coriander</application> homepage contains
    an excellent user manual which can be useful in case of any
    difficulty: <ulink
    url="http://damien.douxchamps.net/ieee1394/coriander/manual.php">http://damien.douxchamps.net/ieee1394/coriander/manual.php</ulink>.</para>
    <para>Our use of <application>Coriander</application> was limited
    only to checking that the camera was working properly and confirming
    the focus was correct. We will give some more usage information
    for <application>Coriander</application> in later sections.</para>
  </sect2>

  <sect2 id="example">
   <title>Example: How to grab image from the IEEE1394 camera</title>
    <para>In this section we will demonstrate how to write a small
    program to grab an image from the camera. We have taken the
    program (<filename>grab_gray_image.c</filename>) given in the examples in the library tar file. We have removed some lines to increase the readability of the code. We have provided the explanation for this code below. In order to provide you with a clear picture of which section of the code does what, we grouped the code lines together by task below.</para>

<screenco>
<areaspec>
<area coords="5" id="header" ></area>
<area coords="16" id="d_types" ></area>
<area coords="20" id="ohci" ></area>
<area coords="29" id="c_nodes" ></area>
<area coords="41" id="condition" ></area>
<area coords="52" id="setup" ></area>
<area coords="77" id="trigger" ></area>
<area coords="90" id="c_send" ></area>
<area coords="101" id="c_frame" ></area>
<area coords="111" id="stop_d" ></area>
<area coords="130" id="pgm_header" ></area>
<area coords="135" id="fwrite" ></area>
<area coords="142" id="c_camera" ></area>
</areaspec>   
<screen>
  #include &lt;stdio.h&gt;
  #include &lt;libraw1394/raw1394.h&gt;
  #include &lt;libdc1394/dc1394_control.h&gt;
  #include &lt;stdlib.h&gt;            
  #define IMAGE_FILE_NAME "Image.pgm"

  int main(int argc, char *argv[]) 
  {

    FILE* imagefile;
    dc1394_cameracapture camera;
    int numNodes;
    int numCameras;
    raw1394handle_t handle;
    nodeid_t * camera_nodes;

         /* Open ohci and asign handle to it */

         handle = dc1394_create_handle(0);
    if (handle==NULL)
    {
         fprintf( stderr, "Unable to aquire a raw1394 handle\n\n"
                    );
         exit(1);
    }

         /* get the camera nodes and describe them as we find them */

    numNodes = raw1394_get_nodecount(handle);
    camera_nodes = dc1394_get_camera_nodes(handle,&amp;numCameras,1);
    fflush(stdout);
    if (numCameras&lt;1)
    {
      fprintf( stderr, "no cameras found :(\n");
      dc1394_destroy_handle(handle);
      exit(1);
    }
    printf("working with the first camera on the bus\n");

    if( camera_nodes[0] == numNodes-1)
    {
      fprintf( stderr, "\n"
         "Sorry, your camera is the highest numbered node\n");
      dc1394_destroy_handle(handle);
      dc1394_free_camera_nodes(camera_nodes);
      exit( 1);
    }

    /*setup capture */

    if (dc1394_setup_capture(handle,camera_nodes[0],
                             0, /* channel */ 

                             FORMAT_VGA_NONCOMPRESSED,
                             MODE_640x480_MONO,
                             SPEED_400,
                             FRAMERATE_7_5,
                             &amp;camera)!=DC1394_SUCCESS) 
    {
      fprintf( stderr,"unable to setup camera-\n"
         "check line %d of %s to make sure\n"
         "that the video mode,framerate and format are\n"
         "supported by your camera\n",
         __LINE__,__FILE__);
      dc1394_release_camera(handle,&amp;camera);
      dc1394_destroy_handle(handle);
      dc1394_free_camera_nodes(camera_nodes);
      exit(1);
    }
    dc1394_free_camera_nodes(camera_nodes);

    /* set trigger mode */

    if( dc1394_set_trigger_mode(handle, camera.node, TRIGGER_MODE_0)
        != DC1394_SUCCESS)
    {
      fprintf( stderr, "unable to set camera trigger mode\n");
#if 0
      dc1394_release_camera(handle,&amp;camera);
      dc1394_destroy_handle(handle);
      exit(1);
#endif
    }

    /* have the camera start sending us data*/

    if (dc1394_start_iso_transmission(handle,camera.node)
        !=DC1394_SUCCESS) 
    {
      fprintf( stderr, "unable to start camera iso transmission\n");
      dc1394_release_camera(handle,&amp;camera);
      dc1394_destroy_handle(handle);
      exit(1);
    }

    /* capture one frame */

    if (dc1394_single_capture(handle,&amp;camera)!=DC1394_SUCCESS) 
    {
      fprintf( stderr, "unable to capture a frame\n");
      dc1394_release_camera(handle,&amp;camera);
      dc1394_destroy_handle(handle);
      exit(1);
    }

    /* Stop data transmission */

    if (dc1394_stop_iso_transmission(handle,camera.node)!=DC1394_SUCCESS)
    {
      printf("couldn't stop the camera?\n");
    }

    /* save image as 'Image.pgm' */

    imagefile=fopen(IMAGE_FILE_NAME, "w");

    if( imagefile == NULL)
    {
      perror( "Can't create '" IMAGE_FILE_NAME "'");
      dc1394_release_camera(handle,&amp;camera);
      dc1394_destroy_handle(handle);
      exit( 1);
    }

    /* Adding the pgm file header */

    fprintf(imagefile,"P5\n%u %u 255\n", camera.frame_width,
         camera.frame_height );

    /* Writing to the file */

    fwrite((const char *)camera.capture_buffer, 1,
         camera.frame_height*camera.frame_width, imagefile);
    fclose(imagefile);
    printf("wrote: " IMAGE_FILE_NAME "\n");

    /* Close camera */

    dc1394_release_camera(handle,&amp;camera);
    dc1394_destroy_handle(handle);
    return 0;
}
</screen>
   <calloutlist>
    <callout arearefs="header">
     <para>Include the header files, which means include:</para>
     <itemizedlist>
      <listitem><para><filename>libraw1394/raw1394.h</filename></para></listitem>
      <listitem><para><filename>libdc1394/dc1394_control.h</filename></para></listitem>
     </itemizedlist>
     <para>These are necessary in order to access functions of the library.</para>
    </callout>
    <callout arearefs="d_types">
     <para>Declare three variables of the following data types:</para>
     <itemizedlist>
      <listitem><para><varname>dc1394_cameracapture</varname></para></listitem>
      <listitem><para><varname>raw1394handle_t</varname></para></listitem>
      <listitem><para><varname>nodeid_t *</varname></para></listitem>
     </itemizedlist>
     <para>The <varname>raw1394handle_t</varname> and <varname>nodeid_t *</varname> are required to uniquely identify the camera. Moreover, <varname>raw1394handle_t</varname> is used to hold the handle that is created for the OHCI-compliant host card.</para>
    </callout>
    <callout arearefs="ohci">
     <para>Open ohci and assign a handle to it.</para>
     <para>This is done by:</para>
     <para><userinput>handle=dc1394_create_handle(0)</userinput></para>
     <para>Where <varname>handle</varname> is of the <type>raw1394handle_t</type>type> type. The parameter <parameter>0</parameter> refers to the position of the camera on host card (there may be more than one slot on the host card; 0 means that the camera is on the first slot ).</para>
     <para>If the wrong number is passed, the handle will not be created. </para>
    </callout>
    <callout arearefs="c_nodes">
     <para>Get camera nodes:</para>
     <para>There can be more than one camera node, since IEEE1394 supports multiple devices on a single port. But for our discussion we will assume that only a single camera is present. Here is how to get nodes:</para>
     <para>
<screen>
int numNodes = raw1394_get_nodecount(raw1394handle_t handle)
camera_nodes=dc1394_getcamera_nodes(handle,&amp;numCameras,1)
</screen></para>
     <para>If the number of cameras returned is <varname>numCameras &lt;1</varname>, this means no camera has been detected.</para>
     <para><varname>1</varname> in the function signifies that a printed description of the camera node found will be shown on the console.</para>
    </callout>
    <callout arearefs="condition">
     <para>Check the condition of <varname>camera_nodes[0]==numNodes -1</varname>. It must be false. The explanation for this is outside the scope of this document.</para>
    </callout>
    <callout arearefs="setup">
     <para>Call the setup function and pass the various parameters.
     For example, let us examine the setup function of the above
     example: </para>
<screen>
     dc1394_setup_capture(

/* handle and camera_nodes[0] uniquely identifies the camera */
     handle,
    camera_nodes[0],
    0, /* channel */

/*format of the Image */
    FORMAT_VGA_NONCOMPRESSED, MODE_640x480_MONO, /* mode of the image */
    SPEED_400, /* data speed */
    FRAMERATE_7_5, /*Frame rate */
    &amp;camera /*dc1394_cameracapture type pointer *./
    )!=DC1394_SUCCESS) 
</screen>
    <para>Our suggestion is that the various parameters should be first queried from the camera and then passed. This is helpful in a successful setup since often the user does not know actual values of the various parameters that have to be passed in the setup function call, and ends up passing the wrong values. In such situations the setup is not done correctly and the camera doesn't get initialized.</para>
    <para>We are listing the appropriate <function>get</function> functions that should be called first in order to obtain the correct values of the setup parameters:</para>
     <orderedlist>
      <listitem><para><function>dc1394_get_iso_channel_and_speed(handle,camera_nodes[0], &amp;channel,&amp;speed);</function> /* to get the channel and the data speed */</para></listitem>
      <listitem><para><function>dc1394_get_video_format(handle,camera_nodes[0],&amp;format);</function> /*to get the format */</para></listitem>
      <listitem><para><function>dc1394_get_video_framerate(handle,camera_nodes[0],&amp;framerate);</function> /* to get the framerate*/</para></listitem>
      <listitem><para><function>dc1394_get_video_mode(handle,camera_nodes[0],&amp;mode);</function> /* to get the mode */</para></listitem>
     </orderedlist>
    <para>So the above <function>dc1394_setup_capture</function>
    function call will look like this:</para>

<screen>
     dc1394_setup_capture(

/* handle and camera_nodes[0] uniquely identifies the camera */
     handle, 
     camera_nodes[0],

   /*we pass the variables instead of actual values */
     channel ,
     format, 
     mode, 
     speed,
     framerate,
     &amp;camera /*dc1394_cameracapture type pointer *./
     )!=DC1394_SUCCESS) 
</screen>
      </callout>   
      <callout arearefs="trigger">
       <para>Setting the trigger mode. This is generally not required. This is just like brightness:</para>
       <para><function>dc1394_set_trigger_mode(handle,camera.node,TRIGGER_MODE_0)</function> sets the trigger mode to 0.</para>
       <note>
        <title>Note on nodes:</title>
         <para>We have passed <varname>camera.node</varname> which indicates that the dc1394_cameracapture structure is being used and only the particular node for which the camera has been setup is being referred to, but we can also use <varname>camera_nodes[0]</varname>.</para>
       </note>
      </callout>
      <callout arearefs="c_send"><para>Have the camera start sending the data to the user. This is done by starting the ISO transmission. The following function is used: </para>
       <para><function>dc1394_start_iso_transmission(handle,camera.node)</function></para>
      </callout>
      <callout arearefs="c_frame"><para>Capture one frame by calling the function:</para>
       <para><function>dc1394_single_capture(handle,&amp;camera)</function></para>
       <para>Where <varname>camera</varname> is a pointer to the structure dc1394_cameracapture. This function will grab the image and store it in the buffer (capture_buffer) provided by the structure.</para>
       <para>In order to capture more than one frame use a for loop and place the function inside it:</para>
<screen>
for( i=0;i&lt;100 ;i++)/* to capture 100 images*/
dc1394_single_capture(handle,&amp;camera)
</screen>
      </callout>
      <callout arearefs="stop_d"><para>After the image has been grabbed, stop the data transmission by calling the following function:</para>
       <para><function>dc1394_stop_iso_transmission(handle,camera.node)</function></para>
      </callout>
      <callout arearefs="pgm_header"><anchor id="pgm_header_anchor" ></anchor><para>Add a PGM file header to the captured buffer to see the image using <application>gimp</application>.</para>
      </callout>
      <callout arearefs="fwrite"><para>Use <command>fwrite</command>
      to save the captured image, by writing the buffer
      (<parameter>camera.capture_buffer</parameter>) to a file. The
      other parameters like height and width of the image can be
      extracted from the same structure: <parameter>camera.frame_width</parameter>, <parameter>camera.frame_height</parameter>.</para>
      </callout>
      <callout arearefs="c_camera"><para>Close the camera. This step is necessary to prevent a memory leak:</para>
<screen>
dc1394_release_camera(handle,&amp;camera);
dc1394_destroy_handle(handle);
</screen>
       <para>In order to compile the program, use: <command>gcc -o
       grabImage grabImage.c -ldc1394_control -lraw1394</command>,
       where <filename>grabImage.c</filename> is your program.</para>
       </callout>
	</calloutlist>
      </screenco>
       <para>We hope that after going through this algorithmic way explanation you can comfortably understand the example code.</para>
       <para>If we used the Format7 image format, we would have to
       change only the <function>setup_capture</function> function. Let us look at the setup function:

<screen>
      dc1394_setup_format7_capture(
  /* handle and camera_nodes[0] uniquely identifies the camera */
            handle,
            camera_nodes[0],
            channel, /* channel */
            mode , /*mode */
            bytes_per_packet , 
            left ,/*area of interest start column */
            right, /*area of interest start row */
            width,/* area of interest width */
            height /* area of interest height */
           &amp;camera /* dc1394_cameracapture type pointer *./
            )!=DC1394_SUCCESS) 
</screen>
where the values of the parameters for channel, speed, bytes_per_packet, speed, mode are found using the following functions:</para>
       <orderedlist>
        <listitem><para><function>dc1394_get_iso_channel_and_speed(handle,camera_nodes[0], &amp;channel,&amp;speed)</function> /* to get the channel and the data speed */</para></listitem>
        <listitem><para><function>dc1394_get_video_mode(handle,camera_nodes[0] &amp;mode);</function> /* to get the mode */</para></listitem>
        <listitem><para><function>dc1394_query_format7_byte_per_packet(handle, camera_nodes[0], mode ,&amp;bytes_per_packet);</function> /* to get the bytes per packet which depends on the mode*/</para></listitem>
        <listitem><para>The value of left, top can be set to <envar>QUERY_FROM_CAMERA</envar>, or can be specified directly by the user.</para></listitem>
        <listitem><para>The value of the width and height depends on the size of frame the user wants, for example, if one wants 960x720 then pass 960 as width and 720 as height.</para></listitem>
       </orderedlist>
  </sect2>
  <sect2 id="dma-example">
   <title>Example: How to grab image from the IEEE1394 camera using DMA</title>
    <para>This section has been contributed by Ian Peikon <email><ulink url="mailto:idp2@duke.edu">idp2@duke.edu</ulink></email>and Tim Hanson <email><ulink url="mailto:tim@hardcarve.com">tim@hardcarve.com</ulink></email>
	We will now present an example of how to grab a frame by the camera using DMA calls. The example is simple to understand as the logic remains the same as the previous example. We will later compare the function calls used in the previous example (without dma) and this example (with dma) for better understanding.
</para>
<screen>
#include &lt;stdio.h&gt;
#include &lt;libraw1394/raw1394.h&gt;
#include &lt;libdc1394/dc1394_control.h&gt;
#include &lt;stdlib.h&gt;  
#include &lt;iostream&gt;
#define IMAGE_FILE_NAME "Image.pgm"
using namespace std;

int main(int arc, char *argv[]){
        FILE * imagefile;
        dc1394_cameracapture camera;
        int numNodes;
        int numCameras;
        raw1394handle_t handle;
        nodeid_t * camera_nodes;
        unsigned int channel, speed, format, framerate, mode;
        
        /*Step 1: Open ohci and assign a handle to it.*/
	/*=======================================================*/
	handle = dc1394_create_handle(0);
        if(handle==NULL){
                fprintf(stderr, "Unable to acquire a handle. \n\n");
        }
        else{
		 cout &lt;&lt;"dma1394: Handle aquired successfully-" &lt;&lt;handle&lt;&lt;"\n";
        }
        
/*Step 2: Get the camera nodes and describe them as we find them.*/
	/*=========================================================================*/
	numNodes = raw1394_get_nodecount(handle);
        camera_nodes = dc1394_get_camera_nodes(handle, &amp;numCameras, 1);
        fflush(stdout);
        if (numCameras&lt;1){
                fprintf(stderr, "No cameras found :( \n");
                dc1394_destroy_handle(handle);
                return -1;
        }
        else{
                cout&lt;&lt;"dma1394:"&lt;&lt; numCameras&lt;&lt;" cameras found. \n";
        }
        printf("dma1394: Working with the first camera on the bus.\n");
        if(camera_nodes[0] == numNodes-1){
                fprintf(stderr, "\n" "dma1394: Sorry, your camera is the highest numbered node.\n");
                dc1394_destroy_handle(handle);
                dc1394_free_camera_nodes(camera_nodes);
                return -1;
        }
        
/*Step 3: Setup Capture*/
	/*=====================================================================*/
	/*Using camera functions to get the params by querying them*/
	cout&lt;&lt;"INFO FOR DEBUG: \n"
                        "num_dma_buffers: "&lt;&lt; camera.num_dma_buffers&lt;&lt;"\n";
        dc1394_get_iso_channel_and_speed(handle, camera_nodes[0], &amp;channel, &amp;speed); /*get channel and speed*/
	dc1394_get_video_format(handle, camera_nodes[0], &amp;format); /*get format*/
	dc1394_get_video_framerate(handle, camera_nodes[0], &amp;framerate); /*get framerate*/
	dc1394_get_video_mode(handle, camera_nodes[0], &amp;mode); /*get mode*/
	cout&lt;&lt;"dc1394: Got parameters from the camera.\n"
                "=======================================\n"
                "Channel: "&lt;&lt; channel&lt;&lt; " \n"
                "Speed: " &lt;&lt;speed &lt;&lt;" \n"
                "Format: "&lt;&lt; format &lt;&lt;" \n"
                "Framerate: " &lt;&lt;framerate&lt;&lt; "\n"
                "Mode: "&lt;&lt; mode &lt;&lt;"\n";
        camera.num_dma_buffers = 8; /* set the dma buffers */
        camera.drop_frames = 1; /* set the number of drop frames */
        camera.dma_device_file = NULL;
        if(dc1394_dma_setup_capture(handle, camera_nodes[0], channel, format, mode, speed, framerate, camera.num_dma_buffers, camera.drop_frames, camera.dma_device_file, &amp;camera) !=DC1394_SUCCESS){
                fprintf(stderr, "dma1394: Unable to setup camera.\n" 
                                        "Check line %d of %s to ensure that the options set are supported by your camera.\n", __LINE__, __FILE__);
                dc1394_destroy_handle(handle);
                dc1394_free_camera_nodes(camera_nodes);
                return -1;
        }
        else{
                printf("dma1394: Capture has been setup.\n");
        }
        dc1394_free_camera_nodes(camera_nodes);

        //Set Trigger Mode -- Generally not required thus I will comment it out.
	/*if(dc1394_set_trigger_mode(handle, camera.node, TRIGGER_MODE_0) != DC1394_SUCCESS){
                fprintf(stderr, "dma1394: Unable to set the camera trigger mode. Refer to line %d in %s.\n", __LINE__, __FILE__);
                dc1394_release_camera(handle, &amp;camera);
                dc1394_destroy_handle(handle);
        }
        else{
                printf("dma1394: Successfully set trigger mode.\n");
        }*/
        
        /*Step 4: Start sending data */
	/*=======================================================*/
	if(dc1394_start_iso_transmission(handle, camera.node) != DC1394_SUCCESS){
                fprintf(stderr, "dma1394: Unable to start the data transmission.\n");
                dc1394_dma_done_with_buffer(&amp;camera);
				dc1394_dma_release_camera(handle, &amp;camera);
                dc1394_destroy_handle(handle);
                return -1;
        }
        else{
                printf("dma1394: Success.  Data Transmission started.\n");
        }
        
        /*Step 5: Capture Something...Anything...PLEASE*/
	/*===============================================================*/
	if(dc1394_dma_single_capture(&amp;camera) != DC1394_SUCCESS){
                fprintf(stderr, "dma1394; DAIM, can't capture a single frame.\n");
				dc1394_dma_done_with_buffer(&amp;camera); /*important step */
                dc1394_dma_release_camera(handle, &amp;camera);
                dc1394_destroy_handle(handle);
                return -1;
        }
        else{
                printf("dma1394: GREAT SUCCESS! Captured a single frame.\n");
        }
        
        /*Step 6: Stop sending data*/
	/*==================================================*/
	if(dc1394_dma_unlisten(handle, &amp;camera) != DC1394_SUCCESS){
        		fprintf(stderr, "Can't unlisten iso channel! \n");
        }
        else{
                printf("dma1394: DMA unlistened. \n");
        }
        
	if(dc1394_stop_iso_transmission(handle, camera.node) != DC1394_SUCCESS){
                fprintf(stderr, " Can't stop the camera!! \n");
        }
        else{
                printf("dma1394: Data transmission terminated. \n");
        }
        
        /*Step 7: Save our image*/
	/*===============================================================*/
	imagefile=fopen(IMAGE_FILE_NAME, "w");
        if(imagefile==NULL){
                perror("dma1394: Can't create' "IMAGE_FILE_NAME" ' ");
                dc1394_dma_done_with_buffer(&amp;camera);
				dc1394_dma_release_camera(handle, &amp;camera);
                dc1394_destroy_handle(handle);
                return -1;
        }
        else{
                cout&lt;&lt;"dma1394: Saved image in "&lt;&lt;IMAGE_FILE_NAME&lt;&lt;".\n";
        }
         /*Add pgm file header*/
	fprintf(imagefile, "P5\n%u %u 255\n", camera.frame_width, camera.frame_height);
       
		/*write to file*/
	fwrite((const char *)camera.capture_buffer, 1, camera.frame_height*camera.frame_width, imagefile);
        fclose(imagefile);
        printf("dma1394: wrote: " IMAGE_FILE_NAME "\n");
        
        /*Step 8: Close camera*/
	/*=============================================================*/
	dc1394_dma_done_with_buffer(&amp;camera);
	dc1394_dma_release_camera(handle, &amp;camera);
        dc1394_destroy_handle(handle);
        printf("dma1394: Camera released.  Exiting. \n");
        
        //Step END
	return 0;

}

  </screen>     

 <para>
Just like the previous example (<xref linkend="example"/>) the program includes the necessary header files(<filename>libraw1394/raw1394.h</filename> and <filename>libdc1394/dc1394_control.h</filename>) and then declare the three variables of the following data type
     <itemizedlist>
      <listitem><para><varname>dc1394_cameracapture</varname></para></listitem>
      <listitem><para><varname>raw1394handle_t</varname></para></listitem>
      <listitem><para><varname>nodeid_t *</varname></para></listitem>
     </itemizedlist>

After this the following steps are followed which are very similar to the previous example (<xref linkend="example"/>)
<orderedlist>
<listitem><para>Open ohci and assign handle to it using the function <function>dc1394_create_handle(0)</function></para></listitem>
<listitem><para>Get the camera nodes using the function <function>dc1394_get_camera_nodes</function></para></listitem>
<listitem><para>Find out various parameters need to be passed during the camera setup. This is done by querying the camera using the following functions</para>
<para>
  <itemizedlist>
  <listitem><para><function>dc1394_get_iso_channel_and_speed()</function>: To get the channel and speed information</para></listitem>
  <listitem><para><function>dc1394_get_video_format()</function>: To get the camera format</para></listitem>
  <listitem><para><function>dc1394_get_video_framerate()</function>: To get the framerate information</para></listitem>
  <listitem><para><function>dc1394_get_video_mode()</function>: To get the camera mode</para></listitem>
  </itemizedlist>
</para>
<para>
Also we are required to set the <varname>dma buffers</varname> to 8 and <varname>number of drop frames</varname> to 1.
Once the values of the parameter have been obtained (framerate,format,mode,channel,speed etc), they are passed in <function>dc1394_dma_setup_capture</function> which then sets up the camera and enables it for capturing video. For  DMA you must pass the number of dma buffers and drop frames parameter.</para>
</listitem>
<listitem><para>After the camera is set, <function>dc1394_start_iso_transmission()</function> is called. This function starts data transactions from the camera to the bus.</para></listitem>
<listitem><para>Now capture one frame using <function>dc1394_dma_single_capture()</function>. This function will capture a frame into the dma buffer</para>
<para>After the frame has been grabbed release the dma buffer using <function>dc1394_dma_done_with_buffer()</function>. This is required so that the memory can be reused. It is imperative that <function>dc1394_dma_done_with_buffer()</function> always follows a <function>dma_capture</function> function call</para>
<para>So in order to capture more than one frame the code will be
<screen>
for( i=0;i&lt;100 ;i++)/* to capture 100 images*/
	{
	dc1394_dma_single_capture(&amp;camera);
	dc1394_dma_done_with_buffer(&amp;camera);
	}
</screen>
</para>
</listitem>
<listitem><para>Stop listening to the iso channel by calling <function>dc1394_dma_unlisten()</function></para>
<para>Terminate the data transmission by calling <function>dc1394_stop_iso_transmission()</function></para></listitem>
<listitem><para>Save the image in a file and add a PGM header for viewing using <application>gimp</application>.</para></listitem>
<listitem><para>Finally call <function>dc1394_release_camera</function> to release the camera</para></listitem>
</orderedlist>
</para> 
<para>
If DMA is not setup correctly you will get the following error message:
</para>
<para><computeroutput>VIDEO1394_IOC_LISTEN_CHANNEL ioctl failed </computeroutput></para>
<para>
There are various reasons for this error which will be further explained in the Problems section (<xref linkend="common_problems"/>)
</para>
<para>
 Thus we can see that the image capture using DMA is not much different from non DMA method. We have compared the functions used in two approaches in the following table.
</para>
<informaltable frame="all">
<tgroup cols="3"><tbody>
<row>
<entry><para>Non DMA steps</para></entry>
<entry><para>DMA steps</para></entry>
<entry><para>Comments</para></entry>
</row>
<row>
<entry><para><function>dc1394_create_handle</function></para></entry>
<entry><para><function>dc1394_create_handle</function></para></entry>
<entry><para>Create handle</para></entry>
</row>
<row>
<entry><para><function>dc1394_get_camera_nodes</function></para></entry>
<entry><para><function>dc1394_get_camera_nodes</function></para></entry>
<entry><para>Get camera nodes</para></entry>
</row>
<row>
<entry><para><function>dc1394_setup_capture</function></para></entry>
<entry><para><function>dc1394_dma_setup_capture</function></para></entry>
<entry><para>Call setup functions to set various parameters of camera</para></entry>
</row>
<row>
<entry><para><function>dc1394_start_iso_transmission</function></para></entry>
<entry><para><function>dc1394_start_iso_transmission</function></para></entry>
<entry><para>Start sending the data from camera to the bus</para></entry>
</row>
<row>
<entry><para><function>dc1394_single_capture</function></para></entry>
<entry><para><function>dc1394_dma_single_capture</function>, <function>dc1394_dma_done_with_buffer</function></para></entry>
<entry><para>Capture one frame</para></entry>
</row>
<row>
<entry><para><function>dc1394_stop_iso_transmission</function></para></entry>
<entry><para><function>dc1394_dma_unlisten</function>, <function>dc1394_stop_iso_transmission</function></para></entry>
<entry><para>Stop sending the data from camera to the bus</para></entry>
</row>
<row>
<entry><para><function>dc1394_release_camera</function>, <function>dc1394_destroy_handle</function></para></entry>
<entry><para><function>dc1394_dma_done_with_buffer</function>, <function>dc1394_dma_release_camera</function>, <function>dc1394_destroy_handle</function></para></entry>
<entry><para>Close the camera</para></entry>
</row>


</tbody></tgroup>
</informaltable>

 
 </sect2>


  <sect2 id="get_color">
   <title>How to get color images: Bayer Pattern Concepts</title>
    <para>The image grabbed by the sample code in the previous section
    is not colored (we have intentionally used the words <quote>not colored,</quote> since the image is not gray-scale either). It is actually a Bayer Pattern. We will give an overview of Bayer Patterns and how they are used to get a colored image in this section.</para>
    <para>Digital cameras use a solid-state device called an <emphasis>image sensor</emphasis>. These fingernail-sized silicon chips contain millions of photosensitive diodes called <emphasis>photosites</emphasis>. When you take a picture with a digital camera, the intensity of light hitting each photo site on the sensor is recorded as a signal. Depending on the camera, either 12 or 14 bits of data are recorded. At 12 bits, the camera can record 4,096 levels of brightness. At 14 bits, the camera can record 16,384 levels of brightness. This is referred to as <emphasis>bit depth</emphasis>. The higher the bit depth, the finer is the detail, the smoother the transition between tones, and the higher the dynamic range (the ability of the camera to hold detail in both highlighted and shadowed areas). But at capture, digital images are grayscale, not color. To record color information, each pixel on the sensor is covered with a red, green, or blue filter, with the colors alternating. A common arrangement of color filters is the <citetitle>Bayer Pattern array</citetitle> that alternates colors, but that also uses twice as many green filters as red and blue. Twice as many green filters are used because our eyes are more sensitive to green. This pattern, or sequence, of filters can vary, but the widely adopted Bayer Pattern, which was invented at Kodak, is a repeating 2x2 arrangement. Each pixel has been made sensitive only to one color (one spectral band).</para>
    <para>A Typical Bayer Pattern will look like this:</para>
<figure><title>Bayer Pattern</title>
     <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig5.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig5.eps" format="EPS"></imagedata>
</imageobject>
    </mediaobject>
</figure>
    <para>The <emphasis>tile</emphasis> or <emphasis>square (pixel)</emphasis> labeled B means this particular tile is sensitive only to Blue light, and so on.</para>
    <para>The Bayer Patterns may be classified into 4 types, depending on how we have arranged the colors. The naming of the Bayer Pattern is done by taking a 2x2 matrix from the top most corner of the pattern and the colors being read in (0,0),(0,1),(1,0),(1,1) order. So for the above Bayer Pattern, if we take the 2x2 matrix as:</para>
<figure><title>BGGR Pattern</title>
     <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig6.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig6.eps" format="EPS"></imagedata>
</imageobject>
     </mediaobject>
</figure>
    <para>The pattern is therefore known as BGGR </para>
    <para>The other possible patterns are:</para>
<figure><title>Other Patterns</title>
     <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig7.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig7.eps" format="EPS"></imagedata>
</imageobject>
     </mediaobject>
</figure>
    
    <para>The image we obtained in the previous example was a Bayer
    Pattern image also known as a <emphasis>RAW</emphasis> image. This
    was stored in <varname>camera.capture_buffer</varname>. In order
    to view what we have captured we convert this RAW image to .PGM by
    adding a header (look at the explanation in <xref
    linkend="example"/>).</para>
    <para>In order to get a colored image, the Bayer Pattern image is
    converted to a <emphasis>RGB</emphasis> image. A RGB image is an enhanced version of the Bayer Pattern image; we try to find the value of the two missing colors at each pixel (remember that each pixel of the sensor is covered by Bayer Pattern filter so we get a single color at any pixel by default). This is done by using different algorithms like <emphasis>Nearest Neighbor</emphasis>,<emphasis> Edge Sense</emphasis>, and so on:
<figure><title>RAW to RGB</title>
     <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig8.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig8.eps" format="EPS"></imagedata>
</imageobject>
     </mediaobject>
</figure>
where the shaded values are to be calculated by the algorithm. Subscript denotes the tile on the Bayer Pattern to which the value of R, G, and B belongs. Note that the image size will become 3 times the Bayer Pattern. In order to view the RGB image we convert it to a Bit Map, or .BMP image, by adding a bitmap header.</para>
    <para>To get a clear picture of what's happening, we have provided the following diagram:</para>
<figure><title>Bayer to Bitmap conversion</title>
     <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig9.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig9.eps" format="EPS"></imagedata>
</imageobject>
    </mediaobject>
</figure> 
    <para>Let's understand how the RAW to RGB conversion algorithms
    work. We will look into the Nearest Neighbor algorithm in
    detail. Other Algorithms are thoroughly explained at the following
    web link: <ulink
    url="http://www-ise.stanford.edu/~tingchen/main.htm">http://www-ise.stanford.edu/~tingchen/main.htm</ulink>.</para>
    <para>Most of these algorithms make use of some kind of interpolations.</para>

   <sect3 id="nearest_alg">
    <title>Nearest Neighbor Algorithm</title>
     <para>In this interpolation method, each interpolated output pixel is assigned the value of the nearest pixel in the input image. The nearest neighbor can be any one of the upper, lower, left or right pixels.</para>
     <para>An example will make the logic clear. We try to find the G values for the R, B tiles for a 3x3 block (shown as shaded region. The blank squares either bear R value or B value. We have not shown them just to make the figure easy to understand). Here we assume the left neighboring pixel value is used to fill the missing ones.</para>
<figure><title>Nearest Neighbour</title>
      <mediaobject>
     <imageobject>
      <imagedata fileref="images/Fig10.jpg" format="JPG"></imagedata>
     </imageobject>
<imageobject>
	<imagedata fileref="images/Fig10.eps" format="EPS"></imagedata>
</imageobject>
     </mediaobject>
</figure>
     <para>The table on the left shows the G values for the Bayer Pattern image. In order to find out the missing G values for the other squares that originally contains only R or B we use the following approach:</para>
     <para>Find the nearest G value square and copy the G value of that square onto the R (B) square. This has been illustrated in the above figure. The square next to G7 had a value of either R or B. So to get G8 (a G value for square 8) we copied the G value of square 7, since it was the nearest so G8 = G7. Similarly we filled the other non G value squares.</para>
     <para>The same logic is applied when finding R and B values for the green squares.</para>
   </sect3>

   <sect3 id="sample_color_grab">
    <title>Example program to understand how the colored image is grabbed using IEEE1394 Camera</title>
     <para>Now that we have presented the basic concept of the RAW, RGB and the conversion algorithm, we feel that you can understand an example program that gives us a colored image.</para>
     <para>We have chosen the format as Format7 because the camera we
     used responds to this format only. We will make use of another
     example code which provides the implementation of the
     algorithms. The program is <filename>conversions.cpp</filename>,
     in the  <filename class="directory">grabdma</filename>
     folder, available for download at <ulink
     url="http://www.ptgrey.com/support/kb/data/grabdma.tgz">http://www.ptgrey.com/support/kb/data/grabdma.tgz</ulink>.</para>
     <para>To run the code, make sure that you have the following files: </para>
      <itemizedlist>
       <listitem><para><filename>conversions.h</filename></para></listitem>
       <listitem><para><filename>conversions.cpp</filename></para></listitem>
       <listitem><para><filename>grabcolor.cpp</filename> - also
       from the <filename class="directory">grabdma</filename>
       folder. We have modified the code according to our requirements
       and removed some of the lines. Since most of the code is same
       as the previously discussed code, we have explained only the
       portions that are different. These portions have been <emphasis>emphasized</emphasis>.</para></listitem>
      </itemizedlist>

<screen>
#include &lt;stdio.h&gt;
#include &lt;libraw1394/raw1394.h&gt;
#include &lt;libdc1394/dc1394_control.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;onversions.h&gt;

#define IMAGE "Image.rgb"

int main(int argc, char *argv[]) 
{
  FILE* imagefile;
  dc1394_cameracapture camera;
  int numNodes;
  int numCameras;
  raw1394handle_t handle;
  nodeid_t * camera_nodes;
  int channel,speed,mode,bytes_per_packet;

   /* Open ohci and asign handle to it */

    handle = dc1394_create_handle(0);
  if (handle==NULL)
  {
    fprintf( stderr, "Unable to aquire a raw1394 handle\n\n"
       "Please check \n"
         " - if the kernel modules `ieee1394',`raw1394' and `ohci1394' are loaded \n"
         " - if you have read/write access to /dev/raw1394\n\n");
exit(1);
  }

  /* get the camera nodes and describe them as we find them */

  numNodes = raw1394_get_nodecount(handle);
  camera_nodes = dc1394_get_camera_nodes(handle,&amp;numCameras,1);
  fflush(stdout);
  if (numCameras&lt;1)
  {
    fprintf( stderr, "no cameras found :(\n");
    dc1394_destroy_handle(handle);
    exit(1);
  }
  printf("working with the first camera on the bus\n");

  if( camera_nodes[0] == numNodes-1)
  {
    fprintf( stderr, "\n"
           "Sorry, your camera is the highest numbered node\n");
    dc1394_destroy_handle(handle);
    dc1394_free_camera_nodes(camera_nodes);
    exit( 1);
  }

  /*obtain the values of the parameter from the camera */

dc1394_get_video_mode(handle,camera_nodes[0],(unsigned int *)&amp;mode); 

dc1394_get_iso_channel_and_speed(handle,camera_nodes[0],
(unsigned int *)&amp;channel, (unsigned int *)&amp;speed);

dc1394_query_format7_byte_per_packet(handle,camera_nodes[0],(unsigned)
mode,&amp;bytes_per_packet);

  /*setup capture */

if (dc1394_setup_format7_capture(handle,
           camera_nodes[0],
         channel , /* channel */ 
         mode,
         speed,
         bytes_per_packet,
         0,
         0,
         960,
         720, 
         &amp;camera)!=DC1394_SUCCESS) 
  {
    fprintf( stderr,"unable to setup camera-\n"
         "check line %d of %s to make sure\n"
         "that the video mode,framerate and format are\n"
         "supported by your camera\n",
         __LINE__,__FILE__);
    dc1394_release_camera(handle,&amp;camera);
    dc1394_destroy_handle(handle);
    dc1394_free_camera_nodes(camera_nodes);
    exit(1);
  }
  dc1394_free_camera_nodes(camera_nodes);

  /* have the camera start sending us data*/

  if (dc1394_start_iso_transmission(handle,camera.node)
      !=DC1394_SUCCESS) 
  {
    fprintf( stderr, "unable to start camera iso transmission\n");
    dc1394_release_camera(handle,&amp;camera);
    dc1394_destroy_handle(handle);
    exit(1);
  }

  /* capture one frame */

  if (dc1394_single_capture(handle,&amp;camera)!=DC1394_SUCCESS) 
  {
    fprintf( stderr, "unable to capture a frame\n");
    dc1394_release_camera(handle,&amp;camera);
    dc1394_destroy_handle(handle);
    exit(1);
  }
<emphasis>
  /*query the camera to determine the Bayer pattern*/

quadlet_t qValue;
   GetCameraControlRegister( handle, 
              Camera_nodes[0],
              0x1040,/* Bayer Tile Mapping register */
              &amp;qValue );

   bayer_pattern_t pattern = BAYER_PATTERN_BGGR;
   switch( qValue )
   {
      case 0x42474752:/* BGGR */
       pattern = BAYER_PATTERN_BGGR;
       break;
      case 0x47524247:/* GRBG */
       pattern = BAYER_PATTERN_GRBG;
       break;
      case 0x52474742: /* RGGB */
       pattern = BAYER_PATTERN_RGGB;
       break;
      case 0x47425247:/* GBRG */
       pattern = BAYER_PATTERN_GBRG;
       break;
      case 0x59595959:/* YYYY = BW */
       fprintf( stderr, "Camera is black and white\n" );
       cleanup();
       return 1;
      default:
      fprintf(stderr,
          "Camera BAYER_TILE_MAPPING register has an unexpected value:\n"
          "\t0x%x\n", qValue );

      return 1;
   }

   int bufferSize = camera.frame_width*camera.frame_height;

   /* assign a buffer of size three time the original image */

   unsigned char* rgbBuffer = new unsigned char[3 * bufferSize];

   unsigned char* src = (unsigned char*)camera.capture_buffer;

   unsigned char* captureBuffer=
            (unsigned char*)camera.capture_buffer;
   for ( int i = 0; i &lt; bufferSize; i++ )
   {
       src[i] = captureBuffer[ i * bytesPerPixel ];
   }

   /* convert to color image */

   BayerNearestNeighbor (src, 
             rgbBuffer, 
             camera.frame_width,
             camera.frame_height,
             pattern );
</emphasis>

   /* Stop data transmission */

  if (dc1394_stop_iso_transmission(handle,camera.node)!=DC1394_SUCCESS) 
  {
  printf("couldn't stop the camera?\n");
  }

  /* save image as 'Image.rgb' without adding any pgm header */

  printf( "Saving the image...\n" );
  imagefile = fopen( IMAGE, "w" );

  fwrite( rgbBuffer, 3,
         bufferSize, imagefile );

  fclose( imagefile );

  /* Close camera */

  dc1394_release_camera(handle,&amp;camera);
  dc1394_destroy_handle(handle);
  return 0;
}

</screen>
    <para>As we have already discussed the use of
    <function>GetCameraControlRegister</function>, you can understand 
    that it has been used to find out the value contained at <varname>0x1040</varname>. Libdc1394 does not provide any function to query this address, so we explicitly used this call to get the value.</para>
    <para>It is important to understand the utility of the above
    function call. Refer to our discussion about the Bayer Pattern
    filters in the previous section. We know that the pattern can be
    BGGR, RGGB, GRBG, and GRBG. The algorithm that we use for
    converting the Bayer Pattern to RGB requires to know about the
    type of pattern the camera filter has got so that it can carry out
    some initialization (refer to <filename>conversions.cpp</filename> for details). The fourth parameter in the function call:</para>
<screen>
   BayerNearestNeighbor (src, 
             rgbBuffer, 
             camera.frame_width,
             camera.frame_height,
             pattern )
</screen>
    <para>refers to this value.</para>
    <para><function>BayerNearestNeighbor</function> is the function
    call for the interpolation algorithm we discussed in the last
    section. This is implemented in <filename>conversions.cpp</filename>.</para>
    <para>Having understood this, we move on to the
    <emphasis>switch-cases</emphasis>. The value that is obtained for
    the Bayer Pattern (<varname>qvalue</varname>) is in the hex form which needs to be decoded for setting the value of the variable <varname>pattern</varname>.</para>
    <para>The case statements indicate the various hex values relating
    to the Bayer Pattern that can be returned by the various cameras. The intimidating values are actually quite easy to decode. Here's the trick:</para>
    <para>The hex code for various colors is as follows:</para>
     <itemizedlist>
<!-- FIXME there were pipes (|) before the B and the R below.  I took them away because it was not proper UTF-8 encoding.  Are they needed? tille -->
      <listitem><para>42h -&gt; B</para></listitem>
      <listitem><para>47h -&gt; G</para></listitem>
      <listitem><para>52h -&gt; R</para></listitem>
     </itemizedlist>
    <para>Now if the <varname>qvalue</varname> contains 0x42474752, it means: B (42h) G (47h) G (47h) R (52h) or BGGR.  We can therefore decode all the case statements similarly.</para>
    <para>Finally, we need to declare another image buffer that will
    contain the RGB image. Remember that the size of the RGB is 3 times the
    size of the Bayer Pattern image.  <parameter>rgbbuffer</parameter>
    is therefore assigned 3 times the buffer size
    (<varname>camera.capture_buffer</varname>). This buffer
    (<parameter>rgbbuffer</parameter>) will be passed as the destination buffer (the second parameter in <function>BayerNearestNeighbor</function>).</para>
    <para>After the buffer has been filled with the RGB values we
    write it in the file <filename>image.rgb</filename>.</para>
    <para>In order to view this image using <application>gimp</application>, we need to append a bitmap header.  The method we employed was as follows: </para>
     <orderedlist>
      <listitem><para>Save the RGB image buffer in a file, say, <filename>image.rgb</filename>.</para></listitem>
      <listitem><para>Make a bitmap header and save it in a separate
      file, <filename>bmpheader</filename>.  Refer to <ulink
      url="http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html">http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html</ulink> for header details.</para></listitem>
      <listitem><para><command>cat bmpheader image.rgb
      &gt; bmpfile</command></para></listitem>
      <listitem><para>Open <filename>bmpfile</filename> using <application>gimp</application>.</para></listitem>
     </orderedlist>
    <para>In order to run the program, use the following steps:</para>
     <para>
<screen>
g++ -c conversions.cpp
g++ -o grabcolor conversions.o grabcolor.cpp -lraw1394
-ldc1394_control
</screen></para>
    <note>
     <title>Note on available algorithms:</title>
      <para>There are many algorithms that are available in <filename>conversions.cpp</filename>, so depending upon the requirements, you can call the necessary functions.</para>
    </note>
<para>The <application>Coriander</application> application is useful in finding out how the RGB image will look after undergoing different conversion algorithms. For example, it provides the choice between Nearest Neighbor, Edge Sense and Down Sample conversion algorithms. The difference can be observed on a mouse click.</para>
   </sect3>
  </sect2>

  <sect2 id="common_problems">
   <title>Common Problems Faced While Working With IEEE1394 Cameras</title>
    <para>We now look at some of the common problems faced while working with the camera, however we have only listed those problems which we faced. These problems are likely to be faced by anyone who uses the library and the camera. Some of the problems were solved with a proper reasoning but some were just hit-and-miss attempts. The problems and their solutions are listed below.</para>
    <itemizedlist>
      <listitem>
       <formalpara>
       <title>Problem #1</title>
       <para>After the installation of the library and the modules the
       camera did not respond</para>
       </formalpara>
       <formalpara>
       <title>Solution:</title><para><emphasis>We disconnected the camera and
       connected it again. May be this has to be repeated multiple
       times. We could not figure out an appropriate reason for this
       but it works.</emphasis></para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
       <title>Problem #2</title>
       <para>Program is not compiling</para>
       </formalpara>
       <formalpara>
       <title>Solution:</title><para><emphasis>If one forgets to link
       the executable with raw1394 and dc1394_control the program
       won't compile.</emphasis> The correct way is:
<screen>
gcc -o xx xx.c -lraw1394 -ldc1394_control /*for C files*/
g++ -o xx xx.cpp -lraw1394 -ldc1394_control /* for Cpp files */
</screen></para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
       <title>Problem #3</title>
       <para>Compilation failed, giving the error:
       <computeroutput>libdc1394_control.so.13: cannot open the shared
       object file</computeroutput>.</para>
       </formalpara>
       <formalpara>
       <title>Solution:</title><para><emphasis>Check for the
environment variable <envar>LD_LIBRARY_PATH</envar>. This should
contain the path of the shares library. On our system the path was
<filename class="directory">/usr/local/lib</filename>. The path must
be set accordingly.</emphasis></para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
       <title>Problem #4</title>
       <para>Program hangs when executed.</para>
       </formalpara>
       <formalpara>
       <title>Solution:</title><para><emphasis>This primarily happens
       if the values of parameters that are passed to the setup
       function are not supported by the camera. For e.g. setting the mode
       mode_640x480_MONO16 when it is not supported. Our suggestion is
       that one should always query for the values and then pass them
       to the function (as explained in the example code, located in
       <xref linkend="example" />)</emphasis>.</para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
       <title>Problem #5</title>
       <para><computeroutput>IDEO1394_IOC_LISTEN_CHANNEL ioctl
       failed</computeroutput> error message being displayed.</para>
       </formalpara>
       <formalpara>
       <title>Solution: (contributed by Ian and Tim)</title><para><emphasis>There are various reasons for this error message. Type <command>dmesg</command> in the command prompt to gain a better understanding of the problem. Here is a list of problem we ran into</emphasis>
	   <itemizedlist>
	   <listitem><para><emphasis>Channel 0 is not being used- This means you are listening on the iso channel and then calling a capture function again. Make sure not to call <function>dma_unlisten</function> until you are ready to stop iso transmission.</emphasis></para>
	   </listitem>
	   <listitem><para><emphasis>Channel 0 is already being used- This means you have set two camera nodes to the same Channel. Fix your <function>dma_setup_capture()</function>. This could also mean that you have tried to call the setup function more than once without releasing the camera between the calls. This error is more likely to occur when you are working with more than one camera.</emphasis></para></listitem>
	   <listitem><para><emphasis>Buffer 0 is already being used- This means that you have not freed the DMA buffer before trying to write to it again. Make sure to alternate <function>dma_done_with_buffer calls with dma_capture_calls</function></emphasis></para></listitem>
	   </itemizedlist>
	   </para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
       <title>Problem #6</title>
       <para>Used <keycombo
       action="simul"><keycap>CTRL</keycap><keycap>C</keycap></keycombo>
       to terminate the image grabbing program, but the next time the
       program is run, it just hangs.</para>
       </formalpara>
       <formalpara>
       <title>Solution:</title><para><emphasis>The error usually
       occurs because the camera functions like a pipe and experiences
       a broken pipe situation if terminated without flushing the
       memory channels. The trick is to disconnect the camera and
       connect it again. One can also try debugging the problem by
       reinstalling the ohci1394, video1394, raw1394, video1394
       modules, which works occasionally.</emphasis></para>
       </formalpara>
      </listitem>
      <listitem>
       <formalpara>
       <title>Problem #7</title>
       <para>Every parameter is okay and the installation is also
       fine, but even then, when the program is executed the camera is
       still not detected.</para>
       </formalpara>
       <formalpara>
       <title>Solution:</title><para><emphasis>This is a strange problem which we also face frequently. The solution is based on trial and error, but it always works:</emphasis>
       <orderedlist>
        <listitem><para>Disconnect the camera first and then reconnect it.</para></listitem>
        <listitem><para>Now run <application>Coriander</application>
        (that's why we suggest that you install <application>Coriander</application> before you start working with the camera).</para></listitem>
        <listitem><para>Make all the necessary adjustments; for example, select the mode of the camera, the frame size, and so forth.</para></listitem>
        <listitem><para>Close <application>Coriander</application>.</para></listitem>
        <listitem><para>Execute your program.</para></listitem>
       </orderedlist>
      Bingo!!! It works.</para>
      </formalpara>
      <note>
       <title>Note on first step above:</title>
       <para>The first step is critical since we experienced an error
       message from <application>Coriander</application> about not
       finding the camera if we did not disconnect and reconnect the camera before running <application>Coriander</application>.</para>
      </note>
     </listitem>
    </itemizedlist>
  </sect2>
</sect1>

<sect1 id="references">
<title>References</title>
  <orderedlist>
   <listitem><para><ulink
   url="http://kauri.auck.irl.cri.nz/~johanns/libdc1394/libdc1394_FAQ.html">http://kauri.auck.irl.cri.nz/~johanns/libdc1394/libdc1394_FAQ.html</ulink>,
   <citetitle>libdc1394 FAQ</citetitle> by Johann Schoonees.</para></listitem>
   <listitem><para><ulink url="http://www.ptgrey.com/">http://www.ptgrey.com/</ulink></para></listitem>
   <listitem><para><ulink url="http://www-ise.stanford.edu/~tingchen">http://www-ise.stanford.edu/~tingchen</ulink></para></listitem>
   <listitem><para><ulink
   url="http://damien.douxchamps.net/ieee1394/coriander/manual.php">http://damien.douxchamps.net/ieee1394/coriander/manual.php</ulink></para></listitem>
   <listitem><para><citetitle>Point Grey Dragonfly Camera Technical Reference Manual, Version 2.1.2.1.3</citetitle></para></listitem>
   <listitem><para><citetitle>Raw Capture: A Second Chance to Get it Right</citetitle>, by Charlotte K. Lowrie, 2005-09-01</para></listitem>
   <listitem><para><ulink url="http://www.linuxfocus.org/">http://www.linuxfocus.org</ulink></para></listitem>
   <listitem><para><ulink
   url="http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html">http://www.fortunecity.com/skyscraper/windows/364/bmpffrmt.html</ulink></para></listitem>
  </orderedlist>
</sect1>

<appendix id="a">
<title>Appendix A</title>

<sect1 id="license">
<title>License</title>
<para>This document, <citetitle>Libdc1394 Library support for IEEE
1394 Cameras HOWTO</citetitle>, is copyrighted &#169; 2005 by Rohit
Agarwal &amp; Vikram B. Permission is granted to copy, distribute
and/or modify this document under the terms of the GNU Free
Documentation License, Version 1.2 or any later version published by
the Free Software Foundation; with no Invariant Sections, with no
Front-Cover Texts, and with no Back-Cover Texts. A copy of the license
is available at <ulink url="http://www.gnu.org/copyleft/fdl.html">http://www.gnu.org/copyleft/fdl.html</ulink>.</para>
</sect1>

<sect1 id="disclaimer">
<title>Disclaimer</title>
<para>Although we have tried to do our best to bring out this HOWTO in
a good form, we are not responsible for any damage due to the actions
taken based upon the information contained in this document. It is
impossible to test things under all the configurations, so probably
some of the hints given in this document may be incorrect and may not
work on your system. In case you find anything wrong, let us know it
first. We will rewrite the document as soon as possible. This document
is provided <quote>as is</quote>. We put great effort into writing it as accurately as we could, but you are using the information contained herein at your own risk. In no event shall we be liable for any damages resulting from the use of this work.</para>
</sect1>

<sect1 id="authors">
 <title>About Authors</title>
 <para>Rohit Agarwal and Vikram B are pursuing their Masters Degrees in IT from the International Institute of Information Technology, Bangalore, India.</para>
 <para>They can be contacted at:</para>
 <itemizedlist>
  <listitem><para>rohdimp_24@rediffmail.com &lt;Rohit&gt;</para></listitem>
  <listitem><para>vickys_box@rediffmail.com &lt;Vikram&gt;</para></listitem>
 </itemizedlist>
</sect1>

<sect1 id="dedications">
 <title>Dedications</title>
 <para>We are grateful to all our friends for their support. We would specially like to thank Chinmay Narayan our batch mate for his valuable advices. We would like to dedicate this document to our Professor, Mr. S. Nagrajan, for he is the one who motivated us to contribute to the open source community.</para>
 </sect1>
</appendix>
</article>
